# Project Readiness Quiz
# Formative Assessment pentru verificarea pregătirii studenților înainte de proiecte
# Format: YAML pentru parsare ușoară și integrare cu sisteme de evaluare

quiz:
  title: "Verificare Pregătire Proiect SO - SEM-PROJ"
  description: |
    Acest quiz verifică dacă aveți cunoștințele necesare pentru a începe
    lucrul la proiectul semestrial. Parcurgeți întrebările pentru a vă
    autoevalua pregătirea. Score recomandat: minim 70%.
  passing_score: 70
  time_limit_minutes: 30
  
sections:
  - name: "Fundamentele Bash"
    weight: 25
    questions:
      - id: bash_01
        type: multiple_choice
        difficulty: easy
        question: |
          Care este diferența dintre `$var` și `${var}`?
        options:
          a: "Nu există nicio diferență"
          b: "${var} permite concatenare și manipulări (ex: ${var}_suffix)"
          c: "$var este pentru numere, ${var} pentru stringuri"
          d: "${var} este deprecated"
        correct: b
        explanation: |
          `${var}` permite delimitare clară a numelui variabilei și operații
          precum ${var:-default}, ${var%pattern}, ${var#prefix}.
          
      - id: bash_02
        type: multiple_choice
        difficulty: easy
        question: |
          Ce face linia `set -euo pipefail` la începutul unui script?
        options:
          a: "Setează variabile de mediu"
          b: "Oprește scriptul la erori, variabile nedefinite și erori în pipeline"
          c: "Activează modul debug"
          d: "Dezactivează expansiunea glob"
        correct: b
        explanation: |
          -e: exit on error, -u: error on undefined variable,
          -o pipefail: pipeline fails if any command fails.
          Aceasta este best practice pentru scripturi robuste.
          
      - id: bash_03
        type: multiple_choice
        difficulty: medium
        question: |
          Care este output-ul următorului cod?
          ```bash
          arr=(a b c d)
          echo ${#arr[@]}
          ```
        options:
          a: "a b c d"
          b: "4"
          c: "abcd"
          d: "Error: syntax error"
        correct: b
        explanation: |
          ${#arr[@]} returnează numărul de elemente din array.
          ${arr[@]} returnează toate elementele, ${arr[0]} primul element.
          
      - id: bash_04
        type: multiple_choice
        difficulty: medium
        question: |
          Cum citiți un fișier linie cu linie într-un while loop, corect?
        options:
          a: "for line in $(cat file); do"
          b: "while read line; do ... done < file"
          c: "cat file | while read line; do"
          d: "Ambele b și c sunt corecte"
        correct: b
        explanation: |
          Varianta b este preferată. Varianta c creează un subshell,
          deci variabilele setate în loop nu persistă. Varianta a
          face word splitting și sparge liniile la spații.
          
      - id: bash_05
        type: code_completion
        difficulty: hard
        question: |
          Completați codul pentru a procesa opțiuni cu getopts:
          ```bash
          while getopts "v:o:h" opt; do
              case $opt in
                  v) VERBOSE=________ ;;
                  o) OUTPUT=________ ;;
                  h) show_help; exit 0 ;;
                  *) echo "Invalid option"; exit 1 ;;
              esac
          done
          ```
        answer: ["$OPTARG", "$OPTARG"]
        explanation: |
          $OPTARG conține valoarea argumentului pentru opțiunile
          care necesită argumente (cele urmate de : în optstring).

  - name: "Comenzi și Utilitare"
    weight: 25
    questions:
      - id: cmd_01
        type: multiple_choice
        difficulty: easy
        question: |
          Care comandă găsește toate fișierele .log modificate în ultimele 24 ore?
        options:
          a: "find . -name '*.log' -mtime -1"
          b: "find . -name '*.log' -mtime 1"
          c: "find . -name '*.log' -mmin -1440"
          d: "Ambele a și c"
        correct: d
        explanation: |
          -mtime -1 înseamnă modificat în mai puțin de 1 zi.
          -mmin -1440 înseamnă modificat în mai puțin de 1440 minute (24 ore).
          -mtime 1 (fără minus) înseamnă exact între 1 și 2 zile.
          
      - id: cmd_02
        type: multiple_choice
        difficulty: medium
        question: |
          Care comandă extrage coloana 3 dintr-un CSV cu delimiter ','?
        options:
          a: "cut -d, -f3 file.csv"
          b: "awk -F, '{print $3}' file.csv"
          c: "sed 's/.*,\\([^,]*\\),.*/\\1/' file.csv"
          d: "Ambele a și b sunt corecte"
        correct: d
        explanation: |
          cut -d, -f3 și awk -F, '{print $3}' fac același lucru.
          AWK este mai flexibil pentru procesări complexe.
          
      - id: cmd_03
        type: multiple_choice
        difficulty: medium
        question: |
          Ce face comanda `grep -v '^#' file | grep -v '^$'`?
        options:
          a: "Afișează doar comentariile"
          b: "Elimină comentariile și liniile goale"
          c: "Numără liniile cu #"
          d: "Înlocuiește # cu spațiu"
        correct: b
        explanation: |
          -v inversează match-ul. ^# match linii care încep cu #.
          ^$ match linii goale. Rezultat: linii care nu sunt comentarii
          și nu sunt goale - util pentru parsare configurări.
          
      - id: cmd_04
        type: multiple_choice
        difficulty: hard
        question: |
          Care comandă sortează procesele după utilizarea memoriei (descrescător)?
        options:
          a: "ps aux --sort=-rss"
          b: "ps aux | sort -k4 -n -r"
          c: "top -o %MEM"
          d: "Toate sunt corecte"
        correct: d
        explanation: |
          ps aux --sort=-rss sortează direct.
          sort -k4 -n -r sortează coloana 4 numeric descrescător.
          top -o %MEM sortează în interfață.
          
      - id: cmd_05
        type: code_completion
        difficulty: hard
        question: |
          Completați pentru a găsi fișierele duplicate după hash MD5:
          ```bash
          find . -type f -exec md5sum {} \; | ________ | ________ | cut -d' ' -f2-
          ```
        answer: ["sort", "uniq -d -w32"]
        explanation: |
          sort: sortează după hash pentru a grupa duplicatele.
          uniq -d -w32: afișează doar duplicatele, comparând primele 32 caractere (hash-ul MD5).

  - name: "Procese și Sistem"
    weight: 25
    questions:
      - id: proc_01
        type: multiple_choice
        difficulty: easy
        question: |
          Care semnal este trimis implicit de `kill <pid>`?
        options:
          a: "SIGKILL (9)"
          b: "SIGTERM (15)"
          c: "SIGHUP (1)"
          d: "SIGINT (2)"
        correct: b
        explanation: |
          SIGTERM (15) este implicit și permite procesului să facă cleanup.
          SIGKILL (9) forțează terminarea fără cleanup.
          SIGHUP este pentru "hang up", SIGINT pentru Ctrl+C.
          
      - id: proc_02
        type: multiple_choice
        difficulty: medium
        question: |
          Cum rulați o comandă în background și o detașați de terminal?
        options:
          a: "command &"
          b: "nohup command &"
          c: "command & disown"
          d: "Ambele b și c"
        correct: d
        explanation: |
          nohup previne SIGHUP la închiderea terminalului.
          disown elimină job-ul din lista shell-ului.
          Ambele permit comenzii să continue după logout.
          
      - id: proc_03
        type: multiple_choice
        difficulty: medium
        question: |
          Ce informații oferă fișierul /proc/[pid]/status?
        options:
          a: "Doar PID și PPID"
          b: "Starea procesului, memorie, threads, capabilities"
          c: "Doar utilizarea CPU"
          d: "Istoricul comenzilor procesului"
        correct: b
        explanation: |
          /proc/[pid]/status conține: State, Pid, PPid, Uid, Gid,
          VmSize, VmRSS, Threads, și multe altele.
          Este o sursă completă de informații despre proces.
          
      - id: proc_04
        type: multiple_choice
        difficulty: hard
        question: |
          Care este diferența dintre proces zombie și proces orfan?
        options:
          a: "Zombie: terminat dar nepreluat; Orfan: părinte mort, adoptat de init"
          b: "Zombie: fără memorie; Orfan: fără CPU"
          c: "Nu există diferență"
          d: "Zombie: adoptat de init; Orfan: terminat"
        correct: a
        explanation: |
          Zombie: proces terminat al cărui exit status nu a fost
          preluat de părinte cu wait(). Ocupă slot în process table.
          Orfan: proces al cărui părinte a murit; este adoptat de init (PID 1).
          
      - id: proc_05
        type: code_completion
        difficulty: hard
        question: |
          Completați trap-ul pentru cleanup la terminare:
          ```bash
          cleanup() {
              rm -f "$TMPFILE"
              kill "$BG_PID" 2>/dev/null
          }
          trap ________ EXIT
          trap ________ INT TERM
          ```
        answer: ["cleanup", "cleanup"]
        explanation: |
          EXIT trap se execută la orice ieșire din script.
          INT TERM trap se execută la Ctrl+C și kill.
          Best practice: trap cleanup pe ambele pentru robustețe.

  - name: "Networking și Securitate"
    weight: 15
    questions:
      - id: net_01
        type: multiple_choice
        difficulty: easy
        question: |
          Care comandă verifică dacă portul 80 este deschis pe localhost?
        options:
          a: "nc -zv localhost 80"
          b: "ping localhost:80"
          c: "telnet localhost 80"
          d: "Ambele a și c"
        correct: d
        explanation: |
          nc -zv face scan rapid (-z) cu verbose (-v).
          telnet poate conecta și permite interacțiune.
          ping nu poate specifica porturi (ICMP nu are porturi).
          
      - id: net_02
        type: multiple_choice
        difficulty: medium
        question: |
          Ce înseamnă permisiunea 4755 pe un executabil?
        options:
          a: "rwxr-xr-x cu SUID bit"
          b: "rwxrwxrwx"
          c: "r--r--r-x"
          d: "rwxr-xr-x normal"
        correct: a
        explanation: |
          4xxx = SUID bit. Când este executat, procesul rulează
          cu permisiunile owner-ului, nu ale utilizatorului.
          2xxx = SGID, 1xxx = sticky bit.
          
      - id: net_03
        type: multiple_choice
        difficulty: hard
        question: |
          Care comandă afișează toate conexiunile TCP stabilite, cu PID?
        options:
          a: "netstat -tuln"
          b: "ss -tnp state established"
          c: "lsof -i TCP"
          d: "Ambele b și c"
        correct: d
        explanation: |
          ss -tnp state established: TCP, numeric, cu PID, doar established.
          lsof -i TCP: listează fișierele (sockeți) TCP cu PID.
          netstat -tuln afișează LISTENING, nu established.

  - name: "Proiect și Best Practices"
    weight: 10
    questions:
      - id: proj_01
        type: multiple_choice
        difficulty: easy
        question: |
          Ce trebuie să conțină README.md-ul proiectului?
        options:
          a: "Doar titlul"
          b: "Descriere, instalare, utilizare, exemple"
          c: "Doar codul sursă"
          d: "Doar cerințele hardware"
        correct: b
        explanation: |
          README.md complet include: descriere, cerințe/dependențe,
          instrucțiuni instalare, exemple de utilizare, contribuții.
          
      - id: proj_02
        type: multiple_choice
        difficulty: medium
        question: |
          Care este structura recomandată pentru un proiect Bash?
        options:
          a: "Un singur fișier mare"
          b: "src/, lib/, tests/, docs/, etc/, Makefile"
          c: "Doar fișierul principal și README"
          d: "Nu există standard"
        correct: b
        explanation: |
          Structura modulară permite: cod organizat în lib/,
          teste separate, documentație în docs/, configurări în etc/.
          Makefile orchestrează build, test, install.
          
      - id: proj_03
        type: multiple_choice
        difficulty: medium
        question: |
          Cum verificați că scriptul vostru nu are erori de stil?
        options:
          a: "bash -n script.sh"
          b: "shellcheck script.sh"
          c: "chmod +x și rulare"
          d: "Ambele a și b"
        correct: d
        explanation: |
          bash -n: verifică sintaxa fără a executa.
          shellcheck: analizează cod pentru erori și bad practices.
          Ambele sunt esențiale pentru cod de calitate.

# Scoring și feedback
scoring:
  easy: 1
  medium: 2
  hard: 3

feedback:
  90-100: |
    Excelent! Sunteți pregătit să abordați orice nivel de proiect.
    Recomandare: proiect MEDIUM sau ADVANCED.
  70-89: |
    Bine! Aveți o bază solidă.
    Recomandare: proiect EASY sau MEDIUM.
    Revizuiți secțiunile cu scor mai mic.
  50-69: |
    Trebuie să mai exersați.
    Recomandare: proiect EASY.
    Parcurgeți seminarul corespunzător pentru secțiunile slabe.
  0-49: |
    Pregătire insuficientă.
    Recomandare: revizuiți materialele de curs și seminarii
    înainte de a începe proiectul. Consultați tutoriale suplimentare.

# Mapare la seminarii pentru studiu suplimentar
study_resources:
  "Fundamentele Bash":
    - "Seminar 2: Variabile și expansiuni"
    - "Seminar 3: Controlul fluxului"
  "Comenzi și Utilitare":
    - "Seminar 4: Procesare text (grep, sed, awk)"
    - "Seminar 5: Căutare și manipulare fișiere"
  "Procese și Sistem":
    - "Seminar 2: Procese și semnale"
    - "Seminar 6: Monitorizare sistem"
  "Networking și Securitate":
    - "Seminar 7: Networking basics"
    - "Seminar 8: Securitate"
  "Proiect și Best Practices":
    - "Seminar 1: Introducere și structură proiecte"
    - "Ghidul de stil Bash (docs/)"
