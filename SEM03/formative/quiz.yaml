# ═══════════════════════════════════════════════════════════════════════════════
# Quiz Formativ — Seminarul 03: System Administration
# Sisteme de Operare | ASE București - CSIE
# ═══════════════════════════════════════════════════════════════════════════════
# Versiune: 1.0 | Data: Ianuarie 2025
# Subiecte: find, xargs, getopts, permisiuni Unix, CRON
# Distribuție Bloom: Remember 20%, Understand 25%, Apply 35%, Analyse 15%, Evaluate 5%
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  seminar: 3
  titlu: "System Administration: find, xargs, getopts, permisiuni, CRON"
  versiune: "1.0"
  data_creare: "2025-01"
  limba: "ro"
  nivel: "începător"
  durata_estimata_minute: 25
  punctaj_total: 100
  prag_promovare: 60
  distributie_bloom:
    remember: 3      # 20%
    understand: 4    # 25%
    apply: 5         # 35%
    analyse: 2       # 15%
    evaluate: 1      # 5%

instructiuni: |
  Acest quiz verifică înțelegerea conceptelor de administrare sistem în Linux.
  Răspunde la toate întrebările. Există o singură variantă corectă.
  Timpul recomandat: 25 minute.

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 1: FIND ȘI XARGS
# ═══════════════════════════════════════════════════════════════════════════════

intrebari:
  # ─────────────────────────────────────────────────────────────────────────────
  # Q01: REMEMBER - Sintaxă find
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q01
    sectiune: "find și xargs"
    tip: mcq
    bloom: remember
    punctaj: 6
    text: |
      Care opțiune a comenzii `find` specifică tipul de fișier căutat?
    optiuni:
      - "-type"
      - "-name"
      - "-size"
      - "-mtime"
    corect: 0
    explicatie: |
      Opțiunea `-type` specifică tipul: `f` pentru fișiere, `d` pentru directoare,
      `l` pentru symlink-uri. Exemplu: `find . -type f` găsește doar fișiere.
    misconceptii:
      1: "Confundă -name (caută după nume, nu tip)"
      2: "Confundă -size (caută după dimensiune)"
      3: "Confundă -mtime (caută după dată modificare)"
    referinta: "docs/S03_02_MATERIAL_PRINCIPAL.md#find"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q02: UNDERSTAND - find vs locate
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q02
    sectiune: "find și xargs"
    tip: mcq
    bloom: understand
    punctaj: 7
    text: |
      Tocmai ai creat un fișier nou: `touch ~/test.txt`
      Imediat rulezi: `locate test.txt`
      
      Ce se întâmplă?
    optiuni:
      - "Găsește fișierul instant"
      - "Nu găsește fișierul (baza de date nu e actualizată)"
      - "Eroare - locate nu caută în home"
      - "Găsește toate fișierele test.txt, inclusiv cel nou"
    corect: 1
    explicatie: |
      `locate` folosește o bază de date pre-indexată care se actualizează periodic
      (de regulă noaptea prin cron). Fișierele noi nu apar până la `sudo updatedb`.
      Folosește `find` pentru căutări în timp real.
    misconceptii:
      0: "Crede că locate face căutare live ca find"
      2: "Nu înțelege scopul lui locate"
      3: "Confundă cu comportamentul lui find"
    referinta: "docs/S03_03_PEER_INSTRUCTION.md#PI-01"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q03: APPLY - Construire comandă find
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q03
    sectiune: "find și xargs"
    tip: mcq
    bloom: apply
    punctaj: 8
    text: |
      Vrei să găsești toate fișierele `.log` mai mari de 10MB modificate
      în ultimele 7 zile. Care comandă e corectă?
    optiuni:
      - "find . -name '*.log' -size +10M -mtime -7"
      - "find . -name '*.log' -size 10M -mtime 7"
      - "find . -type f '*.log' -size +10M -mtime -7"
      - "find . -name *.log -size +10M -mtime -7"
    corect: 0
    explicatie: |
      Corect: `-name '*.log'` (pattern cu ghilimele), `-size +10M` (mai mare de),
      `-mtime -7` (modificat în ultimele 7 zile). Semnul + înseamnă "mai mare",
      semnul - la mtime înseamnă "în ultimele N zile".
    misconceptii:
      1: "Lipsește + la size, lipsește - la mtime"
      2: "Sintaxă greșită: -type nu ia pattern direct"
      3: "Lipsesc ghilimelele la pattern (shell expandează prematur)"
    referinta: "docs/S03_05_LIVE_CODING_GUIDE.md#LC-01"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q04: UNDERSTAND - Precedență operatori find
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q04
    sectiune: "find și xargs"
    tip: mcq
    bloom: understand
    punctaj: 7
    text: |
      Ce returnează această comandă?
      
      ```bash
      find . -type f -name "*.txt" -o -name "*.md"
      ```
    optiuni:
      - "Toate fișierele .txt și toate fișierele .md"
      - "Toate FIȘIERELE .txt și ORICE (fișier sau director) .md"
      - "Eroare de sintaxă"
      - "Nimic - condițiile se exclud reciproc"
    corect: 1
    explicatie: |
      AND are precedență mai mare decât OR în find!
      Se interpretează: `(-type f AND -name "*.txt") OR (-name "*.md")`
      Soluția corectă: `find . -type f \( -name "*.txt" -o -name "*.md" \)`
    misconceptii:
      0: "Nu înțelege precedența operatorilor"
      2: "Sintaxa e validă, nu produce eroare"
      3: "Condițiile nu se exclud, OR le combină"
    referinta: "docs/S03_03_PEER_INSTRUCTION.md#PI-02"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q05: APPLY - xargs cu spații
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q05
    sectiune: "find și xargs"
    tip: mcq
    bloom: apply
    punctaj: 8
    text: |
      Ai fișiere cu spații în nume. Care combinație e sigură?
    optiuni:
      - "find . -name '*.txt' | xargs rm"
      - "find . -name '*.txt' -print0 | xargs -0 rm"
      - "find . -name '*.txt' -exec rm {} +"
      - "Atât B cât și C sunt corecte"
    corect: 3
    explicatie: |
      Ambele variante sunt corecte pentru fișiere cu spații:
      - `-print0 | xargs -0` folosește null ca separator
      - `-exec {} +` grupează argumentele și le pasează direct
      Varianta A eșuează pentru "document important.txt" (devine 2 argumente).
    misconceptii:
      0: "xargs implicit separă după spații - periculos!"
      1: "Corect, dar nu e singura soluție"
      2: "Corect, dar nu e singura soluție"
    referinta: "docs/S03_03_PEER_INSTRUCTION.md#PI-04"

  # ═══════════════════════════════════════════════════════════════════════════════
  # SECȚIUNEA 2: GETOPTS ȘI PARAMETRI SCRIPT
  # ═══════════════════════════════════════════════════════════════════════════════

  # ─────────────────────────────────────────────────────────────────────────────
  # Q06: REMEMBER - Variabile speciale
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q06
    sectiune: "getopts și parametri"
    tip: mcq
    bloom: remember
    punctaj: 6
    text: |
      Care variabilă conține numărul de argumente pasate unui script?
    optiuni:
      - "$#"
      - "$@"
      - "$*"
      - "$0"
    corect: 0
    explicatie: |
      `$#` = numărul de argumente (count)
      `$@` = toate argumentele ca listă
      `$*` = toate argumentele ca string
      `$0` = numele scriptului
    misconceptii:
      1: "Confundă cu lista argumentelor"
      2: "Confundă cu string-ul argumentelor"
      3: "Confundă cu numele scriptului"
    referinta: "docs/S03_02_MATERIAL_PRINCIPAL.md#parametri"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q07: UNDERSTAND - Diferența $@ vs $*
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q07
    sectiune: "getopts și parametri"
    tip: mcq
    bloom: understand
    punctaj: 7
    text: |
      Script apelat cu: `./script.sh "Hello World" Test`
      
      Câte elemente iterează `for arg in "$@"`?
    optiuni:
      - "1 element"
      - "2 elemente"
      - "3 elemente"
      - "4 elemente"
    corect: 1
    explicatie: |
      Cu ghilimele duble, `"$@"` păstrează argumentele originale:
      - Argument 1: "Hello World" (un singur argument)
      - Argument 2: "Test"
      Total: 2 elemente. Fără ghilimele, ar fi 3 ("Hello", "World", "Test").
    misconceptii:
      0: "Crede că totul devine un singur string"
      2: "Confundă cu comportamentul fără ghilimele"
      3: "Numără și numele scriptului"
    referinta: "docs/S03_03_PEER_INSTRUCTION.md#PI-07"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q08: APPLY - getopts
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q08
    sectiune: "getopts și parametri"
    tip: mcq
    bloom: apply
    punctaj: 8
    text: |
      Pentru a parsa `-v` (flag) și `-f FILE` (cu argument), care e corect?
    optiuni:
      - 'while getopts "vf" opt; do'
      - 'while getopts "v:f:" opt; do'
      - 'while getopts "vf:" opt; do'
      - 'while getopts ":vf" opt; do'
    corect: 2
    explicatie: |
      Două puncte (`:`) după literă înseamnă "necesită argument".
      - `v` = flag simplu (fără argument)
      - `f:` = opțiune cu argument obligatoriu
      Deci: `"vf:"` e corect.
    misconceptii:
      0: "Nici v nici f nu primesc argument"
      1: "Ambele primesc argument (greșit pentru -v)"
      3: ": la început = silent error mode, nu rezolvă problema"
    referinta: "docs/S03_05_LIVE_CODING_GUIDE.md#LC-03"

  # ═══════════════════════════════════════════════════════════════════════════════
  # SECȚIUNEA 3: PERMISIUNI UNIX
  # ═══════════════════════════════════════════════════════════════════════════════

  # ─────────────────────────────────────────────────────────────────────────────
  # Q09: REMEMBER - Permisiuni octal
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q09
    sectiune: "permisiuni Unix"
    tip: mcq
    bloom: remember
    punctaj: 6
    text: |
      Ce permisiuni reprezintă valoarea octală `755`?
    optiuni:
      - "rwxr-xr-x"
      - "rwxrwxrwx"
      - "rw-r--r--"
      - "rwx------"
    corect: 0
    explicatie: |
      7 = rwx (4+2+1), 5 = r-x (4+0+1), 5 = r-x (4+0+1)
      Owner: read+write+execute, Group: read+execute, Others: read+execute
      Tipic pentru scripturi executabile.
    misconceptii:
      1: "777 = rwxrwxrwx"
      2: "644 = rw-r--r--"
      3: "700 = rwx------"
    referinta: "docs/S03_02_MATERIAL_PRINCIPAL.md#permisiuni"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q10: UNDERSTAND - Efect chmod
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q10
    sectiune: "permisiuni Unix"
    tip: mcq
    bloom: understand
    punctaj: 7
    text: |
      Un fișier are permisiunile `rw-r--r--`. După `chmod g+w file`, ce permisiuni are?
    optiuni:
      - "rw-rw-r--"
      - "rwxrw-r--"
      - "rw-r--rw-"
      - "rw-rwxr--"
    corect: 0
    explicatie: |
      `g+w` = adaugă write pentru group
      Inițial: rw- r-- r-- (owner, group, others)
      După: rw- rw- r-- (group primește w)
    misconceptii:
      1: "Confundă cu adăugare x"
      2: "Confundă g (group) cu o (others)"
      3: "Adaugă prea multe permisiuni"
    referinta: "docs/S03_05_LIVE_CODING_GUIDE.md#LC-04"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q11: ANALYSE - Diagnostic permisiuni
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q11
    sectiune: "permisiuni Unix"
    tip: mcq
    bloom: analyse
    punctaj: 9
    text: |
      Un script `backup.sh` are permisiunile `rw-r--r--`.
      Rulezi `./backup.sh` și primești "Permission denied".
      
      Care e problema și soluția?
    optiuni:
      - "Lipsește permisiunea execute; soluție: chmod +x backup.sh"
      - "Lipsește permisiunea read; soluție: chmod +r backup.sh"
      - "Fișierul e owned de root; soluție: sudo ./backup.sh"
      - "Shebang-ul e greșit; soluție: verifică prima linie"
    corect: 0
    explicatie: |
      Pentru a rula un script cu `./script.sh`, ai nevoie de permisiune execute.
      `rw-r--r--` = 644 nu include x. Soluția: `chmod +x backup.sh` sau `chmod 755 backup.sh`.
      Alternativ, poți rula cu `bash backup.sh` (nu necesită x).
    misconceptii:
      1: "Read e pentru citire conținut, nu execuție"
      2: "Owner-ul nu e problema aici"
      3: "Shebang afectează interpretorul, nu permisiunile"
    referinta: "docs/S03_06_EXERCITII_SPRINT.md#permissions"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q12: APPLY - SUID/SGID
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q12
    sectiune: "permisiuni Unix"
    tip: mcq
    bloom: apply
    punctaj: 8
    text: |
      Vrei ca un script să ruleze cu permisiunile owner-ului, nu ale celui
      care îl execută. Ce faci?
    optiuni:
      - "chmod u+s script.sh"
      - "chmod g+s script.sh"
      - "chmod +t script.sh"
      - "chmod 777 script.sh"
    corect: 0
    explicatie: |
      SUID (Set User ID): `chmod u+s` sau `chmod 4755`
      Scriptul rulează cu UID-ul owner-ului.
      ATENȚIE: SUID pe scripturi e ignorat în majoritatea sistemelor moderne!
      Se folosește pentru binare precum /usr/bin/passwd.
    misconceptii:
      1: "SGID (g+s) = rulează cu GID-ul grupului"
      2: "Sticky bit (+t) = protejează ștergerea în directoare"
      3: "777 dă permisiuni, nu schimbă identitatea"
    referinta: "docs/S03_02_MATERIAL_PRINCIPAL.md#suid-sgid"

  # ═══════════════════════════════════════════════════════════════════════════════
  # SECȚIUNEA 4: CRON
  # ═══════════════════════════════════════════════════════════════════════════════

  # ─────────────────────────────────────────────────────────────────────────────
  # Q13: REMEMBER - Format crontab
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q13
    sectiune: "CRON"
    tip: mcq
    bloom: remember
    punctaj: 6
    text: |
      Care e ordinea câmpurilor într-o linie crontab?
    optiuni:
      - "minut oră zi_lună lună zi_săptămână comandă"
      - "oră minut zi_lună lună zi_săptămână comandă"
      - "minut oră lună zi_lună zi_săptămână comandă"
      - "zi_săptămână lună zi_lună oră minut comandă"
    corect: 0
    explicatie: |
      Format crontab: `m h dom mon dow command`
      - m = minut (0-59)
      - h = oră (0-23)
      - dom = day of month (1-31)
      - mon = lună (1-12)
      - dow = day of week (0-7, 0 și 7 = duminică)
    misconceptii:
      1: "Inversează minut și oră"
      2: "Inversează lună și zi"
      3: "Ordine complet greșită"
    referinta: "docs/S03_02_MATERIAL_PRINCIPAL.md#cron"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q14: UNDERSTAND - Interpretare crontab
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q14
    sectiune: "CRON"
    tip: mcq
    bloom: understand
    punctaj: 7
    text: |
      Ce face această linie crontab?
      
      ```
      30 2 * * 1 /home/user/backup.sh
      ```
    optiuni:
      - "Rulează backup.sh în fiecare luni la 2:30 AM"
      - "Rulează backup.sh pe 2 ale fiecărei luni la 00:30"
      - "Rulează backup.sh în fiecare zi la 2:30 AM"
      - "Rulează backup.sh o dată pe lună, luni"
    corect: 0
    explicatie: |
      30 = minutul 30, 2 = ora 2, * = orice zi, * = orice lună, 1 = luni
      Deci: în fiecare luni la 02:30 dimineața.
    misconceptii:
      1: "Confundă poziția oră cu zi_lună"
      2: "Ignoră câmpul zi_săptămână (1=luni)"
      3: "Nu înțelege combinația câmpurilor"
    referinta: "docs/S03_03_PEER_INSTRUCTION.md#PI-15"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q15: APPLY - Scriere crontab
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q15
    sectiune: "CRON"
    tip: mcq
    bloom: apply
    punctaj: 8
    text: |
      Vrei să rulezi un script la fiecare 15 minute. Care linie e corectă?
    optiuni:
      - "*/15 * * * * /path/script.sh"
      - "15 * * * * /path/script.sh"
      - "0-15 * * * * /path/script.sh"
      - "0,15,30,45 * * * * /path/script.sh"
    corect: 0
    explicatie: |
      `*/15` = la fiecare 15 minute (0, 15, 30, 45)
      `15 * * * *` = doar la minutul 15 al fiecărei ore
      Varianta D e echivalentă cu A, dar A e mai elegantă.
    misconceptii:
      1: "Rulează doar o dată pe oră, la minutul 15"
      2: "0-15 = minutele 0-15, nu interval de 15"
      3: "Corect funcțional, dar ineficient"
    referinta: "docs/S03_05_LIVE_CODING_GUIDE.md#LC-05"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q16: ANALYSE - Debugging cron
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q16
    sectiune: "CRON"
    tip: mcq
    bloom: analyse
    punctaj: 9
    text: |
      Un cron job nu rulează. Scriptul funcționează manual.
      Linia crontab: `0 3 * * * backup.sh`
      
      Care e cea mai probabilă cauză?
    optiuni:
      - "Lipsește calea absolută către script"
      - "Ora 3 nu există (daylight saving)"
      - "Cron daemon nu rulează"
      - "Permisiuni insuficiente pe crontab"
    corect: 0
    explicatie: |
      Cron rulează cu un PATH minimal. `backup.sh` fără cale absolută nu e găsit.
      Soluție: folosește `/home/user/backup.sh` sau setează PATH în crontab.
      Alte cauze comune: variabile de mediu lipsă, output neredirectat.
    misconceptii:
      1: "DST e o problemă rară, nu prima de verificat"
      2: "Dacă scriptul rulează manual, daemon-ul funcționează"
      3: "Eroarea ar fi diferită pentru permisiuni"
    referinta: "docs/S03_07_LLM_AWARE_EXERCISES.md#cron-debug"

  # ─────────────────────────────────────────────────────────────────────────────
  # Q17: EVALUATE - Alegere strategie
  # ─────────────────────────────────────────────────────────────────────────────
  - id: q17
    sectiune: "Evaluare generală"
    tip: mcq
    bloom: evaluate
    punctaj: 10
    text: |
      Trebuie să procesezi 10,000 de fișiere .log, ștergând liniile goale.
      Care abordare e cea mai eficientă?
    optiuni:
      - "for f in *.log; do sed -i '/^$/d' \"$f\"; done"
      - "find . -name '*.log' -exec sed -i '/^$/d' {} \\;"
      - "find . -name '*.log' -exec sed -i '/^$/d' {} +"
      - "find . -name '*.log' | xargs sed -i '/^$/d'"
    corect: 2
    explicatie: |
      Varianta C cu `+` grupează fișierele și apelează sed o singură dată
      (sau de câteva ori pentru loturi mari). E mult mai eficient decât:
      - A/B: pornește un proces sed pentru FIECARE fișier (10,000 procese)
      - D: probleme cu spații în nume (ar trebui -print0 | xargs -0)
    misconceptii:
      0: "Funcționează, dar 10,000 de fork-uri = lent"
      1: "\\; = un sed per fișier, ineficient"
      3: "Probleme cu spații, nu e robust"
    referinta: "docs/S03_03_PEER_INSTRUCTION.md#PI-03"

# ═══════════════════════════════════════════════════════════════════════════════
# SUMARUL DISTRIBUȚIEI
# ═══════════════════════════════════════════════════════════════════════════════
#
# Remember (3):    Q01, Q06, Q09, Q13           = 24 puncte
# Understand (4):  Q02, Q04, Q07, Q10, Q14      = 35 puncte
# Apply (5):       Q03, Q05, Q08, Q12, Q15      = 40 puncte
# Analyse (2):     Q11, Q16                     = 18 puncte
# Evaluate (1):    Q17                          = 10 puncte
# ───────────────────────────────────────────────────────────────────────────────
# TOTAL:           17 întrebări                 = 127 puncte (scalat la 100)
# ═══════════════════════════════════════════════════════════════════════════════
