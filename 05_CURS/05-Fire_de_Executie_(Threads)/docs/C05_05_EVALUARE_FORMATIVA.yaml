# C05_05_EVALUARE_FORMATIVA.yaml
# Curs 5: Fire de Execuție (Threads)
# Evaluare Formativă — Quiz Conceptual

metadata:
  curs: 5
  subiect: "Fire de Execuție (Threads)"
  versiune: "2.0"
  data_creare: "2026-01-28"
  autor: "by Revolvix"
  numar_intrebari: 12
  timp_estimat_minute: 15
  distributie_bloom:
    remember: 3
    understand: 5
    analyse: 3
    apply: 1

intrebari:
  # ═══════════════════════════════════════════════════════════════════════════
  # REMEMBER (3 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q01
    bloom: remember
    dificultate: usor
    text: "Ce este un thread (fir de execuție)?"
    optiuni:
      - "Un proces independent"
      - "Cea mai mică unitate de execuție, partajează spațiul de adrese cu alte thread-uri din același proces"
      - "Un tip de memorie"
      - "Un fișier executabil"
    corect: 1
    explicatie: "Thread = lightweight process, partajează codul, datele și resursele procesului, are stack propriu."

  - id: q02
    bloom: remember
    dificultate: usor
    text: "Ce partajează thread-urile din același proces?"
    optiuni:
      - "Nimic, sunt complet izolate"
      - "Codul, datele globale, heap-ul, fișierele deschise"
      - "Doar stack-ul"
      - "Doar registrele CPU"
    corect: 1
    explicatie: "Thread-urile partajează tot spațiul de adrese (cod, date, heap) și resursele; fiecare are stack propriu."

  - id: q03
    bloom: remember
    dificultate: usor
    text: "Ce NU partajează thread-urile din același proces?"
    optiuni:
      - "Codul programului"
      - "Variabilele globale"
      - "Stack-ul, registrele CPU, thread ID"
      - "Fișierele deschise"
    corect: 2
    explicatie: "Fiecare thread are stack propriu, registre proprii și TID; restul e partajat."

  # ═══════════════════════════════════════════════════════════════════════════
  # UNDERSTAND (5 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q04
    bloom: understand
    dificultate: mediu
    text: "De ce crearea unui thread este mai rapidă decât fork()?"
    optiuni:
      - "Thread-urile nu au nevoie de memorie"
      - "Nu trebuie duplicat spațiul de adrese, doar alocat un stack nou"
      - "Thread-urile nu rulează cod"
      - "Fork() este depreciat"
    corect: 1
    explicatie: "Thread-ul reutilizează spațiul de adrese existent; fork() trebuie să creeze/copieze întregul spațiu."

  - id: q05
    bloom: understand
    dificultate: mediu
    text: "Care este diferența între user-level threads și kernel-level threads?"
    optiuni:
      - "Nu există diferență"
      - "User threads sunt gestionate de bibliotecă, kernel threads de SO; kernel threads pot rula în paralel pe multi-core"
      - "Kernel threads sunt mai lente"
      - "User threads nu pot face I/O"
    corect: 1
    explicatie: "User threads: invizibile kernel-ului, rapide dar fără paralelism real. Kernel threads: overhead mai mare dar paralelism adevărat."

  - id: q06
    bloom: understand
    dificultate: mediu
    text: "Ce model de threading folosesc majoritatea sistemelor moderne (Linux, Windows)?"
    optiuni:
      - "Many-to-One"
      - "One-to-One (1:1)"
      - "Many-to-Many"
      - "None-to-None"
    corect: 1
    explicatie: "Modelul 1:1 mapează fiecare user thread la un kernel thread, permițând paralelism complet."

  - id: q07
    bloom: understand
    dificultate: mediu
    text: "De ce thread-urile sunt numite 'lightweight processes'?"
    optiuni:
      - "Consumă mai puțină energie"
      - "Au overhead mai mic la creare/switch și partajează resurse"
      - "Sunt mai lente"
      - "Nu pot accesa hardware"
    corect: 1
    explicatie: "Thread-urile au context mai mic de salvat/restaurat și nu necesită duplicare de resurse."

  - id: q08
    bloom: understand
    dificultate: mediu
    text: "Ce problemă poate apărea când un thread modifică o variabilă globală?"
    optiuni:
      - "Variabila devine read-only"
      - "Race condition: alte thread-uri pot citi valori inconsistente"
      - "Programul se termină"
      - "Memoria se dublează"
    corect: 1
    explicatie: "Accesul concurrent nesincronizat la date partajate poate cauza race conditions și comportament imprevizibil."

  # ═══════════════════════════════════════════════════════════════════════════
  # ANALYSE (3 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q09
    bloom: analyse
    dificultate: greu
    text: "Un server web creează un thread per cerere. De ce este mai eficient decât fork() per cerere?"
    optiuni:
      - "Thread-urile nu pot gestiona cereri"
      - "Thread-urile partajează cache-ul, conexiunile DB, și au overhead de creare/switch mult mai mic"
      - "Fork() este mai rapid"
      - "Nu există diferență"
    corect: 1
    explicatie: "Thread-urile reutilizează resursele procesului și au overhead minim; fork() duplică totul."

  - id: q10
    bloom: analyse
    dificultate: greu
    text: "Pe un sistem cu 4 core-uri, câte thread-uri CPU-bound ar trebui să creezi pentru performanță optimă?"
    optiuni:
      - "1 thread"
      - "4 thread-uri (unul per core)"
      - "100 thread-uri"
      - "8 thread-uri"
    corect: 1
    explicatie: "Pentru CPU-bound: #threads ≈ #cores. Mai multe thread-uri doar adaugă overhead de context switch."

  - id: q11
    bloom: analyse
    dificultate: greu
    text: "De ce modelul Many-to-One nu poate exploata paralelismul pe multi-core?"
    optiuni:
      - "Nu are suficientă memorie"
      - "Toate user thread-urile sunt mapate la un singur kernel thread, deci SO vede un singur context"
      - "Este prea rapid"
      - "Nu suportă I/O"
    corect: 1
    explicatie: "Cu un singur kernel thread, SO-ul planifică totul pe un singur core, indiferent de câte user threads există."

  # ═══════════════════════════════════════════════════════════════════════════
  # APPLY (1 întrebare)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q12
    bloom: apply
    dificultate: greu
    text: "Implementezi un program care citește fișiere mari și le procesează. Ce strategie de threading alegi?"
    optiuni:
      - "Un singur thread pentru tot"
      - "Thread separat pentru I/O și thread-uri worker pentru procesare (producer-consumer)"
      - "Un thread per octet"
      - "Nu folosești thread-uri"
    corect: 1
    explicatie: "Separarea I/O de procesare permite paralelism: I/O thread citește, worker threads procesează în pipeline."
