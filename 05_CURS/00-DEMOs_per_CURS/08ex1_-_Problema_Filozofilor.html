<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problema Filozofilor la Cină: Explorare Interactivă OS</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Font Awesome for Icons (using CDN for vivid UI elements) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Chosen Palette: Warm Stone & Academic Blue
         Background: #f5f5f4 (Stone 100)
         Primary Text: #1c1917 (Stone 900)
         Accents: 
            - Thinking: #60a5fa (Blue 400)
            - Hungry: #fbbf24 (Amber 400)
            - Eating: #4ade80 (Green 400)
            - Deadlock: #ef4444 (Red 500)
    -->

    <style>
        /* Custom Chart Container Styles as per requirements */
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }

        /* Circular Table Layout Helpers */
        .philosopher-avatar {
            transition: all 0.3s ease;
        }
        
        .fork {
            transition: all 0.3s ease;
        }

        /* Status Glow Effects */
        .status-thinking { box-shadow: 0 0 10px rgba(96, 165, 250, 0.5); border-color: #60a5fa; }
        .status-hungry { box-shadow: 0 0 15px rgba(251, 191, 36, 0.8); border-color: #fbbf24; animation: pulse-hungry 1s infinite; }
        .status-eating { box-shadow: 0 0 20px rgba(74, 222, 128, 0.6); border-color: #4ade80; background-color: #ecfdf5; }
        .status-deadlock { box-shadow: 0 0 20px rgba(239, 68, 68, 0.9); border-color: #ef4444; background-color: #fef2f2; }

        @keyframes pulse-hungry {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f5f5f4;
            color: #1c1917;
        }
    </style>

    <!-- Application Structure Plan:
         1. Header: Hook and Introduction.
         2. Main Interactive Area (Grid):
            - Left: The Visual Simulation (The Round Table). Central focus for "vivid" description.
            - Right: Controls & Metrics (The OS Scheduler/Monitor).
         3. Concept Mapping: Explaining the metaphor in OS terms (Process, Resource, Deadlock).
         4. Footer: Summary.
         
         Why this structure?
         The user needs to SEE the deadlock to understand it. Putting the visualizer side-by-side with 
         controls allows for immediate cause-and-effect learning ("I clicked Deadlock, and the circle stopped").
    -->
</head>
<body class="bg-stone-100 min-h-screen flex flex-col">

    <!-- Navigation / Header -->
    <header class="bg-white shadow-sm sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <i class="fa-solid fa-utensils text-stone-700 text-xl"></i>
                <h1 class="text-xl md:text-2xl font-bold text-stone-800 tracking-tight">OS Interactive: Problema Filozofilor</h1>
            </div>
            <div class="text-sm font-medium text-stone-500 bg-stone-100 px-3 py-1 rounded-full">
                Sisteme de Operare & Sincronizare
            </div>
        </div>
    </header>

    <main class="flex-grow max-w-7xl mx-auto px-4 py-8 w-full space-y-12">

        <!-- Intro Section -->
        <section class="max-w-4xl mx-auto text-center space-y-4">
            <h2 class="text-3xl font-extrabold text-stone-900">Un Experiment Mental despre Concurență</h2>
            <p class="text-lg text-stone-600 leading-relaxed">
                Imaginează-ți 5 filozofi la o masă rotundă. Ei fac doar două lucruri: <strong>gândesc</strong> și <strong>mănâncă</strong>. 
                Pentru a mânca, au nevoie de două furculițe (una din stânga, una din dreapta). Problema? Sunt doar 5 furculițe în total.
                În sistemele de operare, aceasta este metafora perfectă pentru <strong>procese</strong> care sunt în competiție pentru <strong>resurse limitate</strong>.
            </p>
        </section>

        <!-- Simulation Dashboard -->
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 items-start">
            
            <!-- Left Column: The Visual Table (Simulation) -->
            <div class="lg:col-span-7 bg-white rounded-2xl shadow-xl p-6 border border-stone-200 relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-blue-400 via-amber-400 to-green-400"></div>
                
                <div class="mb-6">
                    <h3 class="text-xl font-bold text-stone-800 flex items-center gap-2">
                        <i class="fa-solid fa-eye text-blue-500"></i> Vizualizare Masă
                    </h3>
                    <p class="text-sm text-stone-500 mt-1">
                        Observă stările în timp real. Cercurile sunt filozofii, barele sunt furculițele.
                    </p>
                </div>

                <!-- The Table UI Container -->
                <div class="relative w-full aspect-square max-w-[500px] mx-auto bg-stone-50 rounded-full border-4 border-stone-200 shadow-inner flex items-center justify-center" id="table-container">
                    
                    <!-- Center Decor -->
                    <div class="absolute inset-0 m-auto w-32 h-32 rounded-full bg-stone-200 flex items-center justify-center text-center p-2 opacity-50">
                        <span class="text-xs font-mono text-stone-500">Resurse Partajate (Memorie/I/O)</span>
                    </div>

                    <!-- Elements generated by JS: Philosophers and Forks -->
                    <div id="simulation-stage" class="w-full h-full relative">
                        <!-- JS renders here -->
                    </div>
                </div>

                <!-- Legend -->
                <div class="mt-6 flex flex-wrap justify-center gap-4 text-xs font-bold text-stone-600">
                    <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-blue-400"></div> Gândește (Idle)</div>
                    <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-amber-400 animate-pulse"></div> Îi e Foame (Waiting)</div>
                    <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-green-400"></div> Mănâncă (Active)</div>
                    <div class="flex items-center gap-2"><div class="w-3 h-3 rounded-full bg-red-500"></div> Blocat (Deadlock)</div>
                </div>
            </div>

            <!-- Right Column: Controls & Analysis -->
            <div class="lg:col-span-5 space-y-6">
                
                <!-- Controls Panel -->
                <div class="bg-white rounded-xl shadow-lg p-6 border border-stone-200">
                    <h3 class="text-lg font-bold text-stone-800 mb-4 border-b pb-2">Panou de Control (Scheduler)</h3>
                    
                    <div class="space-y-4">
                        <!-- Algorithm Selector -->
                        <div>
                            <label class="block text-sm font-semibold text-stone-600 mb-2">Strategie Alocare Resurse:</label>
                            <select id="algorithm-select" class="w-full p-2 border border-stone-300 rounded-lg bg-stone-50 focus:ring-2 focus:ring-blue-500 outline-none transition-all">
                                <option value="naive">Abordare Naivă (Risc de Deadlock)</option>
                                <option value="hierarchy">Ierarhia Resurselor (Soluția Dijkstra)</option>
                            </select>
                            <p id="algo-desc" class="text-xs text-stone-500 mt-1 italic">
                                Fiecare filozof ia furculița din stânga, apoi așteaptă pentru cea din dreapta. Rețeta dezastrului.
                            </p>
                        </div>

                        <!-- Action Buttons -->
                        <div class="grid grid-cols-2 gap-3">
                            <button id="btn-start" class="bg-stone-800 hover:bg-stone-700 text-white py-2 px-4 rounded-lg font-medium transition-colors flex items-center justify-center gap-2">
                                <i class="fa-solid fa-play"></i> Start Simulare
                            </button>
                            <button id="btn-stop" class="bg-white border border-stone-300 hover:bg-stone-100 text-stone-700 py-2 px-4 rounded-lg font-medium transition-colors hidden">
                                <i class="fa-solid fa-pause"></i> Pauză
                            </button>
                            <button id="btn-force-deadlock" class="bg-red-50 text-red-600 border border-red-200 hover:bg-red-100 py-2 px-4 rounded-lg font-medium transition-colors flex items-center justify-center gap-2">
                                <i class="fa-solid fa-bomb"></i> Forțează Deadlock
                            </button>
                        </div>
                        
                        <!-- Reset -->
                        <button id="btn-reset" class="w-full text-sm text-stone-500 hover:text-stone-800 underline">Resetează Sistemul</button>
                    </div>

                    <!-- System Status Log -->
                    <div class="mt-6">
                        <h4 class="text-xs font-uppercase text-stone-400 font-bold mb-2">System Log (Kernel)</h4>
                        <div id="system-log" class="h-32 bg-stone-900 rounded-lg p-3 overflow-y-auto font-mono text-xs text-green-400 shadow-inner">
                            <div class="text-stone-500">> System initialized...</div>
                            <div class="text-stone-500">> Waiting for scheduler...</div>
                        </div>
                    </div>
                </div>

                <!-- Stats Chart -->
                <div class="bg-white rounded-xl shadow-lg p-6 border border-stone-200">
                    <h3 class="text-lg font-bold text-stone-800 mb-2">Eficiență & Echitate (Starvation Monitor)</h3>
                    <p class="text-xs text-stone-500 mb-4">Monitorizează numărul de mese (accese la secțiunea critică) per filozof.</p>
                    
                    <div class="chart-container">
                        <canvas id="statsChart"></canvas>
                    </div>
                </div>

            </div>
        </div>

        <!-- Educational Content: Mapping Concepts -->
        <section class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="col-span-1 md:col-span-3">
                <h2 class="text-2xl font-bold text-stone-800 mb-2">Decodificarea Problemei</h2>
                <p class="text-stone-600">Cum se traduce această cină ciudată în lumea reală a calculatoarelor?</p>
            </div>

            <!-- Concept Card 1 -->
            <div class="bg-white p-6 rounded-xl border-l-4 border-blue-500 shadow-sm hover:shadow-md transition-shadow">
                <div class="flex items-center gap-3 mb-3">
                    <div class="bg-blue-100 p-2 rounded-lg text-blue-600"><i class="fa-solid fa-microchip"></i></div>
                    <h3 class="font-bold text-stone-800">Filozoful = Procesul</h3>
                </div>
                <p class="text-sm text-stone-600">
                    Filozoful reprezintă un program sau un thread care are nevoie de resurse pentru a-și face treaba. Când "Gândește", procesează date local. Când "Mănâncă", folosește resurse partajate.
                </p>
            </div>

            <!-- Concept Card 2 -->
            <div class="bg-white p-6 rounded-xl border-l-4 border-amber-500 shadow-sm hover:shadow-md transition-shadow">
                <div class="flex items-center gap-3 mb-3">
                    <div class="bg-amber-100 p-2 rounded-lg text-amber-600"><i class="fa-solid fa-code-branch"></i></div>
                    <h3 class="font-bold text-stone-800">Furculița = Resursa (Mutex)</h3>
                </div>
                <p class="text-sm text-stone-600">
                    O furculiță este o resursă exclusivă (imprimantă, fișier, segment de memorie). Doar un singur filozof o poate ține la un moment dat. Aceasta necesită "Excludere Mutuală".
                </p>
            </div>

            <!-- Concept Card 3 -->
            <div class="bg-white p-6 rounded-xl border-l-4 border-red-500 shadow-sm hover:shadow-md transition-shadow">
                <div class="flex items-center gap-3 mb-3">
                    <div class="bg-red-100 p-2 rounded-lg text-red-600"><i class="fa-solid fa-lock"></i></div>
                    <h3 class="font-bold text-stone-800">Interblocaj (Deadlock)</h3>
                </div>
                <p class="text-sm text-stone-600">
                    Apare când fiecare filozof ține furculița din stânga și o așteaptă la infinit pe cea din dreapta. În OS, procesele se blochează reciproc, așteptând resurse care nu se vor elibera niciodată.
                </p>
            </div>
        </section>

        <!-- Solutions Explanation -->
        <section class="bg-stone-800 text-stone-100 rounded-2xl p-8">
            <h3 class="text-2xl font-bold mb-6 text-white"><i class="fa-solid fa-lightbulb text-yellow-400 mr-2"></i> Soluția lui Dijkstra (Ierarhia Resurselor)</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div>
                    <h4 class="font-bold text-lg mb-2 text-blue-300">Problema Abordării Naive</h4>
                    <p class="text-stone-300 text-sm leading-relaxed mb-4">
                        Dacă toți filozofii devin flămânzi simultan și toți iau mai întâi furculița din stânga, masa se blochează. Avem o "Dependență Circulară". Nimeni nu poate mânca, nimeni nu cedează furculița.
                    </p>
                    <div class="p-3 bg-stone-900 rounded border border-stone-700 font-mono text-xs text-red-300">
                        P1 are F1, vrea F2<br>
                        P2 are F2, vrea F3<br>
                        ...<br>
                        P5 are F5, vrea F1 -> CICLU!
                    </div>
                </div>
                <div>
                    <h4 class="font-bold text-lg mb-2 text-green-300">Soluția Ierarhică</h4>
                    <p class="text-stone-300 text-sm leading-relaxed mb-4">
                        Numerotăm furculițele de la 1 la 5. Regula impusă de sistem: <strong>Un filozof trebuie să ceară întotdeauna furculița cu numărul mai mic mai întâi.</strong>
                    </p>
                    <ul class="list-disc list-inside text-sm text-stone-400 space-y-2">
                        <li>Filozofii 1-4 iau Stânga (mică) apoi Dreapta (mare).</li>
                        <li><strong>Filozoful 5</strong> (cazul special) ar vrea F5 (stânga) și F1 (dreapta). Dar regula spune să ia numărul mai mic întâi (F1).</li>
                        <li>Dacă F1 e luată de Filozoful 1, Filozoful 5 nu ia <em>nicio</em> furculiță, prevenind ciclul!</li>
                    </ul>
                </div>
            </div>
        </section>

    </main>

    <!-- Footer -->
    <footer class="bg-white border-t border-stone-200 mt-auto">
        <div class="max-w-7xl mx-auto px-4 py-6 text-center">
            <p class="text-stone-500 text-sm">
                Generat de Revolvix pentru cursul de Sisteme de Operare.
            </p>
        </div>
    </footer>

    <!-- JavaScript Logic -->
    <script>
        // --- Configuration & State ---
        const PHILOSOPHER_COUNT = 5;
        const STATES = {
            THINKING: 'thinking',
            HUNGRY: 'hungry',
            EATING: 'eating',
            DEADLOCK: 'deadlock' // Artificial state for visualization
        };

        // State objects
        let philosophers = [];
        let forks = []; // true if taken, false if free
        let simulationInterval = null;
        let isRunning = false;
        let strategy = 'naive'; // 'naive' or 'hierarchy'
        let mealsEaten = new Array(PHILOSOPHER_COUNT).fill(0);
        
        // DOM Elements
        const stage = document.getElementById('simulation-stage');
        const logEl = document.getElementById('system-log');
        const btnStart = document.getElementById('btn-start');
        const btnStop = document.getElementById('btn-stop');
        const btnReset = document.getElementById('btn-reset');
        const btnForceDeadlock = document.getElementById('btn-force-deadlock');
        const algoSelect = document.getElementById('algorithm-select');
        const algoDesc = document.getElementById('algo-desc');

        // --- Chart Setup ---
        const ctx = document.getElementById('statsChart').getContext('2d');
        const statsChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['P1', 'P2', 'P3', 'P4', 'P5'],
                datasets: [{
                    label: 'Mese Servite (Acces Critic)',
                    data: mealsEaten,
                    backgroundColor: [
                        'rgba(96, 165, 250, 0.7)',
                        'rgba(96, 165, 250, 0.7)',
                        'rgba(96, 165, 250, 0.7)',
                        'rgba(96, 165, 250, 0.7)',
                        'rgba(96, 165, 250, 0.7)'
                    ],
                    borderColor: 'rgba(96, 165, 250, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: '#e5e7eb' }
                    },
                    x: {
                        grid: { display: false }
                    }
                },
                plugins: {
                    legend: { display: false }
                },
                animation: {
                    duration: 500
                }
            }
        });

        // --- Initialization ---

        function init() {
            // Clear stage
            stage.innerHTML = '';
            philosophers = [];
            forks = new Array(PHILOSOPHER_COUNT).fill(null); // null = free, integer = taken by philosopher ID
            mealsEaten.fill(0);
            updateChart();

            // Create Geometry
            const radius = 180; // Distance from center
            const centerX = stage.clientWidth / 2;
            const centerY = stage.clientHeight / 2;

            for (let i = 0; i < PHILOSOPHER_COUNT; i++) {
                // Angle logic: Start from top (-90deg) and go clockwise
                const angle = (i * (360 / PHILOSOPHER_COUNT)) - 90; 
                const rad = angle * (Math.PI / 180);

                // Position Philosopher
                const pX = 50 + 35 * Math.cos(rad); // % positions
                const pY = 50 + 35 * Math.sin(rad);

                // Create Philosopher UI
                const pEl = document.createElement('div');
                pEl.className = `philosopher-avatar absolute w-16 h-16 rounded-full border-4 bg-white flex items-center justify-center text-xl font-bold z-20 shadow-lg cursor-pointer transform -translate-x-1/2 -translate-y-1/2 transition-all duration-300 status-thinking`;
                pEl.style.left = `${pX}%`;
                pEl.style.top = `${pY}%`;
                pEl.innerHTML = `<i class="fa-solid fa-user"></i><span class="absolute -top-2 -right-2 bg-stone-800 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">${i+1}</span>`;
                pEl.id = `phil-${i}`;
                
                // Add click event for details
                pEl.onclick = () => showPhilosopherDetails(i);

                stage.appendChild(pEl);

                // Create Fork UI (placed between philosophers)
                // Fork i is between Phil i and Phil (i+1)%5
                const forkAngle = angle + (360 / PHILOSOPHER_COUNT) / 2;
                const forkRad = forkAngle * (Math.PI / 180);
                const fX = 50 + 20 * Math.cos(forkRad); // Closer to center
                const fY = 50 + 20 * Math.sin(forkRad);
                const rotation = forkAngle + 90; // Rotate to point outward

                const fEl = document.createElement('div');
                fEl.className = `fork absolute w-1 h-10 bg-stone-400 rounded z-10 origin-center transform -translate-x-1/2 -translate-y-1/2`;
                fEl.style.left = `${fX}%`;
                fEl.style.top = `${fY}%`;
                fEl.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                fEl.id = `fork-${i}`;
                
                stage.appendChild(fEl);

                // Init Logic State
                philosophers.push({
                    id: i,
                    state: STATES.THINKING,
                    eatingTimer: 0,
                    thinkingTimer: Math.random() * 50 + 20, // Random start
                    hasLeftFork: false,
                    hasRightFork: false
                });
            }
            
            log("Sistem inițializat. Aștept comanda start.");
        }

        // --- Core Simulation Logic ---

        function updateSimulation() {
            // Need a copy or care with updates to avoid double moves in one tick? 
            // In this simple simulation, sequential update is acceptable but randomness helps realism.
            
            // Randomize order of updates to prevent mechanical lockstep in naive mode (though we want to show deadlock eventually)
            const order = Array.from({length: PHILOSOPHER_COUNT}, (_, i) => i).sort(() => Math.random() - 0.5);

            order.forEach(id => {
                const p = philosophers[id];
                const leftForkId = id;
                const rightForkId = (id + 1) % PHILOSOPHER_COUNT;

                if (p.state === STATES.THINKING) {
                    p.thinkingTimer--;
                    if (p.thinkingTimer <= 0) {
                        p.state = STATES.HUNGRY;
                        updatePhilVisual(id);
                        // log(`Filozoful ${id+1} a devenit flămând.`);
                    }
                } else if (p.state === STATES.HUNGRY) {
                    attemptToEat(p, leftForkId, rightForkId);
                } else if (p.state === STATES.EATING) {
                    p.eatingTimer--;
                    if (p.eatingTimer <= 0) {
                        finishEating(p, leftForkId, rightForkId);
                    }
                }
            });
        }

        function attemptToEat(p, leftForkId, rightForkId) {
            // Identify actual fork indices based on strategy
            // Naive: Left then Right
            // Hierarchy: Lower ID then Higher ID
            
            let firstForkId = leftForkId;
            let secondForkId = rightForkId;

            if (strategy === 'hierarchy') {
                if (leftForkId > rightForkId) {
                    firstForkId = rightForkId;
                    secondForkId = leftForkId;
                }
            }

            // Step 1: Try pick up first fork
            // In our state logic: 
            // - If has 0 forks: try get first
            // - If has 1 fork: try get second

            const hasFirst = (strategy === 'hierarchy' && firstForkId === rightForkId) ? p.hasRightFork : p.hasLeftFork;
            const hasSecond = (strategy === 'hierarchy' && secondForkId === leftForkId) ? p.hasLeftFork : p.hasRightFork;
            
            // Map logical ownership back to physical left/right for state tracking
            // Note: p.hasLeftFork strictly refers to the fork at index 'id'
            //       p.hasRightFork strictly refers to the fork at index '(id+1)%5'

            // LOGIC FOR PICKING UP
            if (!p.hasLeftFork && !p.hasRightFork) {
                // Has nothing. Try pick up FIRST required fork.
                if (strategy === 'naive') {
                    // Naive: Try Left
                    if (forks[leftForkId] === null) {
                        takeFork(p, leftForkId, 'left');
                    }
                } else {
                    // Hierarchy: Try Lower ID
                    const target = Math.min(leftForkId, rightForkId);
                    const isLeft = (target === leftForkId);
                    if (forks[target] === null) {
                        takeFork(p, target, isLeft ? 'left' : 'right');
                    }
                }
            } else if ((p.hasLeftFork && !p.hasRightFork) || (!p.hasLeftFork && p.hasRightFork)) {
                // Has one. Try pick up SECOND.
                // Naive: Has Left (always), wants Right
                // Hierarchy: Has Lower, wants Higher
                
                const missingLeft = !p.hasLeftFork;
                const targetId = missingLeft ? leftForkId : rightForkId;
                
                if (forks[targetId] === null) {
                    takeFork(p, targetId, missingLeft ? 'left' : 'right');
                    // NOW HAS BOTH -> EAT
                    startEating(p);
                } else {
                    // Waiting for second fork... risk of deadlock/starvation
                }
            }
        }

        function takeFork(p, forkId, side) {
            forks[forkId] = p.id;
            if (side === 'left') p.hasLeftFork = true;
            else p.hasRightFork = true;
            
            // Visual update for fork
            const fEl = document.getElementById(`fork-${forkId}`);
            fEl.style.backgroundColor = '#1c1917'; // Dark taken color
            fEl.style.width = '4px';
            
            // Move fork visually towards philosopher (simple offset)
            // Ideally we'd calculate vectors, but color change is clear enough for this abstraction level
        }

        function startEating(p) {
            p.state = STATES.EATING;
            p.eatingTimer = 30 + Math.random() * 20; // Time to eat
            updatePhilVisual(p.id);
            mealsEaten[p.id]++;
            updateChart();
            log(`Filozoful ${p.id + 1} a obținut ambele furculițe și MĂNÂNCĂ.`);
        }

        function finishEating(p, leftForkId, rightForkId) {
            // Drop forks
            forks[leftForkId] = null;
            forks[rightForkId] = null;
            p.hasLeftFork = false;
            p.hasRightFork = false;

            // Visual Reset Forks
            const fEl1 = document.getElementById(`fork-${leftForkId}`);
            const fEl2 = document.getElementById(`fork-${rightForkId}`);
            [fEl1, fEl2].forEach(el => {
                el.style.backgroundColor = '#a8a29e'; // Stone-400
                el.style.width = '4px';
            });

            // Change State
            p.state = STATES.THINKING;
            p.thinkingTimer = 30 + Math.random() * 50;
            updatePhilVisual(p.id);
            log(`Filozoful ${p.id + 1} a terminat și gândește.`);
        }

        function forceDeadlock() {
            stopSimulation();
            resetSimulation();
            
            // Manually set state where everyone has left fork
            philosophers.forEach(p => {
                p.state = STATES.HUNGRY;
                p.hasLeftFork = true;
                p.hasRightFork = false;
                forks[p.id] = p.id; // Fork i is taken by Phil i
                
                // Visuals
                const fEl = document.getElementById(`fork-${p.id}`);
                fEl.style.backgroundColor = '#ef4444'; // Red for danger
                
                const pEl = document.getElementById(`phil-${p.id}`);
                pEl.className = pEl.className.replace(/status-\w+/, 'status-deadlock');
            });

            log("DEADLOCK FORȚAT! Toți au furculița stângă. Toți așteaptă dreapta. Nimeni nu cedează.", true);
        }

        // --- UI Updates ---

        function updatePhilVisual(id) {
            const p = philosophers[id];
            const el = document.getElementById(`phil-${id}`);
            
            // Remove old status
            el.className = el.className.replace(/status-\w+/, '');
            
            // Add new status
            if (p.state === STATES.THINKING) el.classList.add('status-thinking');
            if (p.state === STATES.HUNGRY) el.classList.add('status-hungry');
            if (p.state === STATES.EATING) el.classList.add('status-eating');
            if (p.state === STATES.DEADLOCK) el.classList.add('status-deadlock');
        }

        function updateChart() {
            statsChart.data.datasets[0].data = mealsEaten;
            statsChart.update();
        }

        function log(msg, isError = false) {
            const time = new Date().toLocaleTimeString('ro-RO');
            const entry = document.createElement('div');
            entry.className = isError ? 'text-red-400 font-bold' : 'text-green-400';
            entry.textContent = `> [${time}] ${msg}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function showPhilosopherDetails(id) {
            const p = philosophers[id];
            log(`INFO P${id+1}: Stare=${p.state}, Stânga=${p.hasLeftFork}, Dreapta=${p.hasRightFork}`);
        }

        // --- Controls ---

        function startSimulation() {
            if (isRunning) return;
            isRunning = true;
            btnStart.classList.add('hidden');
            btnStop.classList.remove('hidden');
            log("Simulare pornită.");
            simulationInterval = setInterval(updateSimulation, 100); // 10 ticks per second
        }

        function stopSimulation() {
            isRunning = false;
            clearInterval(simulationInterval);
            btnStart.classList.remove('hidden');
            btnStop.classList.add('hidden');
            log("Simulare pusă pe pauză.");
        }

        function resetSimulation() {
            stopSimulation();
            init();
        }

        // --- Event Listeners ---
        
        btnStart.addEventListener('click', startSimulation);
        btnStop.addEventListener('click', stopSimulation);
        btnReset.addEventListener('click', resetSimulation);
        btnForceDeadlock.addEventListener('click', forceDeadlock);
        
        algoSelect.addEventListener('change', (e) => {
            strategy = e.target.value;
            resetSimulation();
            if (strategy === 'naive') {
                algoDesc.textContent = "Strategie Naivă: Fiecare ia Stânga, apoi așteaptă Dreapta. Risc mare de Deadlock.";
                log("Strategie schimbată la NAIVĂ.");
            } else {
                algoDesc.textContent = "Strategie Ierarhică: Resursele se cer în ordine crescătoare. Elimină dependența circulară.";
                log("Strategie schimbată la IERARHICĂ (Dijkstra).");
            }
        });

        // Initialize on Load
        window.addEventListener('load', () => {
            init();
            
            // Resize handler for Chart
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    init(); // Re-calculate positions if needed, though % based CSS handles most
                    statsChart.resize();
                }, 200);
            });
        });

    </script>
    
    <!-- Visualization & Content Choices:
         - Visual: HTML Divs with absolute positioning used instead of SVG to strictly adhere to restrictions while maintaining a custom circular layout.
         - Interaction: Users can switch algorithms to see different outcomes, directly satisfying the learning goal of comparing "Naive" vs "Hierarchical".
         - Feedback: Chart.js bar chart gives quantitative feedback on "Starvation" (uneven bars) vs "Fairness" (even bars).
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
</body>
</html>