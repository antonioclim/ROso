# C17_05_EVALUARE_FORMATIVA.yaml
# Curs 17 Suplimentar: Programare la Nivel Nucleu SO
# Evaluare Formativă — Quiz Conceptual

metadata:
  curs: 17
  subiect: "Programare la Nivel Nucleu SO"
  versiune: "2.0"
  data_creare: "2026-01-28"
  autor: "by Revolvix"
  numar_intrebari: 10
  timp_estimat_minute: 12
  distributie_bloom:
    remember: 2
    understand: 4
    analyse: 3
    apply: 1

intrebari:
  - id: q01
    bloom: remember
    dificultate: usor
    text: "Ce este un kernel module în Linux?"
    optiuni:
      - "Un tip de aplicație"
      - "Cod care poate fi încărcat/descărcat din kernel la runtime fără a recompila kernelul"
      - "Un fișier de configurare"
      - "Un protocol de rețea"
    corect: 1
    explicatie: "Kernel module: extend functionality (drivers, filesystems) dinamic, fără reboot."

  - id: q02
    bloom: remember
    dificultate: usor
    text: "Ce comenzi se folosesc pentru a gestiona module în Linux?"
    optiuni:
      - "apt install / apt remove"
      - "insmod, rmmod, modprobe, lsmod"
      - "mount, umount"
      - "start, stop, restart"
    corect: 1
    explicatie: "insmod: încarcă. rmmod: descarcă. modprobe: rezolvă dependențe. lsmod: listează."

  - id: q03
    bloom: understand
    dificultate: mediu
    text: "De ce codul kernel trebuie să fie foarte atent la erori?"
    optiuni:
      - "Nu trebuie"
      - "Bug în kernel = kernel panic sau security vulnerability; nu există protecție ca în userspace"
      - "Pentru viteză"
      - "Din motive estetice"
    corect: 1
    explicatie: "Kernel: privilegii maxime, acces direct hardware. Bug = crash sistem sau root exploit."

  - id: q04
    bloom: understand
    dificultate: mediu
    text: "Ce sunt funcțiile init_module() și cleanup_module() într-un kernel module?"
    optiuni:
      - "Funcții de debugging"
      - "Entry/exit points: init la insmod, cleanup la rmmod"
      - "Funcții de rețea"
      - "Funcții de stocare"
    corect: 1
    explicatie: "module_init(): setup la încărcare. module_exit(): cleanup la descărcare. Obligatorii."

  - id: q05
    bloom: understand
    dificultate: mediu
    text: "De ce nu poți folosi printf() în kernel?"
    optiuni:
      - "Este prea lent"
      - "printf() este din libc (userspace). În kernel folosești printk() cu log levels"
      - "Kernelul nu are output"
      - "printf() este depreciat"
    corect: 1
    explicatie: "Kernel nu are libc. printk(KERN_INFO ...) scrie în kernel log (dmesg)."

  - id: q06
    bloom: understand
    dificultate: mediu
    text: "Ce este un character device driver?"
    optiuni:
      - "Driver pentru tastatură"
      - "Driver care oferă acces secvențial la un dispozitiv prin operații read/write pe un fișier în /dev"
      - "Driver pentru hard disk"
      - "Driver pentru GPU"
    corect: 1
    explicatie: "Char device: stream de bytes (terminal, serial). Block device: acces random, blocuri (disk)."

  - id: q07
    bloom: analyse
    dificultate: greu
    text: "De ce spinlock-urile sunt preferate în interrupt handlers față de mutex-uri?"
    optiuni:
      - "Sunt mai sigure"
      - "Mutex-urile pot face sleep; în interrupt context nu poți face sleep (nu ai proces de schedulat)"
      - "Spinlock-urile sunt mai lente"
      - "Nu există diferență"
    corect: 1
    explicatie: "Interrupt: nu ai context de proces, nu poți dormi. Spinlock: busy-wait, OK pentru durate scurte."

  - id: q08
    bloom: analyse
    dificultate: greu
    text: "Ce este eBPF și de ce este revoluționar pentru kernel programming?"
    optiuni:
      - "Un tip de firewall"
      - "Permite rularea de cod custom în kernel sigur (sandbox) fără a scrie module tradiționale"
      - "Un protocol de rețea"
      - "Un filesystem"
    corect: 1
    explicatie: "eBPF: program verificat, sandbox în kernel. Tracing, networking, security fără crash risk."

  - id: q09
    bloom: analyse
    dificultate: greu
    text: "Care este riscul principal la scrierea unui kernel module?"
    optiuni:
      - "Este prea lent"
      - "Erori pot cauza kernel panic, corupție de date, sau security holes cu privilegii root"
      - "Consumă prea multă memorie"
      - "Nu există riscuri"
    corect: 1
    explicatie: "Kernel module = parte din kernel. Bug = crash sistem sau compromitere completă."

  - id: q10
    bloom: apply
    dificultate: greu
    text: "Vrei să înregistrezi un handler pentru un interrupt hardware. Ce funcție kernel folosești?"
    optiuni:
      - "malloc()"
      - "request_irq() / devm_request_irq()"
      - "printf()"
      - "fork()"
    corect: 1
    explicatie: "request_irq(irq, handler, flags, name, dev_id) înregistrează handler-ul tău pentru IRQ."
