# C06_05_EVALUARE_FORMATIVA.yaml
# Curs 6: Sincronizare (Part 1 - Peterson, locks, mutex)
# Evaluare Formativă — Quiz Conceptual

metadata:
  curs: 6
  subiect: "Sincronizare (Part 1 - Peterson, locks, mutex)"
  versiune: "2.0"
  data_creare: "2026-01-28"
  autor: "by Revolvix"
  numar_intrebari: 12
  timp_estimat_minute: 15
  distributie_bloom:
    remember: 3
    understand: 5
    analyse: 3
    apply: 1

intrebari:
  # ═══════════════════════════════════════════════════════════════════════════
  # REMEMBER (3 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q01
    bloom: remember
    dificultate: usor
    text: "Ce este o secțiune critică?"
    optiuni:
      - "O eroare fatală de sistem"
      - "O porțiune de cod care accesează resurse partajate și trebuie executată atomic"
      - "Un tip de memorie"
      - "O funcție de sistem"
    corect: 1
    explicatie: "Secțiunea critică = cod care accesează date partajate; doar un proces/thread poate fi în ea la un moment dat."

  - id: q02
    bloom: remember
    dificultate: usor
    text: "Ce este race condition?"
    optiuni:
      - "O competiție între procese pentru memorie"
      - "Rezultatul depinde de ordinea relativă a execuției, care este nedeterministă"
      - "Un algoritm de sortare"
      - "Un tip de thread"
    corect: 1
    explicatie: "Race condition = comportament dependent de timing-ul relativ al operațiilor concurente."

  - id: q03
    bloom: remember
    dificultate: usor
    text: "Care sunt cele 3 condiții necesare pentru o soluție corectă la problema secțiunii critice?"
    optiuni:
      - "Viteză, memorie, CPU"
      - "Mutual exclusion, progress, bounded waiting"
      - "Read, write, execute"
      - "Lock, unlock, wait"
    corect: 1
    explicatie: "Mutual exclusion (exclusivitate), progress (nu blocare inutilă), bounded waiting (fără starvation)."

  # ═══════════════════════════════════════════════════════════════════════════
  # UNDERSTAND (5 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q04
    bloom: understand
    dificultate: mediu
    text: "Ce este busy-waiting și de ce este problematic?"
    optiuni:
      - "O tehnică de optimizare"
      - "Procesul verifică repetat o condiție în buclă, irosind cicluri CPU"
      - "O metodă de alocare de memorie"
      - "Un tip de întrerupere"
    corect: 1
    explicatie: "Busy-wait = spin în buclă așteptând; consumă CPU inutil, mai bine sleep + wake."

  - id: q05
    bloom: understand
    dificultate: mediu
    text: "Cum funcționează algoritmul Peterson pentru 2 procese?"
    optiuni:
      - "Folosește întreruperi hardware"
      - "Folosește flag-uri și variabila turn pentru a decide cine intră în secțiunea critică"
      - "Folosește semafoare"
      - "Blochează procesorul"
    corect: 1
    explicatie: "Peterson: fiecare setează flag + cedează turn celuilalt; intră doar dacă celălalt nu vrea sau nu e rândul lui."

  - id: q06
    bloom: understand
    dificultate: mediu
    text: "Ce face instrucțiunea atomică test-and-set?"
    optiuni:
      - "Testează memoria"
      - "Citește valoarea, setează la true, returnează valoarea veche - toate atomic"
      - "Incrementează un contor"
      - "Dezactivează întreruperile"
    corect: 1
    explicatie: "TAS: atomic { old = *ptr; *ptr = true; return old; }. Baza pentru spinlock-uri."

  - id: q07
    bloom: understand
    dificultate: mediu
    text: "Care este diferența între mutex și spinlock?"
    optiuni:
      - "Sunt identice"
      - "Mutex pune procesul în sleep când e blocat, spinlock face busy-wait"
      - "Spinlock este mai sigur"
      - "Mutex nu funcționează pe multi-core"
    corect: 1
    explicatie: "Mutex: sleep/wake (eficient pentru așteptări lungi). Spinlock: busy-wait (eficient pentru așteptări scurte)."

  - id: q08
    bloom: understand
    dificultate: mediu
    text: "De ce nu putem folosi doar dezactivarea întreruperilor pentru sincronizare pe multi-core?"
    optiuni:
      - "Întreruperile nu există pe multi-core"
      - "Dezactivarea pe un core nu afectează celelalte core-uri care pot accesa simultan datele"
      - "Este prea rapid"
      - "Consumă prea multă memorie"
    corect: 1
    explicatie: "Fiecare core are propriile întreruperi; dezactivarea locală nu împiedică accesul de pe alt core."

  # ═══════════════════════════════════════════════════════════════════════════
  # ANALYSE (3 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q09
    bloom: analyse
    dificultate: greu
    text: "De ce compilatorul poate 'strica' algoritmul Peterson fără memory barriers?"
    optiuni:
      - "Compilatorul are bug-uri"
      - "Compilatorul poate reordona instrucțiunile pentru optimizare, stricând ordinea necesară"
      - "Peterson nu funcționează"
      - "Memoria este defectă"
    corect: 1
    explicatie: "Fără memory barriers, compilatorul/CPU pot reordona scrierile/citirile, violând asumpțiile algoritmului."

  - id: q10
    bloom: analyse
    dificultate: greu
    text: "Un lock protejează o listă înlănțuită. De ce un lock per nod poate fi mai bun decât un lock global?"
    optiuni:
      - "Este mai simplu de implementat"
      - "Permite operații concurente pe noduri diferite (fine-grained locking)"
      - "Consumă mai puțină memorie"
      - "Elimină toate race conditions automat"
    corect: 1
    explicatie: "Fine-grained locking crește paralelismul: operații pe părți diferite ale structurii pot rula simultan."

  - id: q11
    bloom: analyse
    dificultate: greu
    text: "Care este trade-off-ul între spinlock și mutex pentru secțiuni critice scurte?"
    optiuni:
      - "Nu există trade-off"
      - "Spinlock evită overhead-ul context switch dar irosește CPU; pentru secțiuni foarte scurte, spinlock poate fi mai eficient"
      - "Mutex este întotdeauna mai bun"
      - "Spinlock nu funcționează"
    corect: 1
    explicatie: "Dacă secțiunea critică < timpul de context switch, spinlock evită overhead-ul sleep/wake."

  # ═══════════════════════════════════════════════════════════════════════════
  # APPLY (1 întrebare)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q12
    bloom: apply
    dificultate: greu
    text: "Ai un contor partajat incrementat de 1000 de thread-uri. Ce metodă de sincronizare e optimă?"
    optiuni:
      - "Fără sincronizare"
      - "Mutex global"
      - "Operații atomice (atomic_fetch_add)"
      - "Dezactivare întreruperi"
    corect: 2
    explicatie: "Pentru un singur contor, operațiile atomice (lock-free) sunt mai eficiente decât mutex-urile."