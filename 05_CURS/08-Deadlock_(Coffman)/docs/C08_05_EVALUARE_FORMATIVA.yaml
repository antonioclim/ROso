# C08_05_EVALUARE_FORMATIVA.yaml
# Curs 8: Deadlock (Condițiile Coffman)
# Evaluare Formativă — Quiz Conceptual

metadata:
  curs: 8
  subiect: "Deadlock (Condițiile Coffman)"
  versiune: "2.0"
  data_creare: "2026-01-28"
  autor: "by Revolvix"
  numar_intrebari: 12
  timp_estimat_minute: 15
  distributie_bloom:
    remember: 3
    understand: 5
    analyse: 3
    apply: 1

intrebari:
  # ═══════════════════════════════════════════════════════════════════════════
  # REMEMBER (3 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q01
    bloom: remember
    dificultate: usor
    text: "Ce este un deadlock?"
    optiuni:
      - "Un virus informatic"
      - "O situație în care procese se blochează reciproc, așteptând resurse deținute de celelalte"
      - "O eroare de compilare"
      - "Un tip de memorie"
    corect: 1
    explicatie: "Deadlock = impas: fiecare proces așteaptă o resursă deținută de alt proces din grup."

  - id: q02
    bloom: remember
    dificultate: usor
    text: "Care sunt cele 4 condiții Coffman pentru deadlock?"
    optiuni:
      - "Read, write, execute, delete"
      - "Mutual exclusion, hold and wait, no preemption, circular wait"
      - "Lock, unlock, signal, wait"
      - "Create, destroy, modify, access"
    corect: 1
    explicatie: "Toate 4 trebuie să fie adevărate simultan pentru ca deadlock-ul să poată apărea."

  - id: q03
    bloom: remember
    dificultate: usor
    text: "Ce este un Resource Allocation Graph (RAG)?"
    optiuni:
      - "Un algoritm de sortare"
      - "Un graf care arată relațiile de alocare și cerere între procese și resurse"
      - "Un tip de memorie"
      - "Un protocol de rețea"
    corect: 1
    explicatie: "RAG: noduri = procese și resurse, muchii = alocări și cereri. Ciclul indică potențial deadlock."

  # ═══════════════════════════════════════════════════════════════════════════
  # UNDERSTAND (5 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q04
    bloom: understand
    dificultate: mediu
    text: "Cum poate fi prevenită condiția 'circular wait'?"
    optiuni:
      - "Prin criptarea resurselor"
      - "Prin impunerea unei ordini totale asupra achiziției resurselor"
      - "Prin creșterea memoriei"
      - "Prin dezactivarea întreruperilor"
    corect: 1
    explicatie: "Dacă toate procesele achiziționează resurse în aceeași ordine, ciclul nu se poate forma."

  - id: q05
    bloom: understand
    dificultate: mediu
    text: "Ce înseamnă 'hold and wait' și cum poate fi eliminată?"
    optiuni:
      - "Hold and wait = așteptare activă"
      - "Proces care deține resurse și așteaptă altele; eliminată prin achiziție atomică (toate sau nimic)"
      - "Este o metodă de optimizare"
      - "Nu poate fi eliminată"
    corect: 1
    explicatie: "Soluție: procesul cere toate resursele simultan, sau eliberează pe cele deținute înainte de a cere altele."

  - id: q06
    bloom: understand
    dificultate: mediu
    text: "Ce este starea 'safe' în contextul algoritmului bancherului?"
    optiuni:
      - "Sistemul nu are viruși"
      - "Există o secvență de execuție în care toate procesele pot termina"
      - "Memoria este suficientă"
      - "CPU-ul nu este supraîncărcat"
    corect: 1
    explicatie: "Safe state = există cel puțin o secvență safe: procese terminate fără deadlock."

  - id: q07
    bloom: understand
    dificultate: mediu
    text: "De ce algoritmul bancherului nu este folosit frecvent în practică?"
    optiuni:
      - "Este prea simplu"
      - "Necesită cunoașterea a priori a cerințelor maxime de resurse, care rar sunt cunoscute"
      - "Nu funcționează pe multi-core"
      - "Consumă prea multă memorie"
    corect: 1
    explicatie: "Programele moderne nu declară resursele maxime; plus overhead-ul de calcul la fiecare cerere."

  - id: q08
    bloom: understand
    dificultate: mediu
    text: "Care este diferența între deadlock prevention și deadlock avoidance?"
    optiuni:
      - "Sunt identice"
      - "Prevention elimină una din condiții permanent; avoidance verifică dinamic fiecare cerere"
      - "Prevention este mai lentă"
      - "Avoidance nu funcționează"
    corect: 1
    explicatie: "Prevention: structural imposibil. Avoidance: permite cereri doar dacă sistemul rămâne safe."

  # ═══════════════════════════════════════════════════════════════════════════
  # ANALYSE (3 întrebări)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q09
    bloom: analyse
    dificultate: greu
    text: "Într-un RAG cu o singură instanță per resursă, ce indică prezența unui ciclu?"
    optiuni:
      - "Performanță bună"
      - "Deadlock garantat"
      - "Posibil deadlock"
      - "Nici o problemă"
    corect: 1
    explicatie: "Cu instanțe unice, ciclul în RAG = deadlock cert. Cu instanțe multiple, ciclul e doar necesar, nu suficient."

  - id: q10
    bloom: analyse
    dificultate: greu
    text: "De ce 'preemption' de resurse poate fi imposibilă pentru anumite resurse?"
    optiuni:
      - "Este întotdeauna posibilă"
      - "Unele resurse (imprimanta în mijlocul printării, mutex-uri) nu pot fi preemptate fără a corupe starea"
      - "Preemption este prea rapidă"
      - "Necesită hardware special"
    corect: 1
    explicatie: "Resurse non-preemptabile: nu pot fi luate forțat fără a pierde lucru sau a corupe starea."

  - id: q11
    bloom: analyse
    dificultate: greu
    text: "Un sistem folosește detection + recovery pentru deadlock. Care este trade-off-ul?"
    optiuni:
      - "Nu există trade-off"
      - "Mai puțin overhead în operare normală, dar recovery (kill/rollback) poate fi costisitor"
      - "Este întotdeauna mai bun decât prevention"
      - "Nu funcționează"
    corect: 1
    explicatie: "Detection rulează periodic; recovery implică terminare procese sau rollback, ambele cu costuri."

  # ═══════════════════════════════════════════════════════════════════════════
  # APPLY (1 întrebare)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q12
    bloom: apply
    dificultate: greu
    text: "Ai 2 procese și 2 lock-uri (A, B). P1 ia A apoi B; P2 ia B apoi A. Cum previi deadlock-ul?"
    optiuni:
      - "Folosești mai multe lock-uri"
      - "Ambele procese achiziționează în aceeași ordine: A apoi B"
      - "Elimini lock-urile"
      - "Crești prioritatea lui P1"
    corect: 1
    explicatie: "Ordine globală consistentă (A < B) elimină circular wait: ambele cer A întâi, apoi B."
