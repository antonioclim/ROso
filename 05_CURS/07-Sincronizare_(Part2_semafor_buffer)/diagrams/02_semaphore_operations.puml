
@startuml
!theme plain
skinparam backgroundColor #FEFEFE
skinparam defaultFontName DejaVu Sans
skinparam defaultFontSize 11

title Semaphore Operations: wait() and signal()
caption Course 7: Synchronisation Part 2 — Semaphores

rectangle "**Semaphore S**\n(integer counter ≥ 0)" as S #LightBlue {
  rectangle "Value: n" as val #White
}

rectangle "Thread T1\n(wants resource)" as T1 #LightGreen
rectangle "Thread T2\n(releases)" as T2 #LightCoral
rectangle "Waiting\nqueue" as Q #LightYellow

T1 -down-> S : **wait(S)** / P(S) / down(S)
note right of T1
  **Pseudocode wait(S):**
  atomic {
    while (S <= 0) {
      // add thread to queue
      // block thread
    }
    S = S - 1;
  }
end note

S -down-> Q : "if S ≤ 0\nThread → Queue\n(blocked)"

T2 -down-> S : **signal(S)** / V(S) / up(S)
note left of T2
  **Pseudocode signal(S):**
  atomic {
    S = S + 1;
    if (threads in queue) {
      // wake one thread
    }
  }
end note

Q -up-> S : "signal() wakes\na thread from queue"

note bottom of S
  **Mathematical invariant:**
  S = S₀ - #wait_completed + #signal_completed
  
  **Binary semaphore:** S ∈ {0, 1} (equivalent to mutex)
  **Counting semaphore:** S ∈ {0, 1, 2, ...} (multiple resources)
end note

note bottom of Q
  **Queue implementation:**
  - FIFO: guarantees bounded waiting
  - LIFO: possible starvation
  
  **Atomicity:**
  - Disable interrupts (uniprocessor)
  - Spinlock + disable (SMP)
end note

@enduml
