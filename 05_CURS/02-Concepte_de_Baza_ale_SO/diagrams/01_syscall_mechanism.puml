

@startuml mecanismul_syscall
!include ../../diagrams_common/skin.puml
title System Call Mechanism - open()

skinparam sequence {
    ParticipantPadding 20
    BoxPadding 10
}

box "User Space" #E3F2FD
    participant "Application\nC" as app
    participant "glibc\nwrapper" as libc
end box

box "Kernel Space" #FFCCBC
    participant "Syscall\nEntry" as entry
    participant "sys_call_table" as table
    participant "sys_open()" as sysopen
end box

participant "Hardware\nCPU" as cpu

== Call Initiation ==
app -> libc : open("/tmp/file", O_RDONLY)
activate libc #C8E6C9

libc -> libc : Prepare registers:\n%rax = 2 (syscall nr)\n%rdi = path\n%rsi = flags

libc -> cpu : **syscall** instruction
activate cpu #FFCDD2

== User → Kernel Transition ==
cpu -> cpu : Save RIP, RFLAGS\nSwitch Ring 3 → Ring 0\nLoad kernel stack

cpu -> entry : Jump to entry point
deactivate cpu
activate entry #FFE0B2

== Kernel Processing ==
entry -> entry : Save registers\non kernel stack

entry -> table : Lookup %rax in\nsys_call_table[2]
activate table #FFF9C4
table --> entry : sys_open address
deactivate table

entry -> sysopen : Call sys_open()
activate sysopen #C8E6C9

sysopen -> sysopen : 1. copy_from_user(path)\n2. Check permissions\n3. Find inode in VFS\n4. Allocate file descriptor\n5. Return fd

sysopen --> entry : fd = 3
deactivate sysopen

== Kernel → User Transition ==
entry -> entry : Check pending signals\nRestore registers

entry -> cpu : **sysret** instruction
deactivate entry
activate cpu #FFCDD2

cpu -> cpu : Switch Ring 0 → Ring 3\nRestore RIP, RSP

cpu -> libc : Return with %rax = 3
deactivate cpu

== Finalisation ==
libc -> libc : if (rax < 0)\n  errno = -rax\n  return -1\nreturn rax

libc --> app : fd = 3
deactivate libc

note right of app
  **Success!**
  File opened
  with fd = 3
end note

@enduml
