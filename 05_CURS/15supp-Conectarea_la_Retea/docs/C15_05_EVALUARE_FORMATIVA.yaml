# C15_05_EVALUARE_FORMATIVA.yaml
# Curs 15 Suplimentar: Conectarea la Rețea
# Evaluare Formativă — Quiz Conceptual

metadata:
  curs: 15
  subiect: "Conectarea la Rețea"
  versiune: "2.0"
  data_creare: "2026-01-28"
  autor: "by Revolvix"
  numar_intrebari: 10
  timp_estimat_minute: 12
  distributie_bloom:
    remember: 2
    understand: 4
    analyse: 3
    apply: 1

intrebari:
  - id: q01
    bloom: remember
    dificultate: usor
    text: "Ce este un socket în programarea de rețea?"
    optiuni:
      - "Un cablu de rețea"
      - "Endpoint de comunicare: combinație de IP + port care permite transfer de date"
      - "Un tip de server"
      - "Un protocol de criptare"
    corect: 1
    explicatie: "Socket = abstracție OS pentru comunicare în rețea, identificat prin IP:port."

  - id: q02
    bloom: remember
    dificultate: usor
    text: "Care este diferența principală între TCP și UDP?"
    optiuni:
      - "TCP este mai vechi"
      - "TCP: connection-oriented, reliable. UDP: connectionless, best-effort"
      - "UDP este mai sigur"
      - "Nu există diferență"
    corect: 1
    explicatie: "TCP: garantează livrare în ordine. UDP: rapid dar fără garanții (video streaming, gaming)."

  - id: q03
    bloom: understand
    dificultate: mediu
    text: "Ce face apelul bind() în API-ul socket?"
    optiuni:
      - "Conectează la server"
      - "Asociază socket-ul cu o adresă IP și un port local"
      - "Trimite date"
      - "Închide conexiunea"
    corect: 1
    explicatie: "bind(): server-ul specifică pe ce IP:port ascultă. Clientul de obicei nu face bind explicit."

  - id: q04
    bloom: understand
    dificultate: mediu
    text: "De ce server-ul TCP apelează listen() și accept()?"
    optiuni:
      - "Pentru a trimite date"
      - "listen(): marchează socket-ul ca pasiv. accept(): acceptă conexiuni și creează socket nou per client"
      - "Pentru criptare"
      - "Pentru a închide conexiunea"
    corect: 1
    explicatie: "listen(): setează queue pentru conexiuni. accept(): blochează până vine client, returnează socket nou."

  - id: q05
    bloom: understand
    dificultate: mediu
    text: "Ce este multiplexarea I/O cu select()/poll()/epoll()?"
    optiuni:
      - "Crearea de thread-uri"
      - "Permite unui singur thread să monitorizeze multiple socket-uri pentru evenimente I/O"
      - "Compresia datelor"
      - "Criptarea conexiunilor"
    corect: 1
    explicatie: "Multiplexare: un thread gestionează mii de conexiuni eficient, fără thread per conexiune."

  - id: q06
    bloom: understand
    dificultate: mediu
    text: "De ce epoll este mai eficient decât select pentru mulți descriptori?"
    optiuni:
      - "Nu este mai eficient"
      - "epoll: O(1) pentru events, nu scanează toți descriptorii. select: O(n) scan la fiecare apel"
      - "epoll folosește mai multă memorie"
      - "select nu există pe Linux"
    corect: 1
    explicatie: "epoll: kernel notifică doar despre descriptorii activi. select: userspace iterează prin toți."

  - id: q07
    bloom: analyse
    dificultate: greu
    text: "Un server handle-ează 10.000 conexiuni simultane. Ce model este mai potrivit?"
    optiuni:
      - "Un thread per conexiune"
      - "Event-driven cu epoll și un număr mic de worker threads"
      - "Un proces per conexiune"
      - "Procesare secvențială"
    corect: 1
    explicatie: "10K threads = overhead mare (memorie, scheduling). Event loop cu epoll: eficient, scalabil."

  - id: q08
    bloom: analyse
    dificultate: greu
    text: "De ce TCP folosește three-way handshake (SYN, SYN-ACK, ACK)?"
    optiuni:
      - "Pentru viteză"
      - "Pentru a sincroniza sequence numbers și a confirma că ambele părți sunt ready"
      - "Pentru criptare"
      - "Este opțional"
    corect: 1
    explicatie: "3-way handshake: stabilește parametrii conexiunii, previne conexiuni false din pachete vechi."

  - id: q09
    bloom: analyse
    dificultate: greu
    text: "Ce problemă rezolvă Nagle's algorithm și de ce uneori îl dezactivăm?"
    optiuni:
      - "Securitatea"
      - "Combină pachete mici pentru eficiență, dar adaugă latență; dezactivăm pentru aplicații real-time"
      - "Compresia datelor"
      - "Nu rezolvă nimic"
    corect: 1
    explicatie: "Nagle: reduce overhead de headers pentru stream-uri. Dezactivat (TCP_NODELAY) pentru latență mică."

  - id: q10
    bloom: apply
    dificultate: greu
    text: "Scrii un chat server. Ce probleme trebuie să gestionezi pentru mesaje parțiale pe TCP?"
    optiuni:
      - "TCP garantează mesaje complete"
      - "TCP este stream-based: trebuie framing protocol (length prefix sau delimiter) pentru a delimita mesajele"
      - "Folosești UDP în loc"
      - "Nu există probleme"
    corect: 1
    explicatie: "TCP: stream de bytes, nu mesaje. recv() poate returna jumătate de mesaj. Implementezi protocol."