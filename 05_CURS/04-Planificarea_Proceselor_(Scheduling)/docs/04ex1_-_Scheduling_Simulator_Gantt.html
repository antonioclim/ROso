<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulator Planificare CPU - Gantt Chart | Sisteme de Operare</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Inter:wght@300;400;500;600;700&display=swap');
        
        body { font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #f5f5f4 0%, #e7e5e4 100%); }
        .mono { font-family: 'JetBrains Mono', monospace; }
        
        .gantt-segment {
            transition: all 0.3s ease;
            position: relative;
        }
        .gantt-segment:hover {
            transform: scaleY(1.1);
            z-index: 10;
        }
        .gantt-segment::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1c1917;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .gantt-segment:hover::after { opacity: 1; }
        
        .now-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 20;
            transition: left 0.3s ease;
        }
        .now-line::before {
            content: 'NOW';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ef4444;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }
        
        .ready-queue-item {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .process-colors {
            --p1: #3b82f6; --p2: #22c55e; --p3: #f59e0b; --p4: #ef4444;
            --p5: #8b5cf6; --p6: #06b6d4; --p7: #ec4899; --p8: #84cc16;
        }
        
        .btn-action {
            transition: all 0.2s ease;
        }
        .btn-action:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .btn-action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        input[type="number"] {
            -moz-appearance: textfield;
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
        }
    </style>
</head>
<body class="min-h-screen text-stone-900">
    <!-- Header -->
    <header class="sticky top-0 z-50 bg-white/80 backdrop-blur-md border-b border-stone-200 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 py-3 flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 rounded-lg bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center">
                    <i class="fas fa-clock text-white text-lg"></i>
                </div>
                <div>
                    <h1 class="text-xl font-bold text-stone-800">Simulator Planificare CPU</h1>
                    <p class="text-xs text-stone-500">Vizualizare Gantt Chart</p>
                </div>
            </div>
            <span class="px-3 py-1 bg-purple-100 text-purple-700 rounded-full text-sm font-medium">
                <i class="fas fa-graduation-cap mr-1"></i> Sisteme de Operare
            </span>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-6">
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            <!-- Left Panel: Configuration -->
            <div class="lg:col-span-4 space-y-6">
                <!-- Algorithm Selection -->
                <div class="bg-white rounded-xl shadow-sm border border-stone-200 p-4">
                    <h3 class="text-sm font-semibold text-stone-700 mb-3">
                        <i class="fas fa-cogs text-blue-500 mr-2"></i>Algoritm de Planificare
                    </h3>
                    <select id="algorithm" class="w-full p-3 border border-stone-300 rounded-lg text-sm bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        <option value="FCFS">FCFS (First Come First Served)</option>
                        <option value="SJF">SJF (Shortest Job First) - Non-preemptive</option>
                        <option value="SRTF">SRTF (Shortest Remaining Time First) - Preemptive</option>
                        <option value="RR" selected>Round Robin</option>
                        <option value="PRIORITY_NP">Priority - Non-preemptive</option>
                        <option value="PRIORITY_P">Priority - Preemptive</option>
                    </select>
                    
                    <div id="quantumConfig" class="mt-3">
                        <label class="text-xs text-stone-500 block mb-1">Time Quantum (pentru Round Robin)</label>
                        <input type="number" id="quantum" value="2" min="1" max="10" class="w-full p-2 border border-stone-300 rounded-lg text-sm mono focus:ring-2 focus:ring-blue-500">
                    </div>
                </div>

                <!-- Process Table -->
                <div class="bg-white rounded-xl shadow-sm border border-stone-200 p-4">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-sm font-semibold text-stone-700">
                            <i class="fas fa-table text-green-500 mr-2"></i>Tabela de Procese
                        </h3>
                        <button onclick="addProcess()" class="text-xs bg-green-100 hover:bg-green-200 text-green-700 px-2 py-1 rounded transition-colors">
                            <i class="fas fa-plus mr-1"></i>Adaugă
                        </button>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full text-xs">
                            <thead>
                                <tr class="bg-stone-50">
                                    <th class="p-2 text-left">Proces</th>
                                    <th class="p-2 text-center">Arrival</th>
                                    <th class="p-2 text-center">Burst</th>
                                    <th class="p-2 text-center">Priority</th>
                                    <th class="p-2 text-center">Acțiuni</th>
                                </tr>
                            </thead>
                            <tbody id="processTable">
                                <!-- Processes will be added here -->
                            </tbody>
                        </table>
                    </div>
                    <div class="mt-3 flex gap-2">
                        <button onclick="loadPreset('simple')" class="flex-1 text-xs bg-stone-100 hover:bg-stone-200 text-stone-700 px-2 py-2 rounded transition-colors">
                            Set Simplu
                        </button>
                        <button onclick="loadPreset('complex')" class="flex-1 text-xs bg-stone-100 hover:bg-stone-200 text-stone-700 px-2 py-2 rounded transition-colors">
                            Set Complex
                        </button>
                        <button onclick="loadPreset('priority')" class="flex-1 text-xs bg-stone-100 hover:bg-stone-200 text-stone-700 px-2 py-2 rounded transition-colors">
                            Set Priorități
                        </button>
                    </div>
                </div>

                <!-- Controls -->
                <div class="bg-white rounded-xl shadow-sm border border-stone-200 p-4">
                    <h3 class="text-sm font-semibold text-stone-700 mb-3">
                        <i class="fas fa-play-circle text-purple-500 mr-2"></i>Controale Simulare
                    </h3>
                    <div class="grid grid-cols-4 gap-2 mb-3">
                        <button id="btnPlay" onclick="togglePlay()" class="btn-action p-3 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-medium flex items-center justify-center">
                            <i class="fas fa-play"></i>
                        </button>
                        <button onclick="stepSimulation()" class="btn-action p-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg text-sm font-medium flex items-center justify-center">
                            <i class="fas fa-step-forward"></i>
                        </button>
                        <button onclick="resetSimulation()" class="btn-action p-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg text-sm font-medium flex items-center justify-center">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button onclick="runComplete()" class="btn-action p-3 bg-purple-500 hover:bg-purple-600 text-white rounded-lg text-sm font-medium flex items-center justify-center">
                            <i class="fas fa-fast-forward"></i>
                        </button>
                    </div>
                    <div>
                        <label class="text-xs text-stone-500 block mb-1">Viteză animație</label>
                        <input type="range" id="speedSlider" min="100" max="1500" value="500" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer">
                        <div class="flex justify-between text-xs text-stone-400 mt-1">
                            <span>Rapid</span>
                            <span>Lent</span>
                        </div>
                    </div>
                </div>

                <!-- Formulas -->
                <div class="bg-gradient-to-br from-blue-50 to-purple-50 rounded-xl shadow-sm border border-blue-200 p-4">
                    <h3 class="text-sm font-semibold text-blue-800 mb-3">
                        <i class="fas fa-calculator text-blue-500 mr-2"></i>Formule
                    </h3>
                    <div class="space-y-2 text-xs text-blue-700 mono">
                        <div class="p-2 bg-white/50 rounded"><strong>Turnaround Time</strong> = Finish - Arrival</div>
                        <div class="p-2 bg-white/50 rounded"><strong>Waiting Time</strong> = Turnaround - Burst</div>
                        <div class="p-2 bg-white/50 rounded"><strong>Response Time</strong> = FirstRun - Arrival</div>
                        <div class="p-2 bg-white/50 rounded"><strong>Throughput</strong> = Processes / TotalTime</div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Visualization -->
            <div class="lg:col-span-8 space-y-6">
                <!-- Gantt Chart -->
                <div class="bg-white rounded-xl shadow-sm border border-stone-200 p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold flex items-center gap-2">
                            <i class="fas fa-chart-gantt text-blue-500"></i>
                            Gantt Chart
                        </h2>
                        <div class="flex items-center gap-2 text-sm">
                            <span class="text-stone-500">Timp curent:</span>
                            <span id="currentTime" class="mono font-bold text-blue-600">0</span>
                        </div>
                    </div>
                    
                    <div class="relative bg-stone-50 rounded-lg p-4 min-h-[120px] overflow-x-auto">
                        <!-- Timeline -->
                        <div id="timeline" class="flex items-end gap-0 h-16 relative mb-2">
                            <!-- Gantt segments will be rendered here -->
                        </div>
                        
                        <!-- Time axis -->
                        <div id="timeAxis" class="flex border-t border-stone-300 pt-1">
                            <!-- Time markers will be rendered here -->
                        </div>
                        
                        <!-- Now line -->
                        <div id="nowLine" class="now-line hidden" style="left: 0;"></div>
                    </div>
                    
                    <!-- Legend -->
                    <div id="legend" class="mt-4 flex flex-wrap gap-2">
                        <!-- Process colors will be added here -->
                    </div>
                </div>

                <!-- Ready Queue -->
                <div class="bg-white rounded-xl shadow-sm border border-stone-200 p-4">
                    <h3 class="text-sm font-semibold text-stone-700 mb-3">
                        <i class="fas fa-list-ol text-amber-500 mr-2"></i>Ready Queue (t = <span id="queueTime">0</span>)
                    </h3>
                    <div id="readyQueue" class="flex gap-2 min-h-[50px] bg-stone-50 rounded-lg p-3 overflow-x-auto items-center">
                        <span class="text-stone-400 text-sm italic">Simularea nu a început</span>
                    </div>
                </div>

                <!-- Metrics Table -->
                <div class="bg-white rounded-xl shadow-sm border border-stone-200 p-4">
                    <h3 class="text-sm font-semibold text-stone-700 mb-3">
                        <i class="fas fa-table text-green-500 mr-2"></i>Metrici de Performanță
                    </h3>
                    <div class="overflow-x-auto">
                        <table class="w-full text-xs">
                            <thead>
                                <tr class="bg-stone-50">
                                    <th class="p-2 text-left">Proces</th>
                                    <th class="p-2 text-center">Arrival</th>
                                    <th class="p-2 text-center">Burst</th>
                                    <th class="p-2 text-center">Start</th>
                                    <th class="p-2 text-center">Finish</th>
                                    <th class="p-2 text-center">Waiting</th>
                                    <th class="p-2 text-center">Turnaround</th>
                                    <th class="p-2 text-center">Response</th>
                                </tr>
                            </thead>
                            <tbody id="metricsTable">
                                <tr><td colspan="8" class="p-4 text-center text-stone-400">Rulează simularea pentru a vedea metricile</td></tr>
                            </tbody>
                            <tfoot id="metricsFooter" class="bg-blue-50 font-semibold hidden">
                                <tr>
                                    <td class="p-2" colspan="5">Medii:</td>
                                    <td id="avgWaiting" class="p-2 text-center">-</td>
                                    <td id="avgTurnaround" class="p-2 text-center">-</td>
                                    <td id="avgResponse" class="p-2 text-center">-</td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </div>

                <!-- Algorithm Education -->
                <div class="bg-white rounded-xl shadow-sm border border-stone-200 p-4">
                    <h3 class="text-sm font-semibold text-stone-700 mb-3 cursor-pointer" onclick="toggleEducation()">
                        <i class="fas fa-book-open text-purple-500 mr-2"></i>
                        Despre Algoritmul Curent
                        <i id="eduToggle" class="fas fa-chevron-down ml-2 text-stone-400 transition-transform"></i>
                    </h3>
                    <div id="algorithmInfo" class="text-sm text-stone-600 space-y-2">
                        <!-- Will be populated based on selected algorithm -->
                    </div>
                </div>

                <!-- Console Log -->
                <div class="bg-stone-900 rounded-xl shadow-sm border border-stone-700 p-4">
                    <h3 class="text-sm font-semibold text-green-400 mb-3 flex items-center gap-2">
                        <i class="fas fa-terminal"></i> Event Log
                    </h3>
                    <div id="logConsole" class="h-32 overflow-y-auto text-xs mono text-green-300 space-y-1">
                        <div class="text-stone-500">// Scheduler ready. Selectează un algoritm și apasă Play.</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="mt-8 py-4 border-t border-stone-200 bg-white/50">
        <div class="max-w-7xl mx-auto px-4 text-center text-xs text-stone-400">
            By Revolvix, limited licence 2019-2030 | ASE-CSIE Bucharest
        </div>
    </footer>

    <script>
        // ==================== State ====================
        const PROCESS_COLORS = ['#3b82f6', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#84cc16'];
        
        let processes = [];
        let processCounter = 0;
        let simulation = {
            time: 0,
            running: false,
            complete: false,
            interval: null,
            ganttSegments: [],
            readyQueue: [],
            waitingProcesses: [],
            completedProcesses: [],
            metrics: {}
        };

        // ==================== Process Management ====================
        function addProcess(arrival = 0, burst = 1, priority = 1) {
            processCounter++;
            const process = {
                id: processCounter,
                name: `P${processCounter}`,
                arrival: arrival,
                burst: burst,
                priority: priority,
                remaining: burst,
                color: PROCESS_COLORS[(processCounter - 1) % PROCESS_COLORS.length],
                started: false,
                startTime: null,
                finishTime: null
            };
            processes.push(process);
            renderProcessTable();
            renderLegend();
            return process;
        }

        function removeProcess(id) {
            processes = processes.filter(p => p.id !== id);
            renderProcessTable();
            renderLegend();
        }

        function updateProcess(id, field, value) {
            const process = processes.find(p => p.id === id);
            if (process) {
                process[field] = parseInt(value) || 0;
                process.remaining = process.burst;
            }
        }

        function renderProcessTable() {
            const tbody = document.getElementById('processTable');
            tbody.innerHTML = processes.map(p => `
                <tr class="border-t border-stone-100">
                    <td class="p-2">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded" style="background: ${p.color}"></div>
                            <span class="font-mono font-semibold">${p.name}</span>
                        </div>
                    </td>
                    <td class="p-2">
                        <input type="number" value="${p.arrival}" min="0" max="50" 
                               onchange="updateProcess(${p.id}, 'arrival', this.value)"
                               class="w-12 p-1 border border-stone-200 rounded text-center mono">
                    </td>
                    <td class="p-2">
                        <input type="number" value="${p.burst}" min="1" max="20" 
                               onchange="updateProcess(${p.id}, 'burst', this.value)"
                               class="w-12 p-1 border border-stone-200 rounded text-center mono">
                    </td>
                    <td class="p-2">
                        <input type="number" value="${p.priority}" min="1" max="10" 
                               onchange="updateProcess(${p.id}, 'priority', this.value)"
                               class="w-12 p-1 border border-stone-200 rounded text-center mono">
                    </td>
                    <td class="p-2 text-center">
                        <button onclick="removeProcess(${p.id})" class="text-red-500 hover:text-red-700">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                    </td>
                </tr>
            `).join('');
        }

        function renderLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = processes.map(p => `
                <div class="flex items-center gap-1 px-2 py-1 bg-stone-100 rounded text-xs">
                    <div class="w-3 h-3 rounded" style="background: ${p.color}"></div>
                    <span class="mono">${p.name}</span>
                </div>
            `).join('');
        }

        // ==================== Presets ====================
        function loadPreset(type) {
            processes = [];
            processCounter = 0;
            
            switch(type) {
                case 'simple':
                    addProcess(0, 5, 2);
                    addProcess(1, 3, 1);
                    addProcess(2, 8, 3);
                    addProcess(3, 2, 4);
                    break;
                case 'complex':
                    addProcess(0, 6, 2);
                    addProcess(2, 2, 1);
                    addProcess(4, 8, 3);
                    addProcess(6, 3, 2);
                    addProcess(8, 4, 4);
                    break;
                case 'priority':
                    addProcess(0, 4, 3);
                    addProcess(1, 3, 1);
                    addProcess(2, 1, 4);
                    addProcess(3, 5, 2);
                    addProcess(4, 2, 5);
                    break;
            }
            resetSimulation();
            log(`Preset "${type}" încărcat cu ${processes.length} procese`);
        }

        // ==================== Scheduling Algorithms ====================
        function getNextProcess(algorithm, readyQueue, currentTime) {
            if (readyQueue.length === 0) return null;
            
            switch(algorithm) {
                case 'FCFS':
                    return readyQueue[0];
                    
                case 'SJF':
                case 'SRTF':
                    return readyQueue.reduce((min, p) => p.remaining < min.remaining ? p : min);
                    
                case 'RR':
                    return readyQueue[0];
                    
                case 'PRIORITY_NP':
                case 'PRIORITY_P':
                    return readyQueue.reduce((min, p) => p.priority < min.priority ? p : min);
                    
                default:
                    return readyQueue[0];
            }
        }

        function isPreemptive(algorithm) {
            return ['SRTF', 'RR', 'PRIORITY_P'].includes(algorithm);
        }

        // ==================== Simulation ====================
        function initSimulation() {
            simulation = {
                time: 0,
                running: false,
                complete: false,
                interval: null,
                ganttSegments: [],
                readyQueue: [],
                currentProcess: null,
                quantumRemaining: parseInt(document.getElementById('quantum').value),
                completedCount: 0
            };
            
            // Reset process states
            processes.forEach(p => {
                p.remaining = p.burst;
                p.started = false;
                p.startTime = null;
                p.finishTime = null;
            });
            
            document.getElementById('currentTime').textContent = '0';
            document.getElementById('queueTime').textContent = '0';
            renderGantt();
            renderReadyQueue();
            renderMetrics();
        }

        function stepSimulation() {
            if (simulation.complete) return;
            
            const algorithm = document.getElementById('algorithm').value;
            const quantum = parseInt(document.getElementById('quantum').value);
            
            // Add arriving processes to ready queue
            processes.forEach(p => {
                if (p.arrival === simulation.time && p.remaining > 0 && !simulation.readyQueue.includes(p)) {
                    simulation.readyQueue.push(p);
                    log(`t=${simulation.time}: ${p.name} arrived (burst=${p.burst})`);
                }
            });
            
            // Handle preemption for SRTF and Priority Preemptive
            if (simulation.currentProcess && isPreemptive(algorithm) && algorithm !== 'RR') {
                const better = getNextProcess(algorithm, simulation.readyQueue, simulation.time);
                if (better && better !== simulation.currentProcess) {
                    if ((algorithm === 'SRTF' && better.remaining < simulation.currentProcess.remaining) ||
                        (algorithm === 'PRIORITY_P' && better.priority < simulation.currentProcess.priority)) {
                        log(`t=${simulation.time}: ${simulation.currentProcess.name} preempted by ${better.name}`);
                        if (!simulation.readyQueue.includes(simulation.currentProcess)) {
                            simulation.readyQueue.push(simulation.currentProcess);
                        }
                        simulation.currentProcess = null;
                    }
                }
            }
            
            // Select next process if none running
            if (!simulation.currentProcess && simulation.readyQueue.length > 0) {
                simulation.currentProcess = getNextProcess(algorithm, simulation.readyQueue, simulation.time);
                simulation.readyQueue = simulation.readyQueue.filter(p => p !== simulation.currentProcess);
                simulation.quantumRemaining = quantum;
                
                if (!simulation.currentProcess.started) {
                    simulation.currentProcess.started = true;
                    simulation.currentProcess.startTime = simulation.time;
                }
                log(`t=${simulation.time}: ${simulation.currentProcess.name} started execution`);
            }
            
            // Execute current process
            if (simulation.currentProcess) {
                // Add to Gantt
                const lastSegment = simulation.ganttSegments[simulation.ganttSegments.length - 1];
                if (lastSegment && lastSegment.process === simulation.currentProcess && lastSegment.end === simulation.time) {
                    lastSegment.end = simulation.time + 1;
                } else {
                    simulation.ganttSegments.push({
                        process: simulation.currentProcess,
                        start: simulation.time,
                        end: simulation.time + 1
                    });
                }
                
                simulation.currentProcess.remaining--;
                simulation.quantumRemaining--;
                
                // Check if process completed
                if (simulation.currentProcess.remaining === 0) {
                    simulation.currentProcess.finishTime = simulation.time + 1;
                    simulation.completedCount++;
                    log(`t=${simulation.time + 1}: ${simulation.currentProcess.name} completed`);
                    simulation.currentProcess = null;
                }
                // Check quantum expiry for RR
                else if (algorithm === 'RR' && simulation.quantumRemaining === 0) {
                    log(`t=${simulation.time + 1}: ${simulation.currentProcess.name} quantum expired, back to ready queue`);
                    simulation.readyQueue.push(simulation.currentProcess);
                    simulation.currentProcess = null;
                }
            }
            
            simulation.time++;
            document.getElementById('currentTime').textContent = simulation.time;
            document.getElementById('queueTime').textContent = simulation.time;
            
            // Check if simulation complete
            if (simulation.completedCount === processes.length) {
                simulation.complete = true;
                simulation.running = false;
                if (simulation.interval) {
                    clearInterval(simulation.interval);
                    simulation.interval = null;
                }
                document.getElementById('btnPlay').innerHTML = '<i class="fas fa-play"></i>';
                log(`Simulare completă! Toate cele ${processes.length} procese au terminat.`);
            }
            
            renderGantt();
            renderReadyQueue();
            renderMetrics();
        }

        function togglePlay() {
            if (simulation.complete) {
                resetSimulation();
            }
            
            simulation.running = !simulation.running;
            const btn = document.getElementById('btnPlay');
            
            if (simulation.running) {
                btn.innerHTML = '<i class="fas fa-pause"></i>';
                const speed = parseInt(document.getElementById('speedSlider').value);
                simulation.interval = setInterval(stepSimulation, speed);
                log('Simulare pornită');
            } else {
                btn.innerHTML = '<i class="fas fa-play"></i>';
                if (simulation.interval) {
                    clearInterval(simulation.interval);
                    simulation.interval = null;
                }
                log('Simulare oprită');
            }
        }

        function runComplete() {
            resetSimulation();
            while (!simulation.complete) {
                stepSimulation();
            }
        }

        function resetSimulation() {
            if (simulation.interval) {
                clearInterval(simulation.interval);
                simulation.interval = null;
            }
            document.getElementById('btnPlay').innerHTML = '<i class="fas fa-play"></i>';
            initSimulation();
            log('Simulare resetată');
        }

        // ==================== Rendering ====================
        function renderGantt() {
            const timeline = document.getElementById('timeline');
            const timeAxis = document.getElementById('timeAxis');
            const nowLine = document.getElementById('nowLine');
            
            if (simulation.ganttSegments.length === 0) {
                timeline.innerHTML = '<div class="text-stone-400 text-sm italic p-4">Gantt chart-ul va apărea aici</div>';
                timeAxis.innerHTML = '';
                nowLine.classList.add('hidden');
                return;
            }
            
            const maxTime = Math.max(simulation.time, ...simulation.ganttSegments.map(s => s.end));
            const unitWidth = Math.max(30, Math.min(50, 600 / maxTime));
            
            // Render segments
            timeline.innerHTML = simulation.ganttSegments.map(seg => {
                const width = (seg.end - seg.start) * unitWidth;
                const left = seg.start * unitWidth;
                return `
                    <div class="gantt-segment absolute h-12 rounded flex items-center justify-center text-white text-xs font-bold shadow"
                         style="background: ${seg.process.color}; width: ${width}px; left: ${left}px;"
                         data-tooltip="${seg.process.name}: ${seg.start}-${seg.end} (${seg.end - seg.start}u)">
                        ${seg.end - seg.start > 1 ? seg.process.name : ''}
                    </div>
                `;
            }).join('');
            
            // Render time axis
            timeAxis.innerHTML = '';
            for (let t = 0; t <= maxTime; t++) {
                const marker = document.createElement('div');
                marker.className = 'text-xs text-stone-500 mono';
                marker.style.width = unitWidth + 'px';
                marker.style.textAlign = 'center';
                marker.textContent = t;
                timeAxis.appendChild(marker);
            }
            
            // Position NOW line
            if (!simulation.complete) {
                nowLine.classList.remove('hidden');
                nowLine.style.left = (simulation.time * unitWidth) + 'px';
            } else {
                nowLine.classList.add('hidden');
            }
        }

        function renderReadyQueue() {
            const queue = document.getElementById('readyQueue');
            
            if (simulation.readyQueue.length === 0 && !simulation.currentProcess) {
                queue.innerHTML = '<span class="text-stone-400 text-sm italic">Coada goală</span>';
                return;
            }
            
            let html = '';
            
            if (simulation.currentProcess) {
                html += `
                    <div class="ready-queue-item flex flex-col items-center px-3 py-2 rounded-lg text-white text-xs font-bold"
                         style="background: ${simulation.currentProcess.color}">
                        <span>${simulation.currentProcess.name}</span>
                        <span class="text-[10px] opacity-80">RUNNING</span>
                        <span class="text-[10px] opacity-80">rem: ${simulation.currentProcess.remaining}</span>
                    </div>
                    <i class="fas fa-arrow-right text-stone-300"></i>
                `;
            }
            
            html += simulation.readyQueue.map(p => `
                <div class="ready-queue-item flex flex-col items-center px-3 py-2 bg-stone-200 rounded-lg text-xs font-bold"
                     style="border-left: 4px solid ${p.color}">
                    <span>${p.name}</span>
                    <span class="text-[10px] text-stone-500">rem: ${p.remaining}</span>
                </div>
            `).join('');
            
            queue.innerHTML = html;
        }

        function renderMetrics() {
            const tbody = document.getElementById('metricsTable');
            const footer = document.getElementById('metricsFooter');
            
            const completed = processes.filter(p => p.finishTime !== null);
            
            if (completed.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="p-4 text-center text-stone-400">Rulează simularea pentru a vedea metricile</td></tr>';
                footer.classList.add('hidden');
                return;
            }
            
            let totalWaiting = 0, totalTurnaround = 0, totalResponse = 0;
            
            tbody.innerHTML = processes.map(p => {
                if (p.finishTime === null) {
                    return `
                        <tr class="border-t border-stone-100">
                            <td class="p-2"><span class="mono" style="color: ${p.color}">${p.name}</span></td>
                            <td class="p-2 text-center mono">${p.arrival}</td>
                            <td class="p-2 text-center mono">${p.burst}</td>
                            <td class="p-2 text-center text-stone-400">-</td>
                            <td class="p-2 text-center text-stone-400">-</td>
                            <td class="p-2 text-center text-stone-400">-</td>
                            <td class="p-2 text-center text-stone-400">-</td>
                            <td class="p-2 text-center text-stone-400">-</td>
                        </tr>
                    `;
                }
                
                const turnaround = p.finishTime - p.arrival;
                const waiting = turnaround - p.burst;
                const response = p.startTime - p.arrival;
                
                totalWaiting += waiting;
                totalTurnaround += turnaround;
                totalResponse += response;
                
                return `
                    <tr class="border-t border-stone-100">
                        <td class="p-2"><span class="mono font-semibold" style="color: ${p.color}">${p.name}</span></td>
                        <td class="p-2 text-center mono">${p.arrival}</td>
                        <td class="p-2 text-center mono">${p.burst}</td>
                        <td class="p-2 text-center mono">${p.startTime}</td>
                        <td class="p-2 text-center mono">${p.finishTime}</td>
                        <td class="p-2 text-center mono font-semibold text-amber-600">${waiting}</td>
                        <td class="p-2 text-center mono font-semibold text-blue-600">${turnaround}</td>
                        <td class="p-2 text-center mono font-semibold text-green-600">${response}</td>
                    </tr>
                `;
            }).join('');
            
            if (completed.length > 0) {
                footer.classList.remove('hidden');
                document.getElementById('avgWaiting').textContent = (totalWaiting / completed.length).toFixed(2);
                document.getElementById('avgTurnaround').textContent = (totalTurnaround / completed.length).toFixed(2);
                document.getElementById('avgResponse').textContent = (totalResponse / completed.length).toFixed(2);
            }
        }

        // ==================== Logging ====================
        function log(message) {
            const console = document.getElementById('logConsole');
            const time = new Date().toLocaleTimeString('ro-RO');
            const entry = document.createElement('div');
            entry.innerHTML = `<span class="text-stone-500">[${time}]</span> ${message}`;
            console.appendChild(entry);
            console.scrollTop = console.scrollHeight;
            
            while (console.children.length > 100) {
                console.removeChild(console.firstChild);
            }
        }

        // ==================== Algorithm Info ====================
        function updateAlgorithmInfo() {
            const algorithm = document.getElementById('algorithm').value;
            const info = document.getElementById('algorithmInfo');
            
            const descriptions = {
                'FCFS': `
                    <p><strong>First Come First Served</strong> — Cel mai simplu algoritm de planificare.</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li>Procesele sunt executate în ordinea sosirii</li>
                        <li>Non-preemptive: odată pornit, un proces rulează până la final</li>
                        <li>Simplu de implementat, dar poate cauza "convoy effect"</li>
                        <li>Timp mediu de așteptare poate fi mare</li>
                    </ul>
                `,
                'SJF': `
                    <p><strong>Shortest Job First (Non-preemptive)</strong> — Optim pentru minimizarea timpului mediu de așteptare.</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li>Selectează procesul cu cel mai mic burst time</li>
                        <li>Minimizează timpul mediu de așteptare</li>
                        <li>Poate cauza starvation pentru procese lungi</li>
                        <li>Necesită cunoașterea în avans a burst time-ului</li>
                    </ul>
                `,
                'SRTF': `
                    <p><strong>Shortest Remaining Time First (Preemptive)</strong> — Versiunea preemptive a SJF.</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li>Preemptează procesul curent dacă sosește unul cu timp rămas mai mic</li>
                        <li>Optim pentru minimizarea timpului mediu de așteptare</li>
                        <li>Mai multe context switch-uri decât SJF</li>
                        <li>Risc crescut de starvation</li>
                    </ul>
                `,
                'RR': `
                    <p><strong>Round Robin</strong> — Algoritm fair, bazat pe time slicing.</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li>Fiecare proces primește un time quantum fix</li>
                        <li>După expirarea quantum-ului, procesul merge la sfârșitul cozii</li>
                        <li>Timp de răspuns bun pentru procese interactive</li>
                        <li>Performanța depinde de alegerea quantum-ului</li>
                    </ul>
                `,
                'PRIORITY_NP': `
                    <p><strong>Priority Scheduling (Non-preemptive)</strong> — Bazat pe priorități asignate.</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li>Procesul cu prioritatea cea mai mare (număr mic) rulează primul</li>
                        <li>Non-preemptive: procesul curent nu este întrerupt</li>
                        <li>Poate cauza starvation pentru procese cu prioritate mică</li>
                        <li>Soluție: aging (creșterea progresivă a priorității)</li>
                    </ul>
                `,
                'PRIORITY_P': `
                    <p><strong>Priority Scheduling (Preemptive)</strong> — Priority cu preemption.</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">
                        <li>Un proces nou cu prioritate mai mare preemptează procesul curent</li>
                        <li>Răspuns rapid pentru procese de prioritate înaltă</li>
                        <li>Risc mare de starvation</li>
                        <li>Mai multe context switch-uri</li>
                    </ul>
                `
            };
            
            info.innerHTML = descriptions[algorithm] || '';
            
            // Show/hide quantum config
            document.getElementById('quantumConfig').style.display = algorithm === 'RR' ? 'block' : 'none';
        }

        function toggleEducation() {
            const info = document.getElementById('algorithmInfo');
            const toggle = document.getElementById('eduToggle');
            info.classList.toggle('hidden');
            toggle.classList.toggle('rotate-180');
        }

        // ==================== Initialization ====================
        document.getElementById('algorithm').addEventListener('change', updateAlgorithmInfo);
        
        // Load default preset
        loadPreset('simple');
        updateAlgorithmInfo();
    </script>
</body>
</html>