# ═══════════════════════════════════════════════════════════════════════════════
# Quiz Formativ - Seminarul 02: Operatori, Redirecționare, Filtre, Bucle
# ═══════════════════════════════════════════════════════════════════════════════
#
# Sisteme de Operare | ASE București - CSIE
# Format: YAML rulabil cu quiz_runner.py
# Total: 25 întrebări | Durată estimată: 20-30 minute
#
# Distribuție Bloom (ajustată pentru începători):
#   REMEMBER:    5 întrebări (20%)
#   UNDERSTAND:  7 întrebări (28%)
#   APPLY:       8 întrebări (32%)
#   ANALYSE:     4 întrebări (16%)
#   EVALUATE:    1 întrebare (4%)
#
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  seminar: 2
  subiect: "Operatori de Control, Redirecționare I/O, Filtre și Bucle"
  versiune: "1.0"
  data: "2025-01"
  autor: "Kit Pedagogic SO | ASE București - CSIE"
  limba: "ro"
  timp_estimat_minute: 25
  distributie_bloom:
    remember: 5
    understand: 7
    apply: 8
    analyse: 4
    evaluate: 1

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 1: OPERATORI DE CONTROL
# ═══════════════════════════════════════════════════════════════════════════════

intrebari:

  # --- REMEMBER ---
  
  - id: q01
    tip: mcq
    bloom: remember
    categorie: "operatori"
    text: |
      Care operator execută a doua comandă DOAR dacă prima reușește (exit code 0)?
    optiuni:
      - ";"
      - "&&"
      - "||"
      - "&"
    corect: 1
    explicatie: |
      Operatorul && (AND logic) execută comanda din dreapta DOAR dacă cea din stânga
      returnează exit code 0 (succes). Este util pentru lanțuri de comenzi dependente.
    misconceptii:
      0: "Operatorul ; execută întotdeauna ambele comenzi, indiferent de rezultat"
      2: "Operatorul || execută a doua comandă când prima EȘUEAZĂ"
      3: "Operatorul & lansează comanda în background, nu verifică exit code"

  - id: q02
    tip: mcq
    bloom: remember
    categorie: "operatori"
    text: |
      Ce face operatorul & plasat la sfârșitul unei comenzi?
    optiuni:
      - "Execută comanda de două ori"
      - "Lansează comanda în background"
      - "Conectează stdout la stdin-ul altei comenzi"
      - "Redirecționează stderr la stdout"
    corect: 1
    explicatie: |
      Operatorul & lansat la sfârșitul comenzii o trimite în background, 
      eliberând imediat terminalul pentru alte comenzi.
    misconceptii:
      0: "Confuzie cu alte operatori"
      2: "Acesta e operatorul pipe |"
      3: "Aceasta e sintaxa 2>&1"

  # --- UNDERSTAND ---

  - id: q03
    tip: mcq
    bloom: understand
    categorie: "operatori"
    text: |
      ```bash
      mkdir test && echo "Creat" || echo "Eroare"
      ```
      Dacă directorul `test` DEJA EXISTĂ, ce se afișează?
    optiuni:
      - "Creat"
      - "Eroare"
      - "Creat și Eroare"
      - "Nimic (comanda eșuează silențios)"
    corect: 1
    explicatie: |
      mkdir eșuează (exit code non-zero) când directorul există.
      && nu se execută (echo "Creat" sărit).
      || SE execută deoarece lanțul anterior a eșuat.
      Rezultat: "Eroare"
    misconceptii:
      0: "Nu înțelege că mkdir returnează eroare când directorul există"
      2: "Crede că || se execută întotdeauna după &&"
      3: "Confuzie cu suprimarea erorilor prin 2>/dev/null"

  - id: q04
    tip: mcq
    bloom: understand
    categorie: "operatori"
    text: |
      ```bash
      ls /inexistent | wc -l
      echo "Exit code: $?"
      ```
      Ce va fi exit code-ul afișat?
    optiuni:
      - "Exit code-ul lui ls (non-zero, eroare)"
      - "Exit code-ul lui wc (0, succes)"
      - "Suma exit code-urilor"
      - "Eroare de sintaxă"
    corect: 1
    explicatie: |
      $? returnează doar exit code-ul ULTIMEI comenzi din pipeline.
      wc -l reușește (chiar dacă primește input gol), deci returnează 0.
      Pentru toate exit code-urile: ${PIPESTATUS[@]}
    misconceptii:
      0: "Crede că pipe-ul transmite exit code-ul primei comenzi"
      2: "Inventează un comportament inexistent"
      3: "Confuzie despre sintaxa pipe"

  - id: q05
    tip: mcq
    bloom: understand
    categorie: "operatori"
    text: |
      ```bash
      x=1
      { x=2; echo "În acolade: $x"; }
      echo "După acolade: $x"
      
      y=1
      ( y=2; echo "În paranteze: $y"; )
      echo "După paranteze: $y"
      ```
      Care sunt valorile finale pentru x și y în shell-ul principal?
    optiuni:
      - "x=2, y=2"
      - "x=2, y=1"
      - "x=1, y=2"
      - "x=1, y=1"
    corect: 1
    explicatie: |
      {} execută în shell-ul CURENT - modificările persistă (x=2).
      () execută în SUBSHELL - modificările se pierd (y rămâne 1).
    misconceptii:
      0: "Nu înțelege că () creează subshell"
      2: "Inversează comportamentul {} și ()"
      3: "Crede că ambele creează subshell"

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 2: REDIRECȚIONARE I/O
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q06
    tip: mcq
    bloom: remember
    categorie: "redirectare"
    text: |
      Care operator adaugă text la SFÂRȘITUL unui fișier existent (fără a-l suprascrie)?
    optiuni:
      - ">"
      - ">>"
      - "<"
      - "2>"
    corect: 1
    explicatie: |
      >> (append) adaugă la sfârșitul fișierului.
      > suprascrie fișierul complet.
      < redirecționează input.
      2> redirecționează stderr.
    misconceptii:
      0: "> suprascrie fișierul"
      2: "< e pentru input, nu output"
      3: "2> e pentru stderr"

  - id: q07
    tip: mcq
    bloom: understand
    categorie: "redirectare"
    text: |
      ```bash
      # Varianta A:
      ls /home /inexistent > out.txt 2>&1
      
      # Varianta B:
      ls /home /inexistent 2>&1 > out.txt
      ```
      Care variantă trimite AMBELE (stdout și stderr) în out.txt?
    optiuni:
      - "Varianta A"
      - "Varianta B"
      - "Ambele variante"
      - "Niciuna - trebuie &>"
    corect: 0
    explicatie: |
      Redirecționările se evaluează de la stânga la dreapta!
      
      Varianta A: 
      1. > out.txt: stdout → out.txt
      2. 2>&1: stderr → unde e stdout ACUM (out.txt)
      
      Varianta B:
      1. 2>&1: stderr → unde e stdout ACUM (terminal)
      2. > out.txt: stdout → out.txt (stderr rămâne pe terminal!)
    misconceptii:
      1: "Nu înțelege ordinea evaluării redirecționărilor"
      2: "Crede că ordinea nu contează"
      3: "Nu știe sintaxa clasică, crede că doar &> funcționează"

  - id: q08
    tip: mcq
    bloom: understand
    categorie: "redirectare"
    text: |
      ```bash
      ls /inexistent 2>/dev/null
      echo $?
      ```
      Ce valoare va avea $? (exit code)?
    optiuni:
      - "0 (succes, pentru că eroarea a fost suprimată)"
      - "Non-zero (eroare, pentru că directorul nu există)"
      - "Nimic - $? nu e definit"
      - "Eroare de sintaxă"
    corect: 1
    explicatie: |
      2>/dev/null suprimă doar OUTPUT-ul erorii, nu și exit code-ul!
      Comanda tot eșuează (exit code non-zero), doar nu vedem mesajul.
    misconceptii:
      0: "FRECVENTĂ: Crede că suprimarea mesajului = succes"
      2: "Confuzie despre $?"
      3: "Nu cunoaște sintaxa"

  - id: q09
    tip: mcq
    bloom: apply
    categorie: "redirectare"
    text: |
      Cum salvezi ATÂT stdout CÂT ȘI stderr într-un fișier log.txt folosind Bash?
    optiuni:
      - "cmd > log.txt 2> log.txt"
      - "cmd &> log.txt"
      - "cmd 2> log.txt 1> log.txt"
      - "cmd | tee log.txt"
    corect: 1
    explicatie: |
      &> este sintaxa Bash pentru a redirecționa ambele stream-uri.
      Echivalent cu: cmd > log.txt 2>&1
      
      Opțiunea A/C poate cauza probleme de suprascriere.
      Opțiunea D (tee) nu capturează stderr.
    misconceptii:
      0: "Poate cauza probleme de concurență la scriere"
      2: "Aceeași problemă ca opțiunea A"
      3: "tee nu redirecționează stderr"

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 3: FILTRE DE TEXT
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q10
    tip: mcq
    bloom: understand
    categorie: "filtre"
    text: |
      ```bash
      echo -e "a\nb\na\nb" | uniq
      ```
      Ce afișează această comandă?
    optiuni:
      - "a\nb"
      - "a\nb\na\nb"
      - "a\na\nb\nb"
      - "Eroare - uniq necesită fișier"
    corect: 1
    explicatie: |
      CAPCANĂ CLASICĂ: uniq elimină doar duplicatele CONSECUTIVE!
      Input: a, b, a, b - niciuna nu e consecutivă cu alta identică.
      Toate rămân.
      Pattern corect: sort | uniq sau sort -u
    misconceptii:
      0: "80% cred asta! Nu știu că uniq elimină doar CONSECUTIVE"
      2: "Crede că uniq și sortează"
      3: "Nu cunoaște pipe-uri"

  - id: q11
    tip: mcq
    bloom: understand
    categorie: "filtre"
    text: |
      ```bash
      echo "one two three" | cut -f2
      ```
      Ce afișează?
    optiuni:
      - "two"
      - "one two three"
      - "Eroare"
      - "(nimic/linie goală)"
    corect: 1
    explicatie: |
      cut -f folosește TAB ca delimitator implicit, nu spațiu!
      Stringul "one two three" nu conține TAB.
      Fără TAB găsit, returnează întreaga linie.
      Pentru spații: cut -d' ' -f2
    misconceptii:
      0: "Crede că cut împarte după spații implicit"
      2: "Inventează o eroare"
      3: "Confuzie cu output gol"

  - id: q12
    tip: mcq
    bloom: apply
    categorie: "filtre"
    text: |
      Care comandă numără câte linii UNICE (fără duplicate) conține un fișier?
    optiuni:
      - "wc -l fisier.txt"
      - "sort fisier.txt | uniq | wc -l"
      - "uniq fisier.txt | wc -l"
      - "cat fisier.txt | wc -u"
    corect: 1
    explicatie: |
      sort | uniq elimină toate duplicatele (sortând mai întâi).
      wc -l numără liniile rezultate.
      
      Opțiunea A numără TOATE liniile.
      Opțiunea C nu sortează, deci uniq nu elimină toate duplicatele.
      Opțiunea D - wc nu are flag -u.
    misconceptii:
      0: "Numără toate liniile, inclusiv duplicate"
      2: "uniq fără sort nu elimină toate duplicatele"
      3: "wc -u nu există"

  - id: q13
    tip: mcq
    bloom: apply
    categorie: "filtre"
    text: |
      Cum extragi DOAR coloana 3 dintr-un fișier CSV (separator virgulă)?
    optiuni:
      - "cut -f3 fisier.csv"
      - "cut -d',' -f3 fisier.csv"
      - "awk '{print $3}' fisier.csv"
      - "grep -o ',[^,]*,' fisier.csv"
    corect: 1
    explicatie: |
      cut -d',' setează delimitatorul la virgulă.
      -f3 selectează câmpul 3.
      
      Opțiunea A folosește TAB implicit (greșit pentru CSV).
      Opțiunea C: awk implicit folosește spații/tab-uri.
      Opțiunea D: regex complicat și incorect.
    misconceptii:
      0: "cut implicit folosește TAB, nu virgulă"
      2: "awk implicit nu folosește virgulă ca separator"
      3: "Regex-ul nu extrage corect coloana"

  - id: q14
    tip: mcq
    bloom: remember
    categorie: "filtre"
    text: |
      Care comandă afișează ultimele 20 de linii dintr-un fișier?
    optiuni:
      - "head -20 fisier.txt"
      - "tail -20 fisier.txt"
      - "cat -n 20 fisier.txt"
      - "less -20 fisier.txt"
    corect: 1
    explicatie: |
      tail -N afișează ultimele N linii.
      head -N afișează PRIMELE N linii.
      cat -n numerotează liniile, nu le limitează.
      less -20 nu e sintaxă validă pentru acest scop.
    misconceptii:
      0: "head afișează de la ÎNCEPUT"
      2: "cat -n numerotează, nu limitează"
      3: "less e pentru vizualizare interactivă"

  - id: q15
    tip: mcq
    bloom: apply
    categorie: "filtre"
    text: |
      ```bash
      echo "hello" | tr 'a-z' 'A-Z'
      ```
      Ce afișează?
    optiuni:
      - "hello"
      - "HELLO"
      - "Hello"
      - "hELLO"
    corect: 1
    explicatie: |
      tr 'a-z' 'A-Z' transformă TOATE literele mici în majuscule.
      Fiecare caracter din primul set e înlocuit cu corespondentul din al doilea.
    misconceptii:
      0: "Nu înțelege funcția tr"
      2: "Confuzie cu capitalizare parțială"
      3: "Confuzie cu ordinea transformării"

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 4: BUCLE
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q16
    tip: mcq
    bloom: understand
    categorie: "bucle"
    text: |
      ```bash
      N=5
      for i in {1..$N}; do
          echo $i
      done
      ```
      Ce afișează acest script?
    optiuni:
      - "1 2 3 4 5 (pe linii separate)"
      - "{1..5}"
      - "Eroare de sintaxă"
      - "Nimic (buclă goală)"
    corect: 1
    explicatie: |
      CAPCANĂ: Brace expansion se face ÎNAINTE de variable expansion!
      {1..$N} nu poate fi expandat deoarece $N nu e încă interpretat.
      Rămâne literal: "{1..5}"
      Bucla iterează o singură dată cu i="{1..5}"
      
      Soluții: seq, for ((i=1; i<=N; i++))
    misconceptii:
      0: "70% cred asta! Nu știu ordinea expansion-ului"
      2: "Crede că e sintaxă greșită"
      3: "Crede că bucla nu se execută deloc"

  - id: q17
    tip: mcq
    bloom: analyse
    categorie: "bucle"
    text: |
      ```bash
      count=0
      echo -e "a\nb\nc" | while read line; do
          ((count++))
      done
      echo "Count: $count"
      ```
      Ce afișează?
    optiuni:
      - "Count: 3"
      - "Count: 0"
      - "Count: 1"
      - "Eroare - count nu e definit"
    corect: 1
    explicatie: |
      SUBSHELL PROBLEM: Partea dreaptă a pipe-ului rulează în SUBSHELL!
      Modificările la count se fac în subshell.
      Când subshell-ul se termină, modificările se PIERD.
      Shell-ul principal vede count=0.
      
      Soluție: while read line; do ... done < <(echo -e "a\nb\nc")
    misconceptii:
      0: "65% cred asta! Nu cunosc subshell problem"
      2: "Înțelege parțial dar numără greșit"
      3: "Confuzie despre scope-ul variabilelor"

  - id: q18
    tip: mcq
    bloom: understand
    categorie: "bucle"
    text: |
      ```bash
      for i in 1 2 3; do
          if [ $i -eq 2 ]; then
              break
          fi
          echo $i
      done
      echo "După buclă"
      ```
      Ce se afișează?
    optiuni:
      - "1\nDupă buclă"
      - "1 (nimic mai mult - scriptul s-a oprit)"
      - "1\n2\nDupă buclă"
      - "1\n2\n3\nDupă buclă"
    corect: 0
    explicatie: |
      break iese doar din buclă, nu din script!
      La i=1: echo 1
      La i=2: break (ieșire din buclă înainte de echo)
      Continuă cu "După buclă"
      
      exit ar fi oprit scriptul complet.
    misconceptii:
      1: "Confundă break cu exit"
      2: "Crede că echo se execută înainte de break"
      3: "Nu înțelege break"

  - id: q19
    tip: mcq
    bloom: apply
    categorie: "bucle"
    text: |
      Care este modalitatea CORECTĂ de a itera prin fișierele .txt din directorul curent?
    optiuni:
      - "for f in $(ls *.txt); do"
      - "for f in *.txt; do"
      - "for f in `cat *.txt`; do"
      - "while f in *.txt; do"
    corect: 1
    explicatie: |
      for f in *.txt folosește glob expansion care păstrează numele întregi.
      
      Opțiunea A: $(ls *.txt) se split-uiește greșit pe spații în nume.
      Opțiunea C: cat citește CONȚINUTUL fișierelor, nu numele.
      Opțiunea D: sintaxă invalidă pentru while.
    misconceptii:
      0: "$(ls *.txt) cauzează probleme cu spații în nume"
      2: "cat citește conținut, nu nume de fișiere"
      3: "while nu are această sintaxă"

  - id: q20
    tip: mcq
    bloom: apply
    categorie: "bucle"
    text: |
      Cum citești un fișier linie cu linie în Bash?
    optiuni:
      - "for line in $(cat fisier.txt); do"
      - "while read line; do ... done < fisier.txt"
      - "cat fisier.txt | for line; do"
      - "read fisier.txt line"
    corect: 1
    explicatie: |
      while read line; do ... done < fisier.txt e pattern-ul corect.
      
      Opțiunea A: $(cat) split-uiește pe spații și newlines.
      Opțiunea C: sintaxă invalidă.
      Opțiunea D: sintaxă invalidă pentru read.
    misconceptii:
      0: "$(cat) nu păstrează liniile intacte"
      2: "Sintaxă for invalidă cu pipe"
      3: "Sintaxă read invalidă"

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 5: ÎNTREBĂRI INTEGRATE / AVANSATE
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q21
    tip: mcq
    bloom: analyse
    categorie: "integrat"
    text: |
      ```bash
      cat access.log | grep "404" | cut -d' ' -f1 | sort | uniq -c | sort -rn | head -5
      ```
      Ce face acest pipeline?
    optiuni:
      - "Afișează primele 5 linii cu erori 404"
      - "Afișează top 5 IP-uri cu cele mai multe erori 404"
      - "Numără total de erori 404 în log"
      - "Sortează fișierul și afișează primele 5 linii"
    corect: 1
    explicatie: |
      Pas cu pas:
      1. cat access.log: citește fișierul
      2. grep "404": filtrează liniile cu 404
      3. cut -d' ' -f1: extrage primul câmp (IP)
      4. sort: sortează IP-urile (necesar pentru uniq)
      5. uniq -c: numără ocurențele
      6. sort -rn: sortează numeric descrescător
      7. head -5: primele 5 rezultate
      
      Rezultat: Top 5 IP-uri cu cele mai multe erori 404
    misconceptii:
      0: "Nu înțelege că uniq -c numără"
      2: "Nu urmărește tot pipeline-ul"
      3: "Confuzie despre funcția sort -rn"

  - id: q22
    tip: mcq
    bloom: analyse
    categorie: "integrat"
    text: |
      Care comandă este echivalentă cu `cat file.txt | grep pattern`?
    optiuni:
      - "grep pattern file.txt"
      - "grep file.txt pattern"
      - "pattern | grep file.txt"
      - "file.txt | grep pattern"
    corect: 0
    explicatie: |
      grep pattern file.txt este forma directă, fără cat inutil (UUOC).
      grep acceptă fișierul ca argument, nu necesită pipe de la cat.
      Aceasta e forma recomandată pentru eficiență.
    misconceptii:
      1: "Ordinea argumentelor la grep: pattern APOI fișier"
      2: "Sintaxă inversată, imposibilă"
      3: "Nu poți pipe un nume de fișier"

  - id: q23
    tip: mcq
    bloom: apply
    categorie: "integrat"
    text: |
      Cum rulezi o comandă în background și o faci imună la închiderea terminalului?
    optiuni:
      - "cmd &"
      - "nohup cmd &"
      - "bg cmd"
      - "daemon cmd"
    corect: 1
    explicatie: |
      nohup cmd & face comanda imună la SIGHUP (signal de hangup la închidere terminal).
      
      cmd & doar trimite în background, dar procesul moare la închidere terminal.
      bg mută un job DEJA suspendat în background.
      daemon nu e o comandă standard.
    misconceptii:
      0: "& singur nu protejează de SIGHUP"
      2: "bg e pentru job-uri suspendate, nu pentru lansare"
      3: "daemon nu există ca comandă standard"

  - id: q24
    tip: mcq
    bloom: remember
    categorie: "integrat"
    text: |
      Ce conține variabila specială $? în Bash?
    optiuni:
      - "PID-ul procesului curent"
      - "Exit code-ul ultimei comenzi executate"
      - "Numărul de argumente primite"
      - "Numele scriptului"
    corect: 1
    explicatie: |
      $? conține exit code-ul ultimei comenzi.
      $$ = PID-ul procesului curent
      $# = numărul de argumente
      $0 = numele scriptului
    misconceptii:
      0: "$$ e pentru PID"
      2: "$# e pentru număr argumente"
      3: "$0 e pentru nume script"

  - id: q25
    tip: mcq
    bloom: evaluate
    categorie: "integrat"
    text: |
      Un coleg a scris:
      ```bash
      for f in $(find . -name "*.log"); do
          rm "$f"
      done
      ```
      Care e cea mai bună practică pentru ștergerea fișierelor .log?
    optiuni:
      - "Codul este corect și sigur"
      - "find . -name '*.log' -delete"
      - "rm *.log"
      - "ls *.log | xargs rm"
    corect: 1
    explicatie: |
      find -delete e cel mai sigur și eficient:
      - Gestionează corect spațiile și caracterele speciale în nume
      - Un singur proces, nu fork pentru fiecare fișier
      - Atomic: șterge exact ce găsește
      
      Codul colegului: probleme cu spații în nume fișiere.
      rm *.log: nu e recursiv, poate eșua cu "argument list too long".
      ls | xargs rm: probleme cu spații și caractere speciale.
    misconceptii:
      0: "$(find) cauzează probleme cu spații în nume"
      2: "rm *.log nu e recursiv și are limite"
      3: "ls | xargs are probleme cu caractere speciale"

# ═══════════════════════════════════════════════════════════════════════════════
# CONFIGURARE SCORING
# ═══════════════════════════════════════════════════════════════════════════════

scoring:
  puncte_per_intrebare: 4
  total_maxim: 100
  praguri:
    excelent: 90
    bine: 75
    satisfacator: 60
    insuficient: 0
  feedback:
    excelent: "Felicitări! Stăpânești foarte bine conceptele de shell scripting."
    bine: "Bun nivel! Revizuiește pipe-urile și subshell-urile pentru perfecționare."
    satisfacator: "Progres bun! Practică mai mult cu redirecționare și bucle."
    insuficient: "Necesită studiu suplimentar. Revizuiește materialul și exersează."

# ═══════════════════════════════════════════════════════════════════════════════
# FIN
# ═══════════════════════════════════════════════════════════════════════════════
