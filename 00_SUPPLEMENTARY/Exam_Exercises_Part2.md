# SO - ExerciÈ›ii, Diagrame È™i ÃntrebÄƒri de Examen

## Partea 2: SÄƒptÄƒmÃ¢nile 5-8 (Fire de execuÈ›ie, Sincronizare, Interblocare)

> by Revolvix | ASE BucureÈ™ti - CSIE

### LegendÄƒ de dificultate

| Simbol | Nivel | Timp | Descriere |
|--------|-------|------|-----------|
| â­ | UÈ™or | 3â€“5 min | Reamintire È™i Ã®nÈ›elegere de bazÄƒ |
| â­â­ | Mediu | 5â€“10 min | Aplicarea conceptelor |
| â­â­â­ | Dificil | 10â€“15 min | AnalizÄƒ È™i calcul |
| â­â­â­â­ | Expert | 15â€“20 min | Evaluare È™i proiectare |

> ğŸ’¡ **Sfat de studiu:** ParcurgeÈ›i exerciÈ›iile fÄƒrÄƒ a consulta soluÈ›iile din prima Ã®ncercare. CronometraÈ›i-vÄƒ â€” Ã®ntrebÄƒrile de examen ar trebui sÄƒ dureze aproximativ 5 minute fiecare.



---

# SÄ‚PTÄ‚MÃ‚NA 5: Fire de execuÈ›ie

## Diagrame ASCII Detaliate

### Diagrama 5.1: fir de execuÈ›ie vs Process Memory Layout

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    PROCESS vs THREAD - MEMORY LAYOUT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DOUÄ‚ PROCESE SEPARATE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    PROCES A (PID 1000)                    PROCES B (PID 2000)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Virtual Address Space A    â”‚      â”‚  Virtual Address Space B    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚     Kernel Space      â”‚  â”‚      â”‚  â”‚     Kernel Space      â”‚  â”‚
â”‚  â”‚      (shared)         â”‚  â”‚      â”‚  â”‚      (shared)         â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚        Stack          â”‚  â”‚      â”‚  â”‚        Stack          â”‚  â”‚
â”‚  â”‚     (propriu)         â”‚  â”‚      â”‚  â”‚     (propriu)         â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                       â”‚  â”‚      â”‚  â”‚                       â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚        Heap           â”‚  â”‚      â”‚  â”‚        Heap           â”‚  â”‚
â”‚  â”‚     (propriu)         â”‚  â”‚      â”‚  â”‚     (propriu)         â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚      Data/BSS         â”‚  â”‚      â”‚  â”‚      Data/BSS         â”‚  â”‚
â”‚  â”‚     (propriu)         â”‚  â”‚      â”‚  â”‚     (propriu)         â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚        Text           â”‚  â”‚      â”‚  â”‚        Text           â”‚  â”‚
â”‚  â”‚      (propriu)        â”‚  â”‚      â”‚  â”‚      (propriu)        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                    â”‚
            â–¼                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         MEMORIA FIZICÄ‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚Frame A1 â”‚ â”‚Frame A2 â”‚ â”‚Frame B1 â”‚ â”‚Frame B2 â”‚ â”‚ Kernel  â”‚       â”‚
â”‚  â”‚(Stack A)â”‚ â”‚(Heap A) â”‚ â”‚(Stack B)â”‚ â”‚(Heap B) â”‚ â”‚(shared) â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                     â”‚
â”‚  Izolare COMPLETÄ‚: A nu poate accesa memoria lui B!                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
UN PROCES CU MULTIPLE THREADS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                    PROCES P (PID 1000) cu 3 THREADS
                    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Virtual Address Space (PARTAJAT)                    â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      Kernel Space                                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚  Stack T1   â”‚    â”‚  Stack T2   â”‚    â”‚  Stack T3   â”‚  â† SEPARATE     â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚                 â”‚
â”‚  â”‚  var_a = 5  â”‚    â”‚  var_a = 10 â”‚    â”‚  var_a = 15 â”‚  (variabile     â”‚
â”‚  â”‚  var_b = 2  â”‚    â”‚  var_b = 7  â”‚    â”‚  var_b = 9  â”‚   locale)       â”‚
â”‚  â”‚  ret_addr   â”‚    â”‚  ret_addr   â”‚    â”‚  ret_addr   â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚         â”‚                  â”‚                  â”‚                         â”‚
â”‚         â”‚    Thread ID     â”‚    Thread ID     â”‚    Thread ID           â”‚
â”‚         â”‚    Registers     â”‚    Registers     â”‚    Registers           â”‚
â”‚         â”‚    PC (Program   â”‚    PC            â”‚    PC         SEPARATE â”‚
â”‚         â”‚    Counter)      â”‚                  â”‚                         â”‚
â”‚         â”‚                  â”‚                  â”‚                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         HEAP                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚  shared_counter = 42                                     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  shared_array[] = [1, 2, 3, 4, 5]                       â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  mutex = <locked by T2>                                  â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ P â”‚
â”‚  â”‚                                                                  â”‚ A â”‚
â”‚  â”‚  ORICE THREAD POATE ACCESA ORICE DIN HEAP!                      â”‚ R â”‚
â”‚  â”‚  â†’ NEVOIE DE SINCRONIZARE!                                      â”‚ T â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ A â”‚
â”‚                                                                       J â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” A â”‚
â”‚  â”‚                      DATA/BSS                                    â”‚ T â”‚
â”‚  â”‚  global_config = "production"                                    â”‚   â”‚
â”‚  â”‚  log_level = 3                                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                        TEXT                                      â”‚   â”‚
â”‚  â”‚  [instrucÈ›iuni executabile]                                      â”‚   â”‚
â”‚  â”‚  Toate threads-urile executÄƒ acelaÈ™i cod!                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    FILE DESCRIPTORS                              â”‚   â”‚
â”‚  â”‚  fd[0] = stdin                                                   â”‚   â”‚
â”‚  â”‚  fd[1] = stdout                                                  â”‚ P â”‚
â”‚  â”‚  fd[2] = stderr                                                  â”‚ A â”‚
â”‚  â”‚  fd[3] = /var/log/app.log                                       â”‚ R â”‚
â”‚  â”‚                                                                  â”‚ T â”‚
â”‚  â”‚  PARTAJATE! Un thread deschide, toate pot folosi.               â”‚ A â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ J â”‚
â”‚                                                                       A â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SUMAR COMPARATIV:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Component     â”‚   PROCESE SEPARATE       â”‚   THREADS (acelaÈ™i proces)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Address Space   â”‚ SEPARAT pentru fiecare   â”‚ PARTAJAT                 â”‚
â”‚ Text (Code)     â”‚ Copiat/Separat           â”‚ PARTAJAT                 â”‚
â”‚ Data/BSS        â”‚ SEPARAT                  â”‚ PARTAJAT                 â”‚
â”‚ Heap            â”‚ SEPARAT                  â”‚ PARTAJAT                 â”‚
â”‚ Stack           â”‚ SEPARAT                  â”‚ SEPARAT per thread       â”‚
â”‚ Registers       â”‚ SEPARAT                  â”‚ SEPARAT per thread       â”‚
â”‚ PC              â”‚ SEPARAT                  â”‚ SEPARAT per thread       â”‚
â”‚ File Descriptorsâ”‚ Copiate la fork          â”‚ PARTAJAT                 â”‚
â”‚ PID             â”‚ Diferit                  â”‚ AcelaÈ™i                  â”‚
â”‚ TID             â”‚ N/A                      â”‚ Diferit                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Izolare         â”‚ âœ… CompletÄƒ              â”‚ âŒ MinimÄƒ                â”‚
â”‚ Comunicare      â”‚ IPC (pipes, sockets)     â”‚ Memorie partajatÄƒ directÄƒâ”‚
â”‚ Creare          â”‚ ~1-10 ms                 â”‚ ~10-100 Î¼s               â”‚
â”‚ Context Switch  â”‚ ~1-10 Î¼s + TLB flush     â”‚ ~0.1-1 Î¼s                â”‚
â”‚ Crash Impact    â”‚ Doar procesul respectiv  â”‚ Tot procesul moare       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Diagrama 5.2: Modele de Multithreading

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    MODELE DE MULTITHREADING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         MODEL 1: MANY-TO-ONE (N:1)                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘    USER SPACE                                                             â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚                                                                  â”‚   â•‘
â•‘    â”‚     T1 â—    T2 â—    T3 â—    T4 â—    T5 â—                       â”‚   â•‘
â•‘    â”‚       \      |       |       |      /                           â”‚   â•‘
â•‘    â”‚        \     |       |       |     /                            â”‚   â•‘
â•‘    â”‚         \    |       |       |    /                             â”‚   â•‘
â•‘    â”‚          â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€                              â”‚   â•‘
â•‘    â”‚                    |                                             â”‚   â•‘
â•‘    â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚   â•‘
â•‘    â”‚     â”‚   User-Level Thread Library  â”‚                             â”‚   â•‘
â•‘    â”‚     â”‚   (Green Fire de execuÈ›ie, Fibers)    â”‚                             â”‚   â•‘
â•‘    â”‚     â”‚   - Planificare Ã®n user space â”‚                             â”‚   â•‘
â•‘    â”‚     â”‚   - Context switch rapid     â”‚                             â”‚   â•‘
â•‘    â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚   â•‘
â•‘    â”‚                    â”‚                                             â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘                         â”‚                                                 â•‘
â•‘    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â•‘
â•‘                         â”‚  UN SINGUR kernel thread                        â•‘
â•‘    KERNEL SPACE         â–¼                                                 â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
â•‘    â”‚                     K1 â—†                                        â”‚    â•‘
â•‘    â”‚               (kernel thread)                                   â”‚    â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
â•‘                                                                           â•‘
â•‘    âœ… Avantaje:                    âŒ Dezavantaje:                        â•‘
â•‘    â€¢ Switch rapid Ã®ntre threads     â€¢ Un syscall blocant blocheazÄƒ TOATE  â•‘
â•‘    â€¢ Portabil                       â€¢ Nu poate exploata multi-core        â•‘
â•‘    â€¢ FÄƒrÄƒ overhead kernel           â€¢ Un thread crash = tot procesul      â•‘
â•‘                                                                           â•‘
â•‘    ğŸ“Œ Exemple: GNU Pth, Java Green Fire de execuÈ›ie (vechi)                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         MODEL 2: ONE-TO-ONE (1:1)                          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘    USER SPACE                                                             â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚                                                                  â”‚   â•‘
â•‘    â”‚     T1 â—         T2 â—         T3 â—         T4 â—                 â”‚   â•‘
â•‘    â”‚       â”‚            â”‚            â”‚            â”‚                   â”‚   â•‘
â•‘    â”‚       â”‚            â”‚            â”‚            â”‚                   â”‚   â•‘
â•‘    â”‚       â”‚            â”‚            â”‚            â”‚                   â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘            â”‚            â”‚            â”‚            â”‚                       â•‘
â•‘    â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â•‘
â•‘            â”‚  1:1       â”‚  1:1       â”‚  1:1       â”‚  1:1                  â•‘
â•‘    KERNEL  â–¼            â–¼            â–¼            â–¼                       â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
â•‘    â”‚     K1 â—†         K2 â—†         K3 â—†         K4 â—†                â”‚    â•‘
â•‘    â”‚   (kernel)     (kernel)     (kernel)     (kernel)               â”‚    â•‘
â•‘    â”‚    thread       thread       thread       thread                â”‚    â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
â•‘            â”‚            â”‚            â”‚            â”‚                       â•‘
â•‘            â–¼            â–¼            â–¼            â–¼                       â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â•‘
â•‘    â”‚     CPU 0       CPU 1       CPU 2       CPU 3                   â”‚    â•‘
â•‘    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”                 â”‚    â•‘
â•‘    â”‚   â”‚ Core â”‚    â”‚ Core â”‚    â”‚ Core â”‚    â”‚ Core â”‚                 â”‚    â•‘
â•‘    â”‚   â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”˜                 â”‚    â•‘
â•‘    â”‚              PARALELISM REAL PE MULTI-CORE!                     â”‚    â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â•‘
â•‘                                                                           â•‘
â•‘    âœ… Avantaje:                    âŒ Dezavantaje:                        â•‘
â•‘    â€¢ Paralelism real multi-core     â€¢ Overhead creare thread             â•‘
â•‘    â€¢ Un thread blocat nu afecteazÄƒ  â€¢ LimitÄƒ pe numÄƒrul de threads       â•‘
â•‘      pe altele                      â€¢ Switch prin kernel (mai lent)      â•‘
â•‘    â€¢ Scheduler kernel optimizat                                          â•‘
â•‘                                                                           â•‘
â•‘    ğŸ“Œ Exemple: Linux NPTL, Windows Fire de execuÈ›ie, macOS Fire de execuÈ›ie               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                       MODEL 3: MANY-TO-MANY (M:N)                          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                           â•‘
â•‘    USER SPACE                                                             â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚                                                                  â”‚   â•‘
â•‘    â”‚   T1 â—  T2 â—  T3 â—  T4 â—  T5 â—  T6 â—  T7 â—  T8 â—               â”‚   â•‘
â•‘    â”‚     \    |    /      \    |    /      \    /                    â”‚   â•‘
â•‘    â”‚      \   |   /        \   |   /        \  /                     â”‚   â•‘
â•‘    â”‚       \  |  /          \  |  /          \/                      â”‚   â•‘
â•‘    â”‚        \ | /            \ | /           /\                      â”‚   â•‘
â•‘    â”‚         â”€â”¼â”€              â”€â”¼â”€           /  \                     â”‚   â•‘
â•‘    â”‚     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”                    â”‚   â•‘
â•‘    â”‚     â”‚      User-Level Scheduler            â”‚                    â”‚   â•‘
â•‘    â”‚     â”‚  (multiplexeazÄƒ M user threads       â”‚                    â”‚   â•‘
â•‘    â”‚     â”‚   pe N kernel threads)               â”‚                    â”‚   â•‘
â•‘    â”‚     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜                    â”‚   â•‘
â•‘    â”‚          â”‚                â”‚            â”‚                        â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘               â”‚                â”‚            â”‚                            â•‘
â•‘    â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â•‘
â•‘               â”‚  M:N           â”‚            â”‚                            â•‘
â•‘    KERNEL     â–¼                â–¼            â–¼                            â•‘
â•‘    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘    â”‚          K1 â—†            K2 â—†         K3 â—†                     â”‚   â•‘
â•‘    â”‚       (kernel)         (kernel)      (kernel)                   â”‚   â•‘
â•‘    â”‚        thread           thread        thread                    â”‚   â•‘
â•‘    â”‚                                                                 â”‚   â•‘
â•‘    â”‚    8 user threads multiplexate pe 3 kernel threads!            â”‚   â•‘
â•‘    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘                                                                          â•‘
â•‘    âœ… Avantaje:                    âŒ Dezavantaje:                       â•‘
â•‘    â€¢ Flexibil (M >> N sau M = N)   â€¢ Complex de implementat            â•‘
â•‘    â€¢ CombinÄƒ beneficii N:1 È™i 1:1  â€¢ Sincronizare Ã®ntre schedulers     â•‘
â•‘    â€¢ Poate scala mii de threads    â€¢ Debugging dificil                  â•‘
â•‘                                                                          â•‘
â•‘    ğŸ“Œ Exemple: Go goroutines, Erlang processes, Solaris (istoric)       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## ExerciÈ›ii Rezolvate

### ExerciÈ›iul 5.1: Analiza Fire de execuÈ›ie vs Procese

ProblemÄƒ: Pentru fiecare scenariu, decide dacÄƒ ar trebui folosite fire de execuÈ›ie sau procese separate. JustificÄƒ.

| Scenariu | Recomandare | Justificare |
|----------|-------------|-------------|
| Web server care serveÈ™te 10.000 de cereri simultane | Fire de execuÈ›ie (sau async I/O) | Cererile sunt independente dar partajeazÄƒ config, conexiuni DB. fir de execuÈ›ie-urile sunt mai uÈ™oare. |
| Browser cu taburi multiple | Procese separate pentru tab-uri | Izolare: un tab compromis/crashuit nu afecteazÄƒ altele (securitate, stabilitate) |
| AplicaÈ›ie de calcul È™tiinÈ›ific cu date partajate | Fire de execuÈ›ie | Nevoie de acces rapid la date partajate; overhead mic pentru comunicare |
| Pipeline de procesare video | Procese conectate cu pipes | Fiecare stage e independent, poate crÄƒpa separat, poate fi rescris Ã®n alt limbaj |
| Joc video cu rendering È™i fizicÄƒ | Fire de execuÈ›ie | Nevoie de sincronizare strÃ¢nsÄƒ, latenÈ›Äƒ micÄƒ, partajare stare joc |

---

### ExerciÈ›iul 5.2: fir de execuÈ›ie Safety

ProblemÄƒ: IdentificÄƒ problemele Ã®n codul urmÄƒtor È™i corecteazÄƒ-le.

```python
# COD PROBLEMATIC
import threading

counter = 0

def increment():
    global counter
    for _ in range(100000):
        counter = counter + 1  # PROBLEMÄ‚!

threads = [threading.Thread(target=increment) for _ in range(4)]
for t in threads:
    t.start()
for t in threads:
    t.join()

print(counter)  # Ar trebui sÄƒ fie 400000, dar probabil e mai mic!
```

SoluÈ›ie:

```python
# COD CORECTAT - Varianta 1: Lock
import threading

counter = 0
lock = threading.Lock()

def increment_safe():
    global counter
    for _ in range(100000):
        with lock:  # SecÈ›iune criticÄƒ protejatÄƒ
            counter = counter + 1

# Varianta 2: Atomics (threading are Lock, dar nu atomic counter)
# Ãn practicÄƒ, folosim Lock sau Queue

# Varianta 3: EvitÄƒ shared state - fiecare thread numÄƒrÄƒ local
def increment_local():
    local_count = 0
    for _ in range(100000):
        local_count += 1
    return local_count

# Apoi sumÄƒm rezultatele
from concurrent.futures import ThreadPoolExecutor
with ThreadPoolExecutor(max_workers=4) as executor:
    futures = [executor.submit(increment_local) for _ in range(4)]
    total = sum(f.result() for f in futures)
print(total)  # 400000 garantat!
```

---

## ÃntrebÄƒri Tip Examen

5.1 (GrilÄƒ) Ce partajeazÄƒ fir de execuÈ›ie-urile aceluiaÈ™i proces?
- a) Stack
- b) Registre CPU
- c) Program Counter
- d) Heap âœ“

---

5.2 (GrilÄƒ) Ãn modelul 1:1, dacÄƒ un fir de execuÈ›ie face un apel de sistem blocant:
- a) Toate fir de execuÈ›ie-urile se blocheazÄƒ
- b) Doar fir de execuÈ›ie-ul respectiv se blocheazÄƒ âœ“
- c) Procesul Ã®ntreg este terminat
- d) Kernel-ul creeazÄƒ automat un nou fir de execuÈ›ie

---

5.3 (5p) ExplicaÈ›i de ce creare unui fir de execuÈ›ie este mai rapidÄƒ decÃ¢t crearea unui proces nou.

RÄƒspuns model:

Crearea unui fir de execuÈ›ie este mai rapidÄƒ din mai multe motive:

1. FÄƒrÄƒ duplicare spaÈ›iu de adrese (2p):
   - Fork() copiazÄƒ page tables (chiar cu CoW)
   - fir de execuÈ›ie: doar alocÄƒ o nouÄƒ stivÄƒ (~8KB)

2. FÄƒrÄƒ setÄƒri de securitate noi (1p):
   - Procesul nou: verificare UID/GID, setare capabilities
   - fir de execuÈ›ie: moÈ™teneÈ™te totul de la proces

3. FÄƒrÄƒ alocare PID (0.5p):
   - Proces: kernel alocÄƒ PID nou
   - fir de execuÈ›ie: doar TID (mai simplu)

4. FÄƒrÄƒ duplicare file descriptors (0.5p):
   - Fork: copiazÄƒ tabela de fd
   - fir de execuÈ›ie: partajeazÄƒ direct

5. Mai puÈ›ine apeluri de sistem (1p):
   - Fork: `fork()` + setup complet
   - fir de execuÈ›ie: `clone(CLONE_VM|CLONE_FILES|...)` cu flags care zic "partajeazÄƒ tot"

---

# SÄ‚PTÄ‚MÃ‚NA 6: Sincronizare I

## Diagrame ASCII Detaliate

### Diagrama 6.1: Race Condition VizualizatÄƒ

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                         RACE CONDITION - VIZUALIZARE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Problema: counter++ NU este atomic!

Cod:
    counter = counter + 1

Se descompune Ã®n 3 instrucÈ›iuni:
    1. LOAD  counter â†’ registru
    2. ADD   1 â†’ registru
    3. STORE registru â†’ counter

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SCENARIUL CORECT (fÄƒrÄƒ interleaving):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

counter = 0

Thread A                            Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(1) LOAD  counter â†’ regA = 0
(2) ADD   1 â†’ regA = 1
(3) STORE regA â†’ counter = 1
                                    (4) LOAD  counter â†’ regB = 1
                                    (5) ADD   1 â†’ regB = 2
                                    (6) STORE regB â†’ counter = 2

Rezultat final: counter = 2 âœ“

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SCENARIUL CU RACE CONDITION (interleaving problematic):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

counter = 0

Thread A                            Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(1) LOAD  counter â†’ regA = 0
                                    (2) LOAD  counter â†’ regB = 0
(3) ADD   1 â†’ regA = 1
                                    (4) ADD   1 â†’ regB = 1
(5) STORE regA â†’ counter = 1
                                    (6) STORE regB â†’ counter = 1

Rezultat final: counter = 1 âœ— (ar trebui sÄƒ fie 2!)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
TIMELINE VIZUALÄ‚:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Timp    Thread A              Memoria           Thread B
â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€           â”€â”€â”€â”€â”€â”€â”€â”€

 t0     LOAD (0)              counter=0                         
        regA â† 0                               
                                               
 t1                           counter=0         LOAD (0)
                                                regB â† 0
                                               
 t2     ADD                   counter=0                
        regA = 1                               
                                               
 t3                           counter=0         ADD
                                                regB = 1
                                               
 t4     STORE                 counter=1                
        counter â† regA                         
                                               
 t5                           counter=1         STORE
                                                counter â† regB
                                               
 t6                           counter=1  â† GREÈ˜IT!
                              (pierdut un increment)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SOLUÈšIA CU LOCK:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Thread A                            Thread B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
acquire(lock)                       
  (1) LOAD  counter â†’ regA = 0      |
  (2) ADD   1 â†’ regA = 1            |  acquire(lock) â†’ BLOCKED!
  (3) STORE regA â†’ counter = 1      |  (aÈ™teaptÄƒ...)
release(lock)                       |
                                    |  (lock available!)
                                    acquire(lock)
                                      (4) LOAD  counter â†’ regB = 1
                                      (5) ADD   1 â†’ regB = 2
                                      (6) STORE regB â†’ counter = 2
                                    release(lock)

Rezultat final: counter = 2 âœ“
```

### Diagrama 6.2: SecÈ›iunea CriticÄƒ È™i ProprietÄƒÈ›ile

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    SECÈšIUNEA CRITICÄ‚ - STRUCTURÄ‚
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        STRUCTURA STANDARD                               â”‚
â”‚                                                                         â”‚
â”‚   while (true) {                                                        â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚       â”‚         ENTRY SECTION                       â”‚                  â”‚
â”‚       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚                  â”‚
â”‚       â”‚  Cerere acces la secÈ›iunea criticÄƒ          â”‚                  â”‚
â”‚       â”‚  Ex: acquire(lock), wait(mutex)             â”‚                  â”‚
â”‚       â”‚  Poate bloca dacÄƒ cineva e Ã®nÄƒuntru         â”‚                  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                           â”‚                                             â”‚
â”‚                           â–¼                                             â”‚
â”‚       â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—                  â”‚
â”‚       â•‘         CRITICAL SECTION                    â•‘                  â”‚
â”‚       â•‘  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•          â•‘                  â”‚
â”‚       â•‘  AcceseazÄƒ resursa partajatÄƒ                â•‘                  â”‚
â”‚       â•‘  Ex: counter++, read/write shared data      â•‘                  â”‚
â”‚       â•‘                                             â•‘                  â”‚
â”‚       â•‘  âš ï¸ MAXIM UN PROCES AICI LA UN MOMENT DAT! â•‘                  â”‚
â”‚       â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                  â”‚
â”‚                           â”‚                                             â”‚
â”‚                           â–¼                                             â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚       â”‚         EXIT SECTION                        â”‚                  â”‚
â”‚       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚                  â”‚
â”‚       â”‚  ElibereazÄƒ accesul                         â”‚                  â”‚
â”‚       â”‚  Ex: release(lock), signal(mutex)           â”‚                  â”‚
â”‚       â”‚  Permite altora sÄƒ intre                    â”‚                  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                           â”‚                                             â”‚
â”‚                           â–¼                                             â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚       â”‚         REMAINDER SECTION                   â”‚                  â”‚
â”‚       â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚                  â”‚
â”‚       â”‚  Cod care nu acceseazÄƒ resursa partajatÄƒ    â”‚                  â”‚
â”‚       â”‚  Poate rula Ã®n paralel cu alÈ›ii             â”‚                  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚   }                                                                     â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CELE 3 PROPRIETÄ‚ÈšI NECESARE:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  1ï¸âƒ£ MUTUAL EXCLUSION (Excludere MutualÄƒ)                               â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                               â”‚
â”‚                                                                         â”‚
â”‚  "DacÄƒ procesul Pi executÄƒ Ã®n secÈ›iunea criticÄƒ,                       â”‚
â”‚   niciun alt proces Pj nu poate fi Ã®n secÈ›iunea sa criticÄƒ."           â”‚
â”‚                                                                         â”‚
â”‚       CS                         CS                                     â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚   â”‚         â”‚                â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚                               â”‚
â”‚   â”‚   P1    â”‚                â”‚ BLOCAT! â”‚ P2                            â”‚
â”‚   â”‚         â”‚                â”‚â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â”‚                               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                         â”‚
â”‚   Metafora: O singurÄƒ persoanÄƒ Ã®n toaletÄƒ la un moment dat.            â”‚
â”‚                                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  2ï¸âƒ£ PROGRESS (Progres)                                                  â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                    â”‚
â”‚                                                                         â”‚
â”‚  "DacÄƒ niciun proces nu e Ã®n CS È™i unele procese vor sÄƒ intre,         â”‚
â”‚   selecÈ›ia nu poate fi amÃ¢natÄƒ indefinit."                             â”‚
â”‚                                                                         â”‚
â”‚       CS (gol)                                                          â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        P1: "Vreau sÄƒ intru!"                             â”‚
â”‚   â”‚ (gol)   â”‚        P2: "È˜i eu!"                                      â”‚
â”‚   â”‚         â”‚                                                           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â†’ Unul dintre ei TREBUIE sÄƒ poatÄƒ intra!          â”‚
â”‚                                                                         â”‚
â”‚   Metafora: DacÄƒ toaleta e liberÄƒ È™i oameni aÈ™teaptÄƒ,                  â”‚
â”‚             cineva trebuie sÄƒ poatÄƒ intra (nu rÄƒmÃ¢ne goalÄƒ).           â”‚
â”‚                                                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  3ï¸âƒ£ BOUNDED WAITING (AÈ™teptare LimitatÄƒ)                               â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                               â”‚
â”‚                                                                         â”‚
â”‚  "ExistÄƒ o limitÄƒ pe numÄƒrul de ori Ã®n care alte procese               â”‚
â”‚   pot intra Ã®n CS dupÄƒ ce un proces a cerut acces."                    â”‚
â”‚                                                                         â”‚
â”‚   P1 cere acces: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚                  â”‚ Max N "depÄƒÈ™iri" pÃ¢nÄƒ intrÄƒ P1     â”‚               â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                         â”‚
â”‚   Metafora: La coadÄƒ, nu poÈ›i fi sÄƒrit de infinit de mulÈ›i oameni.    â”‚
â”‚                                                                         â”‚
â”‚   Contra-exemplu (starvation):                                         â”‚
â”‚   P1 aÈ™teaptÄƒ, dar P2, P3, P4... mereu intrÄƒ Ã®nainte â†’ P1 Ã®nfometeazÄƒ â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ExerciÈ›ii Rezolvate

### ExerciÈ›iul 6.1: Implementare Lock cu TAS

ProblemÄƒ: ImplementeazÄƒ un spinlock folosind Test-and-Set Ã®n pseudocod.

SoluÈ›ie:

```c
// Test-and-Set atomic (furnizat de hardware)
bool test_and_set(bool *target) {
    bool old = *target;
    *target = true;
    return old;
}

// Spinlock implementation
typedef struct {
    bool locked;
} spinlock_t;

void spinlock_init(spinlock_t *lock) {
    lock->locked = false;
}

void spinlock_acquire(spinlock_t *lock) {
    // Spin pÃ¢nÄƒ cÃ¢nd reuÈ™im sÄƒ setÄƒm locked de la false la true
    while (test_and_set(&lock->locked)) {
        // Busy wait (consumÄƒ CPU)
        // Optimizare: yield() sau pause instruction
    }
    // Acum avem lock-ul!
}

void spinlock_release(spinlock_t *lock) {
    lock->locked = false;
}
```

Verificare proprietÄƒÈ›i:
- Mutual Exclusion: âœ… Doar un fir de execuÈ›ie poate seta locked de la false la true
- Progress: âœ… DacÄƒ lock e liber (false), TAS va returna false È™i fir de execuÈ›ie-ul intrÄƒ
- Bounded Waiting: âŒ Nu garantat! Un fir de execuÈ›ie poate fi "nenorocos" È™i sÄƒ aÈ™tepte indefinit

---

### ExerciÈ›iul 6.2: Algoritmul Peterson

ProblemÄƒ: DemonstreazÄƒ cÄƒ algoritmul Peterson satisface mutual exclusion pentru 2 procese.

SoluÈ›ie:

```c
bool flag[2] = {false, false};  // flag[i] = procesul i vrea sÄƒ intre
int turn;                        // al cui e rÃ¢ndul

// Proces P0                     // Proces P1
flag[0] = true;                  flag[1] = true;
turn = 1;                        turn = 0;
while (flag[1] && turn == 1)     while (flag[0] && turn == 0)
    ; // wait                        ; // wait
// CRITICAL SECTION              // CRITICAL SECTION
flag[0] = false;                 flag[1] = false;
```

DemonstraÈ›ie Mutual Exclusion:

SÄƒ presupunem cÄƒ AMBELE procese sunt Ã®n CS simultan (contradicÈ›ie).

1. P0 a trecut de while â†’ `Â¬(flag[1] âˆ§ turn=1)` â†’ `Â¬flag[1] âˆ¨ turn=0`
2. P1 a trecut de while â†’ `Â¬(flag[0] âˆ§ turn=0)` â†’ `Â¬flag[0] âˆ¨ turn=1`

Dar ambele flag[i] = true cÃ¢nd vor sÄƒ intre. Deci:
- Din (1): turn = 0 (deoarece flag[1] = true)
- Din (2): turn = 1 (deoarece flag[0] = true)

ContradicÈ›ie! turn nu poate fi simultan 0 È™i 1. â–¡

---

## ÃntrebÄƒri Tip Examen

6.1 (GrilÄƒ) Care este diferenÈ›a principalÄƒ Ã®ntre spinlock È™i mutex?
- a) Spinlock e mai rapid
- b) Spinlock face busy-wait, mutex face sleep âœ“
- c) Mutex poate fi folosit doar pentru 2 procese
- d) Spinlock garanteazÄƒ bounded waiting

---

6.2 (5p) Un sistem are 3 procese P1, P2, P3 care acceseazÄƒ un contor partajat. Fiecare proces incrementeazÄƒ contorul de 1000 de ori. IniÈ›ial contorul e 0.

a) Care e valoarea aÈ™teptatÄƒ a contorului fÄƒrÄƒ sincronizare?
b) Care e valoarea minimÄƒ posibilÄƒ? ExplicÄƒ.
c) Cum rezolvi problema?

RÄƒspuns:

```
a) Valoarea aÈ™teptatÄƒ (dacÄƒ totul ar fi corect): 3000

b) Valoarea minimÄƒ: 3 (Ã®n cel mai rÄƒu caz teoretic, aproape 1000)

   ExplicaÈ›ie pentru minimum teoretic extrem:
- Toate thread-urile citesc 0 simultan â€” È™i legat de asta, toate adaugÄƒ 1
   - Toate scriu 1
   - Se repetÄƒ: citesc 1, adaugÄƒ 1, scriu 1
   - ... pÃ¢nÄƒ una terminÄƒ
   
   Practic, minimul e greu de atins dar poate fi semnificativ
   mai mic decÃ¢t 3000. Tipic: ~1000-2500.

c) SoluÈ›ie: ProtejeazÄƒ cu mutex/lock

   mutex_t lock;
   
   void increment() {
       for (int i = 0; i < 1000; i++) {
           lock(&lock);
           counter++;
           unlock(&lock);
       }
   }
   
   Sau foloseÈ™te operaÈ›ii atomice:
   __sync_fetch_and_add(&counter, 1);
```

---

# SÄ‚PTÄ‚MÃ‚NA 7: Sincronizare II (Semafoare)

## Diagrame ASCII Detaliate

### Diagrama 7.1: ProducÄƒtor-Consumator cu Semafoare

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    PRODUCÄ‚TOR-CONSUMATOR CU SEMAFOARE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PROBLEMA:
- Buffer de dimensiune N
- ProducÄƒtor: pune elemente (blocheazÄƒ dacÄƒ buffer plin)
- Consumator: ia elemente (blocheazÄƒ dacÄƒ buffer gol)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SEMAFOARE NECESARE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  empty = N     // CÃ¢te sloturi GOALE (iniÈ›ial toate N sunt goale)      â”‚
â”‚  full  = 0     // CÃ¢te elemente DISPONIBILE (iniÈ›ial niciunul)         â”‚
â”‚  mutex = 1     // Acces exclusiv la buffer (binar)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STAREA INIÈšIALÄ‚ (N=5):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚     â”‚     â”‚     â”‚     â”‚     â”‚   Buffer (toate goale)
â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚
â”‚     â”‚     â”‚     â”‚     â”‚     â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
  [0]   [1]   [2]   [3]   [4]

empty = 5 â—â—â—â—â—        full = 0 (gol)        mutex = 1 â—

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PRODUCÄ‚TOR PUNE ELEMENT:

    1. wait(empty)    // Ia un "slot gol" (empty: 5â†’4)
    
    empty = 4 â—â—â—â—        full = 0             mutex = 1 â—
    
    2. wait(mutex)    // IntrÄƒ Ã®n CS (mutex: 1â†’0)
    
    empty = 4 â—â—â—â—        full = 0             mutex = 0 (locked)
    
    3. buffer[in] = item; in = (in+1)%N;
    
    â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚     â”‚     â”‚     â”‚     â”‚   Element adÄƒugat!
    â”‚ A   â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚
    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚     â”‚     â”‚     â”‚     â”‚
    â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
      [0]   [1]   [2]   [3]   [4]
       â†‘
      in=1
    
    4. signal(mutex)  // Iese din CS (mutex: 0â†’1)
    
    5. signal(full)   // AnunÈ›Äƒ element nou (full: 0â†’1)
    
    empty = 4 â—â—â—â—        full = 1 â—           mutex = 1 â—

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CONSUMATOR IA ELEMENT:

    1. wait(full)     // Ia un "element disponibil" (full: 1â†’0)
    
    empty = 4 â—â—â—â—        full = 0             mutex = 1 â—
    
    2. wait(mutex)    // IntrÄƒ Ã®n CS (mutex: 1â†’0)
    
    3. item = buffer[out]; out = (out+1)%N;
    
    â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
    â”‚     â”‚     â”‚     â”‚     â”‚     â”‚   Element luat!
    â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚  -  â”‚
    â”‚     â”‚     â”‚     â”‚     â”‚     â”‚
    â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
       â†‘
      out=1
    
    4. signal(mutex)  // Iese din CS (mutex: 0â†’1)
    
    5. signal(empty)  // AnunÈ›Äƒ slot liber (empty: 4â†’5)
    
    empty = 5 â—â—â—â—â—       full = 0             mutex = 1 â—

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SCENARIUL DE BLOCARE:

Buffer PLIN (N=5 elemente):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
â”‚  A  â”‚  B  â”‚  C  â”‚  D  â”‚  E  â”‚
â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

empty = 0 (gol!)      full = 5 â—â—â—â—â—        mutex = 1 â—

ProducÄƒtor Ã®ncearcÄƒ: wait(empty)
â†’ empty = 0, deci BLOCHEAZÄ‚!
â†’ ProducÄƒtorul doarme pÃ¢nÄƒ cineva face signal(empty)

Consumatorul ia element, face signal(empty) â†’ empty = 1
â†’ ProducÄƒtorul se trezeÈ™te È™i continuÄƒ!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸ GREÈ˜EALÄ‚ COMUNÄ‚ - ORDINEA WAIT:

GREÈ˜IT:                          CORECT:
â”€â”€â”€â”€â”€â”€â”€â”€                         â”€â”€â”€â”€â”€â”€â”€
wait(mutex)                      wait(empty)     // ÃntÃ¢i verificÄƒ slot
wait(empty) â† DEADLOCK!          wait(mutex)     // Apoi ia mutex

DacÄƒ buffer plin:
- Thread-ul ia mutex
- BlocheazÄƒ pe empty
- Dar È›ine mutex!
- Consumatorul nu poate intra sÄƒ elibereze!
- DEADLOCK!
```

---

## ExerciÈ›ii Rezolvate

### ExerciÈ›iul 7.1: Cititori-Scriitori

ProblemÄƒ: ImplementeazÄƒ soluÈ›ia "readers preference" pentru problema cititori-scriitori.

SoluÈ›ie:

```c
semaphore rw_mutex = 1;     // Acces la resursÄƒ (scriitori sau primul/ultimul cititor)
semaphore mutex = 1;        // ProtejeazÄƒ read_count
int read_count = 0;         // CÃ¢È›i cititori activi

void reader() {
    wait(mutex);            // ProtejeazÄƒ read_count
    read_count++;
    if (read_count == 1)    // Primul cititor?
        wait(rw_mutex);     // BlocheazÄƒ scriitorii!
    signal(mutex);
    
    // READ DATA (mulÈ›i cititori simultan)
    
    wait(mutex);
    read_count--;
    if (read_count == 0)    // Ultimul cititor?
        signal(rw_mutex);   // Permite scriitori
    signal(mutex);
}

void writer() {
    wait(rw_mutex);         // Acces exclusiv
    
    // WRITE DATA (singur scriitor)
    
    signal(rw_mutex);
}
```

ExplicaÈ›ie: 
- Primul cititor ia rw_mutex â†’ blocheazÄƒ scriitorii
- UrmÄƒtorii cititori intrÄƒ direct (rw_mutex deja luat)
- Ultimul cititor elibereazÄƒ rw_mutex
- Scriitorii pot intra doar cÃ¢nd read_count = 0

ProblemÄƒ: Scriitorii pot Ã®nfometa dacÄƒ mereu vin cititori noi!

---

## ÃntrebÄƒri Tip Examen

7.1 (GrilÄƒ) Un semafor counting cu valoarea iniÈ›ialÄƒ 3 poate permite:
- a) Maxim 1 proces Ã®n secÈ›iunea criticÄƒ
- b) Maxim 3 procese simultan Ã®n secÈ›iunea criticÄƒ âœ“
- c) Infinite procese
- d) Exact 3 procese (nici mai puÈ›ine)

---

7.2 (5p) ExplicaÈ›i diferenÈ›a Ã®ntre wait() pe un semafor È™i wait() pe o variabilÄƒ de condiÈ›ie.

RÄƒspuns:

| Aspect | Semafor wait() | Condition Variable wait() |
|--------|----------------|---------------------------|
| Lock | NU afecteazÄƒ niciun lock | ELIBEREAZÄ‚ lock-ul asociat |
| Memorie | MemoreazÄƒ signal-uri (contorizeazÄƒ) | NU memoreazÄƒ - signal pierdut dacÄƒ nimeni nu aÈ™teaptÄƒ |
| La signal | DecrementeazÄƒ contorul | Doar trezeÈ™te, nu garanteazÄƒ condiÈ›ie |
| Verificare | Nu e nevoie de while | TREBUIE while (condiÈ›ia poate fi iar falsÄƒ) |
| SemanticÄƒ | Counting resource | Notificare/wait pe condiÈ›ie |

Exemplu concret:
```c
// Semafor
signal(sem);  // Chiar dacÄƒ nimeni nu aÈ™teaptÄƒ, sem creÈ™te
...           // Mai tÃ¢rziu:
wait(sem);    // Va reuÈ™i imediat (sem > 0)

// CV
signal(cv);   // DacÄƒ nimeni nu aÈ™teaptÄƒ, PIERDUT!
...           // Mai tÃ¢rziu:
wait(cv);     // Va bloca pentru totdeauna!
```

---

# SÄ‚PTÄ‚MÃ‚NA 8: Interblocare

## Diagrame ASCII Detaliate

### Diagrama 8.1: CondiÈ›iile Coffman Vizualizate

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    CELE 4 CONDIÈšII COFFMAN - VIZUALIZARE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Toate 4 condiÈ›iile TREBUIE sÄƒ fie prezente simultan pentru deadlock!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
1ï¸âƒ£ MUTUAL EXCLUSION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"Resursa poate fi deÈ›inutÄƒ de cel mult un proces la un moment dat"

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚    RESURSA   â”‚
    â”‚   (printer)  â”‚
    â”‚              â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
    â”‚  â”‚ P1 ğŸ”’  â”‚  â”‚  â† P1 deÈ›ine resursa exclusiv
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
    â”‚              â”‚
    â”‚   P2 â³ P3 â³ â”‚  â† P2, P3 aÈ™teaptÄƒ
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DacÄƒ resursa ar putea fi partajatÄƒ (ex: read-only file), nu ar fi problemÄƒ!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
2ï¸âƒ£ HOLD AND WAIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"Procesul deÈ›ine resurse È™i aÈ™teaptÄƒ altele"

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                P1                     â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
    â”‚  â”‚   R1    â”‚  vrea â†’ â”‚   R2    â”‚     â”‚
    â”‚  â”‚  (are)  â”‚         â”‚(nu are) â”‚     â”‚
    â”‚  â”‚  ğŸ”’     â”‚    â³    â”‚         â”‚     â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

P1 È›ine R1 cu dinÈ›ii È™i refuzÄƒ sÄƒ o dea Ã®nainte sÄƒ primeascÄƒ R2!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
3ï¸âƒ£ NO PREEMPTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"Resursa nu poate fi luatÄƒ forÈ›at - doar procesul o poate elibera voluntar"

         P2: "DÄƒ-mi R1!"
              â”‚
              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        P1           â”‚
    â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚   â”‚   R1    â”‚       â”‚  P1: "NU! E a mea!"
    â”‚   â”‚   ğŸ”’    â”‚ âœ‹     â”‚
    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    (Nimeni nu poate smulge R1 din mÃ¢na lui P1)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
4ï¸âƒ£ CIRCULAR WAIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"ExistÄƒ un ciclu de aÈ™teptare"

           P1 â”€â”€â”€â”€â”€â”€(aÈ™teaptÄƒ R2)â”€â”€â”€â”€â”€â”€â–¶ P2
            â–²                            â”‚
            â”‚                            â”‚
       (are R1)                     (are R2)
            â”‚                            â”‚
            â”‚                            â–¼
           P4 â—€â”€â”€â”€â”€(aÈ™teaptÄƒ R4)â”€â”€â”€â”€â”€â”€ P3
            â”‚                            â–²
       (are R4)                     (are R3)
            â”‚                            â”‚
            â””â”€â”€â”€â”€(aÈ™teaptÄƒ R3)â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Ciclu: P1â†’P2â†’P3â†’P4â†’P1
    ToÈ›i aÈ™teaptÄƒ, nimeni nu poate avansa â†’ DEADLOCK!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EXEMPLU COMPLET - DINING PHILOSOPHERS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

5 filozofi, 5 furculiÈ›e, fiecare ia Ã®ntÃ¢i furculiÈ›a din stÃ¢nga.

        F0            Fiecare filozof (P) are nevoie de
   P0 â—    â— P1       2 furculiÈ›e pentru a mÃ¢nca.
  F4 â”‚      â”‚ F1
     â—â”€â”€â”€â”€â”€â”€â—         ToÈ›i iau simultan furculiÈ›a stÃ¢nga:
    P4      P2        
     â”‚      â”‚         P0 ia F0
  F3 â—â”€â”€â”€â”€â”€â”€â— F2      P1 ia F1
        P3            P2 ia F2
                      P3 ia F3
                      P4 ia F4

Acum fiecare aÈ™teaptÄƒ furculiÈ›a dreapta:
P0 aÈ™teaptÄƒ F1 (deÈ›inutÄƒ de P1)
P1 aÈ™teaptÄƒ F2 (deÈ›inutÄƒ de P2)
P2 aÈ™teaptÄƒ F3 (deÈ›inutÄƒ de P3)
P3 aÈ™teaptÄƒ F4 (deÈ›inutÄƒ de P4)
P4 aÈ™teaptÄƒ F0 (deÈ›inutÄƒ de P0)

CICLU: P0â†’P1â†’P2â†’P3â†’P4â†’P0 â†’ DEADLOCK!
ToÈ›i au o furculiÈ›Äƒ (Hold), toÈ›i aÈ™teaptÄƒ alta (Wait), e ciclu (Circular).
```

### Diagrama 8.2: Algoritmul Banker

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    ALGORITMUL BANKER - EXEMPLU COMPLET
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Sistem cu 5 procese (P0-P4) È™i 3 tipuri de resurse (A, B, C).
Total resurse: A=10, B=5, C=7

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STAREA CURENTÄ‚:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        Allocation          Maximum            Need (Max-Alloc)
      â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”
      â”‚ A  â”‚ B  â”‚ C  â”‚   â”‚ A  â”‚ B  â”‚ C  â”‚   â”‚ A  â”‚ B  â”‚ C  â”‚
  â”Œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P0 â”‚ 0  â”‚ 1  â”‚ 0  â”‚   â”‚ 7  â”‚ 5  â”‚ 3  â”‚   â”‚ 7  â”‚ 4  â”‚ 3  â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P1 â”‚ 2  â”‚ 0  â”‚ 0  â”‚   â”‚ 3  â”‚ 2  â”‚ 2  â”‚   â”‚ 1  â”‚ 2  â”‚ 2  â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P2 â”‚ 3  â”‚ 0  â”‚ 2  â”‚   â”‚ 9  â”‚ 0  â”‚ 2  â”‚   â”‚ 6  â”‚ 0  â”‚ 0  â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P3 â”‚ 2  â”‚ 1  â”‚ 1  â”‚   â”‚ 2  â”‚ 2  â”‚ 2  â”‚   â”‚ 0  â”‚ 1  â”‚ 1  â”‚
  â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤
  â”‚P4 â”‚ 0  â”‚ 0  â”‚ 2  â”‚   â”‚ 4  â”‚ 3  â”‚ 3  â”‚   â”‚ 4  â”‚ 3  â”‚ 1  â”‚
  â””â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜

Total alocat: A=7, B=2, C=5
Available:    A=3, B=3, C=2

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SAFETY ALGORITHM - GÄ‚SIM SECVENÈšÄ‚ SIGURÄ‚:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Work = Available = [3, 3, 2]
Finish = [false, false, false, false, false]

ITERAÈšIA 1: CÄƒutÄƒm proces cu Need â‰¤ Work
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P0: Need=[7,4,3] â‰¤ Work=[3,3,2]? NO (7>3)
  P1: Need=[1,2,2] â‰¤ Work=[3,3,2]? YES! âœ“
  
  â†’ P1 poate termina
  â†’ Work = Work + Allocation[P1] = [3,3,2] + [2,0,0] = [5,3,2]
  â†’ Finish[P1] = true
  
                    Work = [5, 3, 2]

ITERAÈšIA 2:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P0: Need=[7,4,3] â‰¤ Work=[5,3,2]? NO
  P2: Need=[6,0,0] â‰¤ Work=[5,3,2]? NO (6>5)
  P3: Need=[0,1,1] â‰¤ Work=[5,3,2]? YES! âœ“
  
  â†’ P3 poate termina
  â†’ Work = [5,3,2] + [2,1,1] = [7,4,3]
  â†’ Finish[P3] = true
  
                    Work = [7, 4, 3]

ITERAÈšIA 3:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P0: Need=[7,4,3] â‰¤ Work=[7,4,3]? YES! âœ“
  
  â†’ P0 poate termina
  â†’ Work = [7,4,3] + [0,1,0] = [7,5,3]
  â†’ Finish[P0] = true
  
                    Work = [7, 5, 3]

ITERAÈšIA 4:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P2: Need=[6,0,0] â‰¤ Work=[7,5,3]? YES! âœ“
  
  â†’ P2 poate termina
  â†’ Work = [7,5,3] + [3,0,2] = [10,5,5]
  â†’ Finish[P2] = true
  
                    Work = [10, 5, 5]

ITERAÈšIA 5:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  P4: Need=[4,3,1] â‰¤ Work=[10,5,5]? YES! âœ“
  
  â†’ P4 poate termina
  â†’ Finish[P4] = true

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
REZULTAT: STARE SIGURÄ‚!
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SecvenÈ›Äƒ sigurÄƒ: <P1, P3, P0, P2, P4>

Toate procesele pot termina Ã®n aceastÄƒ ordine.
```

---

## ExerciÈ›ii Rezolvate

### ExerciÈ›iul 8.1: Detectare Interblocare

ProblemÄƒ: DeseneazÄƒ graful de alocare È™i determinÄƒ dacÄƒ existÄƒ interblocare.

Procese: P1, P2, P3
Resurse: R1 (1 instanÈ›Äƒ), R2 (2 instanÈ›e), R3 (1 instanÈ›Äƒ)

Stare curentÄƒ:
- P1 deÈ›ine R1, cere R2
- P2 deÈ›ine o instanÈ›Äƒ R2, cere R3
- P3 deÈ›ine R3, cere R1

SoluÈ›ie:

```
Graful de alocare:

    P1 â—â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ R2 â–¡â–¡    (P1 cere R2)
       â”‚                â”‚
       â”‚                â”‚ (R2 alocatÄƒ lui P2)
       â”‚                â–¼
    R1 â–¡ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ P2 â—â”€â”€â”€â”€â†’ R3 â–¡   (P2 cere R3)
       â”‚                            â”‚
       â”‚ (R1 alocatÄƒ lui P1)        â”‚ (R3 alocatÄƒ lui P3)
       â”‚                            â–¼
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ P3 â— (P3 cere R1)
       
Ciclu: P1 â†’ R2 â†’ P2 â†’ R3 â†’ P3 â†’ R1 â†’ P1

CU O INSTANÈšÄ‚ PER RESURSÄ‚: DEADLOCK CONFIRMAT!

R2 are 2 instanÈ›e, dar una e ocupatÄƒ de P2 È™i cealaltÄƒ e liberÄƒ!
â†’ P1 poate primi R2!
â†’ P1 poate termina
â†’ ElibereazÄƒ R1
â†’ P3 poate primi R1
â†’ P3 poate termina
â†’ ... toÈ›i pot termina

REZULTAT: NU este deadlock (R2 are instanÈ›Äƒ liberÄƒ).
```

---

## ÃntrebÄƒri Tip Examen

8.1 (GrilÄƒ) Care condiÈ›ie Coffman poate fi eliminatÄƒ prin "ordonarea resurselor"?
- a) Mutual Exclusion
- b) Hold and Wait
- c) No Preemption
- d) Circular Wait âœ“

---

8.2 (7p) Pentru starea de mai jos, aplicÄƒ algoritmul Banker pentru a verifica dacÄƒ sistemul e Ã®n stare sigurÄƒ.

```
Procese: P0, P1, P2
Resurse: A=9, B=3
Allocation: P0=[2,0], P1=[1,1], P2=[2,1]
Maximum:    P0=[4,2], P1=[3,2], P2=[7,2]
```

RÄƒspuns:

```
1. CalculÄƒm Need = Max - Allocation:
   P0: [4,2] - [2,0] = [2,2]
   P1: [3,2] - [1,1] = [2,1]
   P2: [7,2] - [2,1] = [5,1]

2. CalculÄƒm Available:
   Total: [9,3]
   Alocat: [2+1+2, 0+1+1] = [5,2]
   Available = [9,3] - [5,2] = [4,1]

3. Safety Algorithm:
   Work = [4,1], Finish = [F, F, F]

   Pasul 1: CÄƒutÄƒm Need â‰¤ Work
   - P0: [2,2] â‰¤ [4,1]? NO (2>1 pentru B)
   - P1: [2,1] â‰¤ [4,1]? YES!
   â†’ P1 terminÄƒ, Work = [4,1] + [1,1] = [5,2]

   Pasul 2:
   - P0: [2,2] â‰¤ [5,2]? YES!
   â†’ P0 terminÄƒ, Work = [5,2] + [2,0] = [7,2]

   Pasul 3:
   - P2: [5,1] â‰¤ [7,2]? YES!
   â†’ P2 terminÄƒ

4. SecvenÈ›Äƒ sigurÄƒ: <P1, P0, P2>
   
   SISTEMUL ESTE ÃN STARE SIGURÄ‚! âœ“
```

---

*Continuare Ã®n fiÈ™ierul urmÄƒtor cu SÄƒptÄƒmÃ¢nile 9-14...*

---

*Materiale dezvoltate by Revolvix pentru ASE BucureÈ™ti - CSIE*

## ExerciÈ›ii avansate (Evaluare & Proiectare)

### E2.1: AnalizÄƒ de interblocare (Evaluare) â­â­â­â­
**Dificultate:** Expert | **Timp:** ~15 min | **Nivel cognitiv:** Evaluare

Un sistem de baze de date foloseÈ™te urmÄƒtorul protocol de blocare pentru tranzacÈ›ii:

```
TranzacÈ›ie T1:          TranzacÈ›ie T2:          TranzacÈ›ie T3:
lock(A)                  lock(B)                  lock(C)
lock(B)                  lock(C)                  lock(A)
// lucru                 // lucru                 // lucru
unlock(B)                unlock(C)                unlock(A)
unlock(A)                unlock(B)                unlock(C)
```

**SarcinÄƒ:** AnalizaÈ›i acest sistem din perspectiva potenÈ›ialului de interblocare:

a) DesenaÈ›i graful de alocare a resurselor dacÄƒ toate tranzacÈ›iile pornesc simultan
b) IdentificaÈ›i dacÄƒ poate apÄƒrea interblocare â€” dacÄƒ da, daÈ›i un interleaving specific
c) EvaluaÈ›i trei soluÈ›ii diferite È™i recomandaÈ›i-o pe cea mai bunÄƒ:
   - SoluÈ›ia 1: Ordonare globalÄƒ a lock-urilor (achiziÈ›ioneazÄƒ Ã®ntotdeauna A, B, C Ã®n ordine alfabeticÄƒ)
   - SoluÈ›ia 2: Timeout cu reÃ®ncercare (abandoneazÄƒ dupÄƒ 100ms, reÃ®ncearcÄƒ cu backoff exponenÈ›ial)
   - SoluÈ›ia 3: DetecÈ›ie deadlock cu selecÈ›ie victimÄƒ (abandoneazÄƒ tranzacÈ›ia cea mai tÃ¢nÄƒrÄƒ)

**RÄƒspuns model:**
```
a) Graf de Alocare a Resurselor (toate pornite simultan):
   
   T1 â”€â”€deÈ›ineâ”€â”€â–º A â—„â”€â”€aÈ™teaptÄƒâ”€â”€ T3
   â”‚                              â”‚
   aÈ™teaptÄƒ                       deÈ›ine
   â”‚                              â”‚
   â–¼                              â–¼
   B â—„â”€â”€deÈ›ineâ”€â”€ T2 â”€â”€aÈ™teaptÄƒâ”€â”€â–º C
   
   CICLU EXISTÄ‚: T1 â†’ B â†’ T2 â†’ C â†’ T3 â†’ A â†’ T1

b) Interleaving de interblocare:
   
   Timp    T1          T2          T3
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   t1      lock(A)âœ“
   t2                  lock(B)âœ“
   t3                              lock(C)âœ“
   t4      lock(B)â³               
   t5                  lock(C)â³
   t6                              lock(A)â³
   
   â†’ INTERBLOCARE: aÈ™teptare circularÄƒ stabilitÄƒ

c) Evaluarea soluÈ›iilor:

   SOLUÈšIA 1 - Ordonare GlobalÄƒ a Lock-urilor:
   + Previne complet interblocarea (rupe aÈ™teptarea circularÄƒ)
   + Zero overhead la runtime
   + Simplu de implementat
   - NecesitÄƒ refactorizare cod (T2, T3 trebuie sÄƒ se schimbe)
   - Poate reduce paralelismul (toÈ›i aÈ™teaptÄƒ A primii)
   
   SOLUÈšIA 2 - Timeout cu ReÃ®ncercare:
   + Nu necesitÄƒ modificÄƒri Ã®n ordinea lock-urilor
   + Auto-vindecÄƒtor
   - MuncÄƒ irositÄƒ (tranzacÈ›ii abandonate)
   - Risc de livelock cu timeout-uri identice
   - Dificil de reglat valoarea timeout-ului
   
   SOLUÈšIA 3 - DetecÈ›ie Deadlock:
   + Interblocarea abandoneazÄƒ doar cÃ¢nd e necesar
   + MuncÄƒ irositÄƒ minimÄƒ
   - Overhead de detecÈ›ie (detecÈ›ia ciclurilor Ã®n graf)
   - Complexitate de implementare
   - NecesitÄƒ politicÄƒ de selecÈ›ie a victimei

   RECOMANDARE: SoluÈ›ia 1 (Ordonare GlobalÄƒ a Lock-urilor)
   
   RaÈ›iune: Ãntr-o bazÄƒ de date cu resurse bine definite, ordonarea
   lock-urilor este standardul de aur. OferÄƒ garanÈ›ii la compilare cu
   zero cost la runtime. Efortul de refactorizare este o singurÄƒ datÄƒ,
   Ã®n timp ce SoluÈ›iile 2 È™i 3 au costuri continue de performanÈ›Äƒ È™i complexitate.
```

---

### E2.2: Proiectare de sincronizare (Proiectare) â­â­â­â­
**Dificultate:** Expert | **Timp:** ~20 min | **Nivel cognitiv:** Proiectare

**Scenariu:** ProiectaÈ›i un buffer mÄƒrginit thread-safe pentru un sistem de tranzacÈ›ionare de Ã®naltÄƒ frecvenÈ›Äƒ cu aceste cerinÈ›e:

| CerinÈ›Äƒ | SpecificaÈ›ie |
|---------|--------------|
| Dimensiune buffer | 1024 mesaje |
| ProducÄƒtori | Multipli (pÃ¢nÄƒ la 16 fluxuri de date de piaÈ›Äƒ) |
| Consumatori | Multipli (pÃ¢nÄƒ la 8 algoritmi de tranzacÈ›ionare) |
| ÈšintÄƒ latenÈ›Äƒ | < 1 microsecundÄƒ pentru enqueue/dequeue |
| Ordonare | FIFO Ã®n cadrul fiecÄƒrui producÄƒtor |
| PoliticÄƒ overflow | AruncÄƒ cel mai vechi mesaj (nu bloca niciodatÄƒ producÄƒtorul) |

**SarcinÄƒ:** ProiectaÈ›i soluÈ›ia de sincronizare:

a) AlegeÈ›i primitivele de sincronizare potrivite (justificaÈ›i alegerea)
b) FurnizaÈ›i pseudocod pentru operaÈ›iile enqueue() È™i dequeue()
c) ExplicaÈ›i cum designul vostru Ã®ndeplineÈ™te cerinÈ›a de latenÈ›Äƒ
d) DiscutaÈ›i compromisurile pe care le-aÈ›i fÄƒcut

**RÄƒspuns model:**
```
a) Primitive de sincronizare:

   ALES: Buffer circular lock-free cu operaÈ›ii atomice
   
   NU mutex/semafor deoarece:
   - Mutex: ~25ns cel mai bun caz, pÃ¢nÄƒ la 1Î¼s cu contention
   - Semafor: Overhead similar plus implicare kernel
   - Niciunul nu Ã®ndeplineÈ™te È›inta <1Î¼s sub contention ridicat
   
   Structuri de date:
   - Array circular: Message buffer[1024]
   - Head atomic: poziÈ›ia pentru urmÄƒtoarea scriere
   - Tail atomic: poziÈ›ia pentru urmÄƒtoarea citire  
   - Numere de secvenÈ›Äƒ per slot pentru prevenirea ABA

b) Pseudocod:

   struct Slot {
       atomic<uint64_t> sequence;
       Message data;
   };
   
   Slot buffer[1024];
   atomic<uint64_t> head = 0;
   atomic<uint64_t> tail = 0;
   
   bool enqueue(Message msg) {
       uint64_t pos = head.fetch_add(1, relaxed);
       uint64_t index = pos & 1023;  // Modulo rapid pentru putere de 2
       Slot* slot = &buffer[index];
       
       // AÈ™teaptÄƒ ca slotul sÄƒ fie consumat (sau suprascrie dacÄƒ overflow)
       uint64_t expected_seq = pos;
       while (slot->sequence.load(acquire) != expected_seq) {
           if (pos - tail.load(relaxed) >= 1024) {
               // Overflow: cel mai vechi mesaj va fi aruncat
               break;
           }
           _mm_pause();  // Hint CPU pentru spin-wait
       }
       
       slot->data = msg;
       slot->sequence.store(pos + 1, release);
       return true;
   }
   
   bool dequeue(Message* msg) {
       uint64_t pos = tail.load(relaxed);
       Slot* slot = &buffer[pos & 1023];
       uint64_t seq = slot->sequence.load(acquire);
       
       if (seq != pos + 1) {
           return false;  // Buffer gol
       }
       
       if (tail.compare_exchange_weak(pos, pos + 1, relaxed)) {
           *msg = slot->data;
           slot->sequence.store(pos + 1024, release);
           return true;
       }
       return false;  // Contention, reÃ®ncearcÄƒ
   }

c) AnalizÄƒ de latenÈ›Äƒ:

   - FÄƒrÄƒ apeluri de sistem (pur user-space)
   - FÄƒrÄƒ comutÄƒri de context (lock-free)
   - Optimizat pentru cache-line (aliniere la 64 bytes per slot)
   - fetch_add: ~10-20 cicluri pe x86 modern
   - Bariere de memorie: ~20-40 cicluri
   - Total: ~100-200 cicluri â‰ˆ 30-60 nanosecunde
   
   Aceasta este cu mult sub cerinÈ›a de 1Î¼s chiar È™i cu contention moderat.

d) Compromisuri:

   ACCEPTATE:
   - Pierdere mesaje la overflow (acceptabil conform cerinÈ›elor)
   - Utilizare mai mare a memoriei (padding pentru aliniere cache)
   - Cod mai complex (mai greu de menÈ›inut)
   
   ALTERNATIVE RESPINSE:
   - CoadÄƒ blocantÄƒ: Prea lent
   - Optimizare single-producer: Avem nevoie de producÄƒtori multipli
   - Buffer nemÄƒrginit: Risc de epuizare a memoriei
```

---

*Materiale dezvoltate de Revolvix pentru ASE BucureÈ™ti â€” CSIE*
