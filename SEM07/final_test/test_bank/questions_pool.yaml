# ═══════════════════════════════════════════════════════════════════════════════
# POOL CONSOLIDAT DE ÎNTREBĂRI — bancă pentru testul final
# ═══════════════════════════════════════════════════════════════════════════════
# Operating Systems | ASE Bucharest — CSIE
# Version: 2.0 | Date: January 2025
# Author: ing. dr. Antonio Clim
# 
# Sources integrated:
#   - SEM01-06 formative quizzes
#   - Lecture 02-18 formative assessments
#   - Original SEM07 test bank questions
#
# Total întrebări: 296
# Bloom Taxonomy Distribution: Remember 15%, Understand 30%, Apply 30%, 
#                               Analyse 15%, Evaluate 7%, Create 3%
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  version: "2.0"
  course: "Sisteme de Operare"
  semester: "2024-2025"
  institution: "ASE Bucharest - CSIE"
  total_questions: 296
  language: "ro-RO"
  
  statistics:
    by_difficulty:
      easy: 69
      medium: 153
      hard: 74
    by_type:
      multiple_choice: 260
      short_answer: 26
      practical: 10
    by_bloom:
      remember: 63
      understand: 108
      apply: 71
      analyse: 44
      evaluate: 6
      create: 4

# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 1: SHELL FUNDAMENTALS
# Sources: SEM01, Lectures 1-2
# ═══════════════════════════════════════════════════════════════════════════════

categories:

  - name: "Fundamente de shell"
    lectures: [1, 2]
    seminars: [1]
    question_count: 24
    
    questions:
      # --- Întrebări SEM07 originale ---
      - id: SF01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        question: "Ce comandă afișează directorul de lucru curent?"
        options:
          a: "cd"
          b: "pwd"
          c: "ls"
          d: "dir"
        answer: "b"
        points: 0.5
        
      - id: SF02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        question: "Ce afișează comanda 'ls -la'?"
        options:
          a: "Doar fișierele ascunse"
          b: "Doar directoarele"
          c: "Toate fișierele inclusiv cele ascunse, în format lung"
          d: "Doar fișierele obișnuite"
        answer: "c"
        points: 0.5
        
      - id: SF03
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Scrieți o comandă pentru a crea structura de directoare 'project/src/main' într-o singură comandă."
        answer: "mkdir -p project/src/main"
        accept_alternatives:
          - "mkdir --parents project/src/main"
        points: 1.0
        
      - id: SF04
        type: short_answer
        difficulty: medium
        bloom: understand
        question: "Care este diferența între 'export VAR=valoare' și 'VAR=valoare'?"
        answer: "export face variabila disponibilă proceselor copil, fără export este disponibilă doar în shell-ul curent"
        keywords: ["copil", "proces", "subshell", "mediu"]
        points: 1.0

      # --- From SEM01 Quiz ---
      - id: SF05
        type: multiple_choice
        difficulty: easy
        bloom: understand
        source: "SEM01-q03"
        question: "Care este diferența între un shell și un terminal?"
        options:
          a: "Sunt același lucru"
          b: "Shell-ul interpretează comenzi; terminalul este interfața pentru a accesa shell-ul"
          c: "Terminalul interpretează comenzi; shell-ul le afișează"
          d: "Shell-ul este hardware; terminalul este software"
        answer: "b"
        explanation: "Terminal = interfață (fereastră, tastatură, afișaj). Shell = interpreter (Bash, Zsh)."
        points: 0.5

      - id: SF06
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM01-q05"
        question: "Definiți VAR=secret fără export. Ce se întâmplă într-un subshell?"
        options:
          a: "Variabila este accesibilă cu valoarea 'secret'"
          b: "Variabila este nedefinită"
          c: "Variabila are valoarea 'VAR'"
          d: "Eroare: variabila nu a fost exportată"
        answer: "b"
        explanation: "Fără export, variabila nu face parte din mediul moștenit de procesele copil."
        points: 0.5

      - id: SF07
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM01-q01"
        question: "Ce face comanda pwd?"
        options:
          a: "Schimbă directorul curent"
          b: "Afișează directorul de lucru curent"
          c: "Creează un director nou"
          d: "Listează conținutul directorului"
        answer: "b"
        explanation: "pwd = Print Working Directory, afișează calea absolută a locației curente."
        points: 0.5

      - id: SF08
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM01-q06"
        question: "Ce comandă creează directoare imbricate /home/user/projects/new/src într-un singur pas?"
        options:
          a: "mkdir /home/user/projects/new/src"
          b: "mkdir -p /home/user/projects/new/src"
          c: "mkdir -r /home/user/projects/new/src"
          d: "mkdirs /home/user/projects/new/src"
        answer: "b"
        explanation: "-p (parents) creează directoare intermediare dacă acestea nu există."
        points: 0.5

      - id: SF09
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM01-q07"
        question: "Ce face 'source script.sh' comparativ cu './script.sh'?"
        options:
          a: "Sunt identice"
          b: "source rulează în shell-ul curent; ./script.sh rulează într-un subshell"
          c: "source este mai rapid"
          d: "source necesită permisiune de execuție"
        answer: "b"
        explanation: "source (sau .) execută în shell-ul curent, astfel variabilele și modificările persistă."
        points: 0.5

      - id: SF10
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM01-q08"
        question: "Care expansiune de acolade creează fișierele file1.txt, file2.txt, file3.txt?"
        options:
          a: "touch file[1-3].txt"
          b: "touch file{1..3}.txt"
          c: "touch file(1,2,3).txt"
          d: "touch file<1-3>.txt"
        answer: "b"
        explanation: "{1..3} este expansiune de acolade care generează secvența 1, 2, 3."
        points: 0.5

      - id: SF11
        type: multiple_choice
        difficulty: medium
        bloom: analyse
        source: "SEM01-q09"
        question: "Care este output-ul la: VAR='$HOME'; echo $VAR?"
        options:
          a: "/home/user (directorul home)"
          b: "$HOME (string literal)"
          c: "Eroare: sintaxă invalidă"
          d: "String gol"
        answer: "b"
        explanation: "Ghilimelele simple împiedică expansiunea variabilelor; $HOME rămâne literal."
        points: 0.5

      - id: SF12
        type: multiple_choice
        difficulty: easy
        bloom: understand
        source: "SEM01-q10"
        question: "Ce indică codul de ieșire 0?"
        options:
          a: "Eroare"
          b: "Succes"
          c: "Avertisment"
          d: "Întrerupt"
        answer: "b"
        explanation: "Convenția Unix: 0 = succes, diferit de zero = eroare."
        points: 0.5

      - id: SF13
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM01-q11"
        question: "Care pattern se potrivește cu toate fișierele .txt din directorul curent?"
        options:
          a: "[*.txt]"
          b: "*.txt"
          c: "?.txt"
          d: "{.txt}"
        answer: "b"
        explanation: "* este un glob care se potrivește cu orice caractere; *.txt se potrivește cu toate fișierele .txt."
        points: 0.5

      - id: SF14
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM01-q12"
        question: "De ce este 'rm -rf $DIR' periculos dacă DIR nu este setat sau este gol?"
        options:
          a: "Nu face nimic"
          b: "Poate șterge fișiere din directorul curent sau chiar din /"
          c: "Afișează o eroare"
          d: "Șterge doar directoare goale"
        answer: "b"
        explanation: "Dacă DIR este gol, 'rm -rf' ar putea acționa asupra directorului curent sau, cu anumite shell-uri, asupra /."
        points: 0.75

      - id: SF15
        type: multiple_choice
        difficulty: hard
        bloom: evaluate
        source: "SEM01-q13"
        question: |
          Analizați acest script de backup:
          #!/bin/bash
          backup_dir=$1
          if [ -z $backup_dir ]; then
            echo "Usage: $0 <dir>"
            exit 1
          fi
          tar czf backup.tar.gz $backup_dir
          echo "Backup created"
          Identificați 2 vulnerabilități de securitate.
        options:
          a: "Script-ul este prea lent"
          b: "Variabila necitată $backup_dir poate cauza probleme cu spații sau nume malițioase"
          c: "tar nu suportă gzip"
          d: "Nu există problemă de securitate"
        answer: "b"
        explanation: "Fără ghilimele, un nume de fișier cu spații sau caractere speciale cauzează comportament neașteptat."
        points: 0.75

      - id: SF16
        type: short_answer
        difficulty: hard
        bloom: create
        source: "SEM01-q14"
        question: "Creați un alias 'backup' care creează o arhivă tar.gz cu timestamp a directorului curent."
        answer: "alias backup='tar czf backup_$(date +%Y%m%d_%H%M%S).tar.gz .'"
        accept_alternatives:
          - "alias backup='tar -czf $(date +%F).tar.gz .'"
        keywords: ["alias", "tar", "date", "czf"]
        points: 1.5

      - id: SF17
        type: multiple_choice
        difficulty: easy
        bloom: remember
        question: "Conform Standardului de Ierarhie a Sistemului de Fișiere, unde sunt plasate de obicei programele instalate de utilizator?"
        options:
          a: "/bin"
          b: "/usr/local/bin"
          c: "/etc"
          d: "/var"
        answer: "b"
        explanation: "/usr/local este pentru software instalat local, separat de pachetele de sistem."
        points: 0.5

      - id: SF18
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Care este diferența între /bin și /usr/bin?"
        options:
          a: "Sunt identice"
          b: "/bin contains essential system binaries; /usr/bin contains user applications"
          c: "/usr/bin is for root only"
          d: "/bin is deprecated"
        answer: "b"
        explanation: "Istoric, /bin pentru esențiale de boot, /usr/bin pentru programe generale (acum adesea unite)."
        points: 0.5

      - id: SF19
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Scrieți o comandă pentru a găsi tipul și locația comenzii 'python3'."
        answer: "type python3"
        accept_alternatives:
          - "which python3"
          - "whereis python3"
          - "command -v python3"
        points: 1.0

      - id: SF20
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce face linia shebang '#!/usr/bin/env bash'?"
        options:
          a: "Setează o variabilă de mediu"
          b: "Specifică interpretorul folosind PATH pentru a găsi bash"
          c: "Comentează prima linie"
          d: "Activează depanarea"
        answer: "b"
        explanation: "Folosirea env face script-ul mai portabil pe sisteme cu bash în locații diferite."
        points: 0.5

      - id: SF21
        type: multiple_choice
        difficulty: medium
        bloom: apply
        question: "Cum faceți un script executabil?"
        options:
          a: "touch script.sh"
          b: "chmod +x script.sh"
          c: "chown script.sh"
          d: "exec script.sh"
        answer: "b"
        explanation: "chmod +x adaugă permisiune de execuție fișierului."
        points: 0.5

      - id: SF22
        type: short_answer
        difficulty: hard
        bloom: analyse
        question: "Explicați de ce 'echo $var' ar putea produce output diferit față de 'echo \"$var\"' când var conține spații."
        answer: "Without quotes, word splitting occurs and multiple spaces collapse to one; with quotes, the exact value is preserved"
        keywords: ["word splitting", "quotes", "spaces", "preserve"]
        points: 1.0

      - id: SF23
        type: multiple_choice
        difficulty: easy
        bloom: remember
        question: "Care file is typically executed when starting an interactive Bash login shell?"
        options:
          a: ".bashrc"
          b: ".bash_profile"
          c: ".bash_history"
          d: ".bash_logout"
        answer: "b"
        explanation: "Login shells read .bash_profile (or .profile); interactive non-login shells read .bashrc."
        points: 0.5

      - id: SF24
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este the purpose of the PATH environment variable?"
        options:
          a: "Stores the directorul curent"
          b: "Lists directories where shell searches for executables"
          c: "Contains the home directory path"
          d: "Defines file permissions"
        answer: "b"
        explanation: "PATH is a colon-separated list lui directories searched when running commands."
        points: 0.5


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 2: CONTROL OPERATORS AND REDIRECTION
# Sources: SEM02, Lectures 2-3
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Operatori de control și redirecționare"
    lectures: [2, 3]
    seminars: [2]
    question_count: 26
    
    questions:
      # --- Întrebări SEM07 originale ---
      - id: CR01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        question: "Ce face '&&' în Bash?"
        options:
          a: "Rulează ambele comenzi simultan"
          b: "Rulează a doua comandă doar dacă prima reușește"
          c: "Rulează a doua comandă doar dacă prima eșuează"
          d: "Combină output-ul ambelor comenzi"
        answer: "b"
        points: 0.5
        
      - id: CR02
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce face 'command 2>&1'?"
        options:
          a: "Redirects stdout to stderr"
          b: "Redirects stderr to stdout"
          c: "Discards stderr"
          d: "Duplicates comanda"
        answer: "b"
        points: 0.5
        
      - id: CR03
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Write a comandă care saves both stdout and stderr to 'output.log'."
        answer: "command > output.log 2>&1"
        accept_alternatives:
          - "command &> output.log"
          - "command >& output.log"
        points: 1.0
        
      - id: CR04
        type: practical
        difficulty: hard
        bloom: apply
        question: "Write a one-liner care: 1) Pings google.com once, 2) dacă successful prints 'Online', 3) dacă failed prints 'Offline'."
        answer: "ping -c1 google.com &>/dev/null && echo 'Online' || echo 'Offline'"
        points: 1.5

      # --- From SEM02 Quiz ---
      - id: CR05
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM02-q01"
        question: "Ce face operatorul && în 'cmd1 && cmd2'?"
        options:
          a: "Rulează cmd2 indiferent de rezultatul cmd1"
          b: "Rulează cmd2 în fundal"
          c: "Rulează cmd2 doar dacă cmd1 reușește (cod de ieșire 0)"
          d: "Rulează cmd2 doar dacă cmd1 eșuează"
        answer: "c"
        explanation: "&& is logical AND - second command runs only on success."
        points: 0.5

      - id: CR06
        type: multiple_choice
        difficulty: easy
        bloom: understand
        source: "SEM02-q02"
        question: "Ce face semnul & singular în 'command &'?"
        options:
          a: "AND logic"
          b: "Rulează comanda în fundal"
          c: "Redirecționează stderr"
          d: "Așteaptă comanda"
        answer: "b"
        explanation: "& at the end backgrounds the process, returning control immediately."
        points: 0.5

      - id: CR07
        type: multiple_choice
        difficulty: medium
        bloom: analyse
        source: "SEM02-q03"
        question: "Care este output-ul la: mkdir test && echo 'created' || echo 'failed' (dacă test already exists)?"
        options:
          a: "'created'"
          b: "'failed'"
          c: "'created' then 'failed'"
          d: "No output"
        answer: "b"
        explanation: "mkdir fails (test exists), so && is skipped and || executes."
        points: 0.5

      - id: CR08
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM02-q04"
        question: "În 'false | true', care este valoarea lui $?"
        options:
          a: "1 (from false)"
          b: "0 (from true)"
          c: "Undefined"
          d: "Eroare"
        answer: "b"
        explanation: "Without pipefail, $? reflects only the last command's codul de ieșire."
        points: 0.75

      - id: CR09
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM02-q05"
        question: "Care este diferența între { } și ( ) for command grouping?"
        options:
          a: "Sunt identice"
          b: "{ } runs in the current shell; ( ) runs in a subshell"
          c: "( ) is faster"
          d: "{ } requires spaces; ( ) doesn't"
        answer: "b"
        explanation: "{ } executes in current context (variables persist); ( ) creates subshell."
        points: 0.5

      - id: CR10
        type: multiple_choice
        difficulty: easy
        bloom: understand
        source: "SEM02-q06"
        question: "Care este diferența între > și >> in redirection?"
        options:
          a: "> is faster"
          b: "> overwrites; >> appends"
          c: ">> overwrites; > appends"
          d: "Sunt identice"
        answer: "b"
        explanation: "> truncates and writes; >> adds to the end of the file."
        points: 0.5

      - id: CR11
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM02-q07"
        question: "Care este diferența între 'cmd > file 2>&1' și 'cmd 2>&1 > file'?"
        options:
          a: "Sunt identice"
          b: "First: both stdout and stderr to file. Second: stderr to original stdout, stdout to file"
          c: "First is invalid syntax"
          d: "Second is invalid syntax"
        answer: "b"
        explanation: "Redirection order matters. In the second, 2>&1 copies stdout before it's redirected."
        points: 0.75

      - id: CR12
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM02-q08"
        question: "Ce face 'command 2>/dev/null'?"
        options:
          a: "Discards all output"
          b: "Discards only stderr, preserving codul de ieșire"
          c: "Saves stderr to a file"
          d: "Converts stderr to stdout"
        answer: "b"
        explanation: "2>/dev/null suppresses error messages but codul de ieșire is unchanged."
        points: 0.5

      - id: CR13
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM02-q09"
        question: "Ce face '&>' în Bash?"
        options:
          a: "Rulează comanda în fundal"
          b: "Redirecționează atât stdout cât și stderr către un fișier"
          c: "AND logic apoi redirecționare"
          d: "Invalid syntax"
        answer: "b"
        explanation: "&> is shorthand for > file 2>&1, redirecting both streams."
        points: 0.5

      - id: CR14
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM02-q10"
        question: "Ce face the tee command?"
        options:
          a: "Combines two files"
          b: "Reads stdin and writes to both stdout and a file"
          c: "Compresses data"
          d: "Splits a file"
        answer: "b"
        explanation: "tee duplicates input to stdout and file(s), useful for logging while displaying."
        points: 0.5

      - id: CR15
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM02-q11"
        question: "Care option in sort selects the sorting key by field?"
        options:
          a: "-n"
          b: "-k"
          c: "-r"
          d: "-u"
        answer: "b"
        explanation: "-k specifies field for sorting, e.g., sort -k2 sorts by second field."
        points: 0.5

      - id: CR16
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM02-q12"
        question: "De ce must input be sorted before using uniq?"
        options:
          a: "uniq is faster on sorted input"
          b: "uniq only removes adjacent duplicates"
          c: "uniq requires sorted input"
          d: "uniq sorts automatically"
        answer: "b"
        explanation: "uniq compares consecutive lines; non-adjacent duplicates aren't removed."
        points: 0.5

      - id: CR17
        type: multiple_choice
        difficulty: easy
        bloom: apply
        source: "SEM02-q14"
        question: "Care command translates all lowercase letters to uppercase?"
        options:
          a: "sed 's/a-z/A-Z/'"
          b: "tr 'a-z' 'A-Z'"
          c: "cut -u"
          d: "awk '{upper}'"
        answer: "b"
        explanation: "tr translates character sets; a-z to A-Z converts case."
        points: 0.5

      - id: CR18
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM02-q15"
        question: "Care command counts lines in a file?"
        options:
          a: "count file"
          b: "wc -l file"
          c: "lines file"
          d: "cat -n file"
        answer: "b"
        explanation: "wc -l counts lines; -w counts words; -c counts bytes."
        points: 0.5

      - id: CR19
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM02-q16"
        question: "Ce este the syntax for a for loop în Bash?"
        options:
          a: "for (i=0; i<10; i++)"
          b: "for i in {1..10}; do ... done"
          c: "foreach i in 1..10"
          d: "for i = 1 to 10"
        answer: "b"
        explanation: "Bash uses 'for var in list; do commands; done' syntax."
        points: 0.5

      - id: CR20
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM02-q17"
        question: "Care este diferența între 'break' și 'exit' in a loop?"
        options:
          a: "Sunt identice"
          b: "break exits the loop; exit terminates the script"
          c: "exit exits the loop; break terminates the script"
          d: "Both terminate the script"
        answer: "b"
        explanation: "break continues after the loop; exit ends the entire script/shell."
        points: 0.5

      - id: CR21
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM02-q18"
        question: "Care syntax correctly iterates over .txt files din directorul curent?"
        options:
          a: "for f in ls *.txt; do"
          b: "for f in *.txt; do"
          c: "for f in (*.txt); do"
          d: "for f = *.txt; do"
        answer: "b"
        explanation: "The glob *.txt expands to the list of files; no need for ls."
        points: 0.5

      - id: CR22
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM02-q19"
        question: "Care syntax correctly reads a file line by line?"
        options:
          a: "for line in file.txt; do"
          b: "while read line; do ... done < file.txt"
          c: "cat file.txt | for line; do"
          d: "read file.txt into line"
        answer: "b"
        explanation: "while read with redirection properly handles lines with spaces."
        points: 0.5

      - id: CR23
        type: practical
        difficulty: hard
        bloom: analyse
        source: "SEM02-q21"
        question: |
          Explicați ce face acest pipeline:
          grep 'ERROR' app.log | cut -d':' -f2 | sort | uniq -c | sort -rn | head -5
        answer: "Finds ERROR lines, extracts field 2 (colon-delimited), sorts, counts unique occurrences, sorts by count descending, shows top 5"
        keywords: ["grep", "cut", "sort", "uniq", "count", "top"]
        points: 1.5

      - id: CR24
        type: multiple_choice
        difficulty: medium
        bloom: evaluate
        source: "SEM02-q22"
        question: "De ce is 'cat file | grep pattern' considered bad practice?"
        options:
          a: "It doesn't work"
          b: "It's a Useless Use lui Cat (UUOC); grep can read file directly"
          c: "cat is slower"
          d: "grep doesn't support pipes"
        answer: "b"
        explanation: "UUOC: unnecessary process. Use 'grep pattern file' directly."
        points: 0.5

      - id: CR25
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM02-q23"
        question: "Ce face nohup pentru o comandă?"
        options:
          a: "Crește prioritatea"
          b: "Face comanda imună la SIGHUP (continuă după delogare)"
          c: "Rulează comanda mai rapid"
          d: "Reduce utilizarea memoriei"
        answer: "b"
        explanation: "nohup prevents SIGHUP from terminating process when terminal closes."
        points: 0.5

      - id: CR26
        type: multiple_choice
        difficulty: hard
        bloom: evaluate
        source: "SEM02-q26"
        question: |
          Evaluați acest cod generat de un LLM pentru procesarea input‑ului utilizatorului:
          files=$(ls $input_dir)
          for f in $files; do rm $f; done
          Care este problema majoră?
        options:
          a: "ls is unnecessary"
          b: "Unquoted variables can cause word splitting and glob expansion issues"
          c: "rm doesn't work in loops"
          d: "Missing shebang"
        answer: "b"
        explanation: "Filenames cu spaces or special characters will break. Use quotes and glob directly."
        points: 0.75


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 3: TEXT PROCESSING
# Sources: SEM04, Lectures 4-5
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Procesare de text"
    lectures: [4, 5]
    seminars: [4]
    question_count: 22
    
    questions:
      - id: TP01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM04-R1"
        question: "Care regex metacharacter se potrivește cu ANY single character (except newline)?"
        options:
          a: "."
          b: "*"
          c: "?"
          d: "+"
        answer: "a"
        explanation: "dot (.) se potrivește exactly one character. * = zero or more;? = zero or one; + = one or more."
        points: 0.5

      - id: TP02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM04-R2"
        question: "Care grep option displays ONLY the text that matched, not the entire line?"
        options:
          a: "-o"
          b: "-v"
          c: "-c"
          d: "-l"
        answer: "a"
        explanation: "-o (only-matching) displays only the matched portion."
        points: 0.5

      - id: TP03
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM04-R3"
        question: "În sed, care comandă șterge liniile care se potrivește a pattern-ul?"
        options:
          a: "d"
          b: "p"
          c: "s"
          d: "q"
        answer: "a"
        explanation: "d = delete, p = print, s = substitute, q = quit."
        points: 0.5

      - id: TP04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM04-U1"
        question: "Ce este the MAIN difference between BRE and ERE in grep?"
        options:
          a: "In BRE, metacharacters +, ?, {}, (), | require escaping with backslash"
          b: "BRE is faster than ERE"
          c: "ERE face not support grouping cu parentheses"
          d: "BRE works only on Linux, ERE on all systems"
        answer: "a"
        explanation: "In BRE, + ? {} () | are literal; must escape them. In ERE (-E), they're metacharacters."
        points: 0.5

      - id: TP05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM04-U2"
        question: "Cu ce se potrivește regex pattern-ul `^[^#]`?"
        options:
          a: "Lines that do NOT start with #"
          b: "Lines that start with #"
          c: "The character ^ followed by #"
          d: "Any line that contains #"
        answer: "a"
        explanation: "First ^ = start anchor; [^#] = any character except #."
        points: 0.5

      - id: TP06
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM04-U3"
        question: "Ce va afișa 'echo -e \"abc\\nABC\\nabC\" | grep -i 'abc''?"
        options:
          a: "abc, ABC, abC (all three lines)"
          b: "only abc"
          c: "abc and ABC"
          d: "Error: invalid pattern-ul"
        answer: "a"
        explanation: "-i makes the search case-insensitive."
        points: 0.5

      - id: TP07
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM04-U4"
        question: "Ce va afișa 'echo \"hello world\" | sed 's/o/O/__SQ1__?"
        options:
          a: "hellO world"
          b: "hellO wOrld"
          c: "HELLO WORLD"
          d: "hello world"
        answer: "a"
        explanation: "Without the 'g' flag, sed replaces only the FIRST occurrence."
        points: 0.5

      - id: TP08
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM04-U5"
        question: "Ce va afișa 'echo \"ana:are:mere\" | awk -F: '{print $2}''?"
        options:
          a: "are"
          b: "ana"
          c: "mere"
          d: "ana:are:mere"
        answer: "a"
        explanation: "-F: sets delimiter to ':'; $2 is the second field."
        points: 0.5

      - id: TP09
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM04-A1"
        question: "Care command extracts ALL IP addresses from log.txt?"
        options:
          a: "grep -oE '([0-9]{1,3}\\.){3}[0-9]{1,3}' log.txt"
          b: "grep -o '[0-9]*' log.txt"
          c: "grep 'IP' log.txt"
          d: "grep -E '[0-9].[0-9].[0-9].[0-9]' log.txt"
        answer: "a"
        explanation: "pattern-ul se potrivește 1-3 digits, escaped dot, repeated 3 times, plus final octet."
        points: 0.5

      - id: TP10
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM04-A2"
        question: "Care sed command deletes all blank lines from a file?"
        options:
          a: "sed '/^$/d' file.txt"
          b: "sed 's/^$//' file.txt"
          c: "sed '/./d' file.txt"
          d: "sed 'd' file.txt"
        answer: "a"
        explanation: "^$ se potrivește empty line (start followed by end); d șterge it."
        points: 0.5

      - id: TP11
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM04-A3"
        question: "Care awk command calculates the sum of values in column 3 of a CSV?"
        options:
          a: "awk -F, '{sum+=$3} END {print sum}' data.csv"
          b: "awk '{print $3}' data.csv | sum"
          c: "awk -F, 'BEGIN {print $3}' data.csv"
          d: "awk '{sum=$3} END {print sum}' data.csv"
        answer: "a"
        explanation: "sum+=$3 accumulates; END block prints total after all lines."
        points: 0.5

      - id: TP12
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM04-A4"
        question: "Care pipeline counts unique lines containing 'ERROR' in all .log files?"
        options:
          a: "grep -h 'ERROR' *.log | sort | uniq | wc -l"
          b: "grep 'ERROR' *.log | wc -l"
          c: "grep -c 'ERROR' *.log"
          d: "grep 'ERROR' *.log | uniq | wc -l"
        answer: "a"
        explanation: "-h suppresses filenames; sort before uniq; wc -l counts lines."
        points: 0.5

      - id: TP13
        type: short_answer
        difficulty: medium
        bloom: apply
        source: "SEM04-A5"
        question: "Complete the sed command that replaces ALL occurrences of 'foo' with 'bar': sed 's/foo/bar/___' file.txt"
        answer: "g"
        keywords: ["g", "global"]
        points: 0.5

      - id: TP14
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM04-AN1"
        question: |
          Un coleg a scris: grep 'error|warning' server.log
          Comanda nu găsește nimic, deși fișierul conține 'error' și 'warning'. De ce?
        options:
          a: "Missing -E; in BRE, | is literal, not alternation"
          b: "pattern-ul should be 'error\\|warning'"
          c: "Both options A and B are correct"
          d: "Must use -i for case-insensitive"
        answer: "c"
        explanation: "In BRE, | is literal. Fix with -E or escape: \\|"
        points: 0.75

      - id: TP15
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM04-AN2"
        question: "Care approach is MORE EFFICIENT for extracting column 2 from a 1GB CSV?"
        options:
          a: "awk -F, '{print $2}' large.csv"
          b: "cat large.csv | cut -d, -f2"
          c: "sed 's/[^,]*,\\([^,]*\\).*/\\1/' large.csv"
          d: "All are equally efficient"
        answer: "a"
        explanation: "awk parses once, no extra processes. cat|cut = UUOC; sed regex is slower."
        points: 0.75

      - id: TP16
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Write an awk comandă to print liniile where third field is greater than 100."
        answer: "awk '$3 > 100' file.txt"
        accept_alternatives:
          - "awk '{if ($3 > 100) print}' file.txt"
        points: 1.0

      - id: TP17
        type: short_answer
        difficulty: hard
        bloom: apply
        question: "Write a sed comandă to swap first and second words on each line."
        answer: "sed 's/^\\([^ ]*\\) \\([^ ]*\\)/\\2 \\1/'"
        accept_alternatives:
          - "sed -E 's/^([^ ]+) ([^ ]+)/\\2 \\1/'"
        points: 1.5

      - id: TP18
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Cu ce se potrivesc ancorele regex \\b?"
        options:
          a: "Beginning of line"
          b: "Word boundary"
          c: "Backspace character"
          d: "End of line"
        answer: "b"
        explanation: "\\b se potrivește position between word and non-word character."
        points: 0.5

      - id: TP19
        type: multiple_choice
        difficulty: medium
        bloom: apply
        question: "Care grep command finds whole words only?"
        options:
          a: "grep -w 'word' file"
          b: "grep -o 'word' file"
          c: "grep -x 'word' file"
          d: "grep -e 'word' file"
        answer: "a"
        explanation: "-w se potrivește whole words only (word boundaries on both sides)."
        points: 0.5

      - id: TP20
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "În awk, ce reprezintă NF?"
        options:
          a: "Number of files"
          b: "Number of fields in current record"
          c: "Number of formatted outputs"
          d: "Next field"
        answer: "b"
        explanation: "NF = Number of Fields. NR = Number of Records (line number)."
        points: 0.5

      - id: TP21
        type: practical
        difficulty: hard
        bloom: create
        question: "Write an awk script to calculate average lui column 2 for a CSV file."
        answer: "awk -F, '{sum+=$2; count++} END {print sum/count}' file.csv"
        points: 1.5

      - id: TP22
        type: multiple_choice
        difficulty: medium
        bloom: apply
        question: "Care option makes grep search recursively in directories?"
        options:
          a: "-r"
          b: "-R"
          c: "Both -r and -R work"
          d: "-d"
        answer: "c"
        explanation: "Both -r and -R enable recursive search; -R follows symlinks."
        points: 0.5


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 4: BASH SCRIPTING
# Sources: SEM05, SEM06, Lectures 7-9
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Scripting Bash"
    lectures: [7, 8, 9]
    seminars: [5, 6]
    question_count: 30
    
    questions:
      - id: BS01
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM05-q01"
        question: |
          Ce afișează acest script?
          count=10
          increment() { count=$((count + 1)); echo "In function: $count"; }
          increment
          echo "After function: $count"
        options:
          a: "After function: 10"
          b: "After function: 11"
          c: "After function: (empty)"
          d: "Error - count is not defined in main"
        answer: "b"
        explanation: "în Bash, variables in functions are GLOBAL by default (unlike Python/Java/C)."
        points: 0.5

      - id: BS02
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM05-q02"
        question: |
          Ce afișează acest script?
          get_value() { return 42; }
          result=$(get_value)
          echo "Result: '$result'"
        options:
          a: "Result: '42'"
          b: "Result: '' (empty string)"
          c: "Result: '0'"
          d: "Syntax error"
        answer: "b"
        explanation: "return sets codul de ieșire (0-255), not output. $() captures stdout, not codul de ieșire."
        points: 0.5

      - id: BS03
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM05-q03"
        question: |
          Scriptul test.sh: show_arg() { echo "$1"; }; echo "$1"; show_arg "FUNC"
          Rulare: ./test.sh SCRIPT
          Ce afișează funcția?
        options:
          a: "SCRIPT"
          b: "FUNC"
          c: "(empty)"
          d: "$1"
        answer: "b"
        explanation: "$1 in function refers to function argument, not script argument."
        points: 0.5

      - id: BS04
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM05-q04"
        question: "Ce afișează arr=(\"first\" \"second\" \"third\"); echo \"__P0__\"?"
        options:
          a: "first"
          b: "second"
          c: "third"
          d: "Eroare"
        answer: "b"
        explanation: "Bash arrays start at index 0."
        points: 0.5

      - id: BS05
        type: multiple_choice
        difficulty: hard
        bloom: understand
        source: "SEM05-q05"
        question: |
          Fără 'declare -A':
          config[host]="localhost"
          config[port]="8080"
          echo "Keys: ${!config[@]}"
        options:
          a: "Keys: host port"
          b: "Keys: 0"
          c: "Keys: 0 0"
          d: "Eroare"
        answer: "b"
        explanation: "Without declare -A, Bash treats 'host' and 'port' as arithmetic (=0), both write to config[0]."
        points: 0.75

      - id: BS06
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM05-q06"
        question: |
          files=("file one.txt" "file two.txt")
          count=0; for f in ${files[@]}; do ((count++)); done
          echo "Iterations: $count"
        options:
          a: "2"
          b: "4"
          c: "1"
          d: "Eroare"
        answer: "b"
        explanation: "Without quotes, word splitting separates each element. Use \"${files[@]}\"."
        points: 0.5

      - id: BS07
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM05-q07"
        question: |
          arr=(a b c d e); unset arr[2]
          echo "Indices: ${!arr[@]} Length: ${#arr[@]}"
        options:
          a: "Indices: 0 1 2 3 Length: 4"
          b: "Indices: 0 1 3 4 Length: 4"
          c: "Indices: 0 1 2 3 4 Length: 5"
          d: "Eroare"
        answer: "b"
        explanation: "nu este setat creates a sparse array; indices don't re-index."
        points: 0.5

      - id: BS08
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM05-q08"
        question: |
          set -euo pipefail
          x="${UNDEFINED_VAR}"
          echo "Continues..."
        options:
          a: "Displays 'Continues...' with x=\"\""
          b: "Error: unbound variable"
          c: "Displays 'Continues...' with x=\"UNDEFINED_VAR\""
          d: "Depends on Bash version"
        answer: "b"
        explanation: "set -u makes undefined variables an error."
        points: 0.5

      - id: BS09
        type: multiple_choice
        difficulty: hard
        bloom: understand
        source: "SEM05-q09"
        question: |
          set -e
          if false; then echo "In if"; fi
          echo "After if"
        options:
          a: "Script stops at false"
          b: "Displays 'After if'"
          c: "Displays 'In if' then 'After if'"
          d: "Syntax error"
        answer: "b"
        explanation: "set -e has exceptions: if/while conditions, || and && left side, negation with !."
        points: 0.75

      - id: BS10
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM06-q01"
        question: "Care command sets strict Bash mode: stop on error, undefined variables, and pipe failures?"
        options:
          a: "set -e"
          b: "set -euo pipefail"
          c: "set -x"
          d: "set -v"
        answer: "b"
        explanation: "-e: exit on error, -u: undefined var error, -o pipefail: pipe error detection."
        points: 0.5

      - id: BS11
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM06-q02"
        question: "Care signal is sent when user presses Ctrl+C?"
        options:
          a: "SIGTERM"
          b: "SIGKILL"
          c: "SIGINT"
          d: "SIGHUP"
        answer: "c"
        explanation: "SIGINT (Signal Interrupt) from Ctrl+C; can be caught cu trap."
        points: 0.5

      - id: BS12
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM06-q03"
        question: "Care codul de ieșire indicates successful execution in Unix convention?"
        options:
          a: "1"
          b: "-1"
          c: "0"
          d: "255"
        answer: "c"
        explanation: "0 = success, non-zero = error. Check with $?."
        points: 0.5

      - id: BS13
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM06-q04"
        question: "De ce separate code into lib/core.sh, lib/utils.sh, lib/config.sh?"
        options:
          a: "Bash limits file size to 1000 lines"
          b: "For reuse, isolated testing, and easy maintenance"
          c: "source only works with small files"
          d: "To make code harder to understand"
        answer: "b"
        explanation: "Modular architecture enables reuse, independent testing, and clear responsibilities."
        points: 0.5

      - id: BS14
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM06-q05"
        question: "Cum face incremental backup differ from full backup?"
        options:
          a: "Copies all files every time"
          b: "Copies only files modified since last backup"
          c: "Uses better compression"
          d: "Automatically deletes old files"
        answer: "b"
        explanation: "Incremental uses 'find -newer' to detect changes, saving time and space."
        points: 0.5

      - id: BS15
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM06-q07"
        question: "Ce este the correct order of logging levels from least to most severe?"
        options:
          a: "ERROR, WARN, INFO, DEBUG"
          b: "DEBUG, INFO, WARN, ERROR"
          c: "INFO, DEBUG, ERROR, WARN"
          d: "WARN, ERROR, DEBUG, INFO"
        answer: "b"
        explanation: "DEBUG < INFO < WARN < ERROR < FATAL is the standard ordering."
        points: 0.5

      - id: BS16
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM06-q09"
        question: "Ce este the correct syntax to run 'cleanup' on EXIT and SIGINT?"
        options:
          a: "trap cleanup EXIT SIGINT"
          b: "trap 'cleanup' EXIT INT"
          c: "on_exit cleanup"
          d: "finally { cleanup }"
        answer: "b"
        explanation: "trap 'command' SIGNALS... with quotes; INT not SIGINT in trap."
        points: 0.5

      - id: BS17
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM06-q10"
        question: "Care command finds files modified after timestamp.txt?"
        options:
          a: "find /data -newer timestamp.txt -type f"
          b: "find /data -mtime +timestamp.txt"
          c: "find /data --after timestamp.txt"
          d: "find /data -modified > timestamp.txt"
        answer: "a"
        explanation: "-newer compares mtime with reference file."
        points: 0.5

      - id: BS18
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM06-q11"
        question: "Cum return a numeric value from a Bash function?"
        options:
          a: "return $value (for 0-255)"
          b: "echo $value and capture with $()"
          c: "Both methods, for different purposes"
          d: "export RESULT=$value"
        answer: "c"
        explanation: "return for codul de ieșire (0-255), echo for output values."
        points: 0.5

      - id: BS19
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM06-q12"
        question: "Care command checks dacă a web server responds successfully?"
        options:
          a: "ping localhost:8080"
          b: "curl -sf http://localhost:8080/health"
          c: "wget --check localhost:8080"
          d: "nc -z localhost 8080"
        answer: "b"
        explanation: "curl -s (silent) -f (fail on HTTP error) verifies HTTP response, not just TCP."
        points: 0.5

      - id: BS20
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM06-q13"
        question: "Care syntax correctly iterates over array elements preserving spaces?"
        options:
          a: "for item in $ARRAY; do"
          b: "for item in ${ARRAY[@]}; do"
          c: "for item in \"${ARRAY[@]}\"; do"
          d: "foreach item in ARRAY; do"
        answer: "c"
        explanation: "Double quotes preserve elements with spaces as single units."
        points: 0.5

      - id: BS21
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM06-q14"
        question: "Care command verifies backup integrity using checksum?"
        options:
          a: "md5sum -c backup.md5"
          b: "sha256sum backup.tar.gz"
          c: "diff backup.md5 backup.tar.gz"
          d: "cmp --checksum backup.tar.gz"
        answer: "a"
        explanation: "-c (check) reads hash file and verifies each entry."
        points: 0.5

      - id: BS22
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM06-q15"
        question: |
          Un script de backup conține:
          if [ -z "$1" ]; then echo "Usage"; exit 1; fi
          tar czf backup.tar.gz "$1"
          Rulează, dar creează o arhivă goală. Ce lipsește cel mai probabil?
        options:
          a: "tar failed but error was suppressed by 2>/dev/null"
          b: "echo doesn't work after tar"
          c: "BACKUP_FILE is undefined"
          d: "SOURCE_DIR only has empty directories"
        answer: "a"
        explanation: "2>/dev/null hides errors; without set -e, script continues after failure."
        points: 0.75

      - id: BS23
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM06-q16"
        question: |
          Un script folosește:
          echo $$ > /tmp/mytool.pid
          De ce acest tipar de fișier PID poate cauza probleme?
        options:
          a: "$$ doesn't contain correct PID"
          b: "Race condition: two instances can check simultaneously and both write"
          c: "PID_FILE must be in /var/run"
          d: "Echo cannot write to files"
        answer: "b"
        explanation: "TOCTOU (Time Of Check To Time Of Use) race. Use atomic mkdir or flock."
        points: 0.75

      - id: BS24
        type: multiple_choice
        difficulty: hard
        bloom: evaluate
        source: "SEM06-q17"
        question: "Pentru deployment fără downtime cu rollback instant dar resurse limitate, ce strategie?"
        options:
          a: "Blue-Green deployment"
          b: "Rolling deployment"
          c: "Recreate deployment"
          d: "Big bang deployment"
        answer: "b"
        explanation: "Rolling replaces instances gradually; doesn't need double resources like Blue-Green."
        points: 0.75

      - id: BS25
        type: multiple_choice
        difficulty: hard
        bloom: evaluate
        source: "SEM06-q18"
        question: "Pentru backup-uri zilnice pe server cu CPU limitat dar spațiu de stocare suficient, ce compresie?"
        options:
          a: "xz (best ratio)"
          b: "gzip (balanced)"
          c: "zstd (fast with good compression)"
          d: "No compression"
        answer: "c"
        explanation: "zstd: speed comparable to gzip, better compression, lower CPU than xz."
        points: 0.75

      - id: BS26
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Write a trap comandă to remove /tmp/lockfile on script exit."
        answer: "trap 'rm -f /tmp/lockfile' EXIT"
        accept_alternatives:
          - "trap \"rm -f /tmp/lockfile\" EXIT"
        points: 1.0

      - id: BS27
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Cum make a variable local to a function în Bash?"
        answer: "local varname=value"
        keywords: ["local"]
        points: 0.5

      - id: BS28
        type: practical
        difficulty: hard
        bloom: create
        question: "Write a function care logs messages cu timestamp and level: log INFO \"message\""
        answer: |
          log() {
              local level="$1"
              local msg="$2"
              echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $msg"
          }
        points: 1.5

      - id: BS29
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce face ${var:-default}?"
        options:
          a: "Sets var to default"
          b: "Returns default dacă var is nu este setat sau este gol"
          c: "Returns default only dacă var is nu este setat"
          d: "Deletes var"
        answer: "b"
        explanation: "${var:-default} provides default for unset/empty; ${var-default} only for nu este setat."
        points: 0.5

      - id: BS30
        type: multiple_choice
        difficulty: medium
        bloom: apply
        question: "Care getopts specification handles '-v' flag and '-f filename' option?"
        options:
          a: "getopts 'v:f:'"
          b: "getopts 'vf:'"
          c: "getopts 'v f'"
          d: "getopts '-v -f:'"
        answer: "b"
        explanation: "v = flag (no argument), f: = option requiring argument."
        points: 0.5


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 5: SYSTEM ADMINISTRATION
# Sources: SEM03, Lectures 3
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Administrare de sistem"
    lectures: [3]
    seminars: [3]
    question_count: 20
    
    questions:
      - id: SA01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM03-q01"
        question: "Care find option specifies file type?"
        options:
          a: "-name"
          b: "-type"
          c: "-size"
          d: "-exec"
        answer: "b"
        explanation: "-type f for files, -type d for directories, -type l for symlinks."
        points: 0.5

      - id: SA02
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM03-q02"
        question: "Care este diferența între locate și find?"
        options:
          a: "Sunt identice"
          b: "locate uses a database (fast); find searches real-time (slow but current)"
          c: "find is deprecated"
          d: "locate only works on Windows"
        answer: "b"
        explanation: "locate queries updatedb database; find traverses filesystem."
        points: 0.5

      - id: SA03
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM03-q03"
        question: "Care command finds .log files larger than 10MB modified in last 7 days?"
        options:
          a: "find / -name '*.log' -size +10M -mtime -7"
          b: "locate *.log | size 10M | date 7"
          c: "find / -type log -big -recent"
          d: "search *.log 10M 7d"
        answer: "a"
        explanation: "-size +10M (larger than 10M), -mtime -7 (modified within 7 days)."
        points: 0.5

      - id: SA04
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM03-q04"
        question: "În find, care este precedența operatorilor pentru -name '*.txt' -o -name '*.log' -size +1M?"
        options:
          a: "All evaluated left to right"
          b: "AND (-size) binds tighter than OR (-o)"
          c: "OR binds tighter than AND"
          d: "Size is evaluated first"
        answer: "b"
        explanation: "AND has higher precedence: '*.txt' OR ('*.log' AND +1M). Use \\( \\) for grouping."
        points: 0.75

      - id: SA05
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM03-q05"
        question: "Care approach handles filenames with spaces in find | xargs?"
        options:
          a: "find | xargs rm"
          b: "find -print0 | xargs -0 rm"
          c: "find | xargs -s rm"
          d: "find -spaces | xargs rm"
        answer: "b"
        explanation: "-print0 uses null terminator; xargs -0 reads null-separated input."
        points: 0.5

      - id: SA06
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM03-q06"
        question: "Ce reprezintă $# într-un script Bash?"
        options:
          a: "Last argument"
          b: "Number of arguments"
          c: "Script name"
          d: "All arguments"
        answer: "b"
        explanation: "$# = argument count, $@ = all arguments, $0 = script name, $? = exit status."
        points: 0.5

      - id: SA07
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM03-q07"
        question: "Ce păstrează \"$@\" ce $* nu păstrează?"
        options:
          a: "Nothing, they are identical"
          b: "The original argument boundaries (arguments with spaces)"
          c: "The script name"
          d: "The codul de ieșire"
        answer: "b"
        explanation: "\"$@\" expands each argument as separate word; $* joins them."
        points: 0.5

      - id: SA08
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM03-q08"
        question: "În getopts 'vf:', ce înseamnă f:?"
        options:
          a: "-f is a flag"
          b: "-f requires an argument"
          c: "-f is optional"
          d: "-f is invalid"
        answer: "b"
        explanation: "Colon after letter means option requires argument (OPTARG)."
        points: 0.5

      - id: SA09
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM03-q09"
        question: "Ce înseamnă permission mode 755?"
        options:
          a: "rwx------"
          b: "rwxr-xr-x"
          c: "rw-rw-rw-"
          d: "rwxrwxrwx"
        answer: "b"
        explanation: "7=rwx (owner), 5=r-x (group), 5=r-x (others)."
        points: 0.5

      - id: SA10
        type: multiple_choice
        difficulty: easy
        bloom: apply
        source: "SEM03-q10"
        question: "Ce face chmod g+w?"
        options:
          a: "Removes write from group"
          b: "Adds write permission to group"
          c: "Sets group to world"
          d: "Changes group ownership"
        answer: "b"
        explanation: "g+w adds (+) write (w) permission to group (g)."
        points: 0.5

      - id: SA11
        type: multiple_choice
        difficulty: medium
        bloom: analyse
        source: "SEM03-q11"
        question: "Un script are permisiunile rwxr-xr-x dar nu se execută. Care este cauza probabilă?"
        options:
          a: "Missing read permission"
          b: "Missing execute permission on directory"
          c: "Wrong ownership"
          d: "File is too large"
        answer: "b"
        explanation: "Need execute on directories to access contents; check parent dirs."
        points: 0.5

      - id: SA12
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "SEM03-q12"
        question: "ce face SUID (chmod u+s) allow?"
        options:
          a: "Anyone can delete file"
          b: "File executes with owner's permissions, not executor's"
          c: "File is shared"
          d: "File is system-protected"
        answer: "b"
        explanation: "SUID runs executable as owner (e.g., passwd runs as root)."
        points: 0.5

      - id: SA13
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "SEM03-q13"
        question: "Ce este the crontab field order?"
        options:
          a: "hour minute day month weekday"
          b: "minute hour day month weekday"
          c: "day month weekday hour minute"
          d: "minute hour month day weekday"
        answer: "b"
        explanation: "m h dom mon dow command (minute, hour, day-of-month, month, day-of-week)."
        points: 0.5

      - id: SA14
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM03-q14"
        question: "ce face cron expression '30 2 * * 1' schedule?"
        options:
          a: "Every day at 2:30"
          b: "Every Monday at 2:30"
          c: "Every hour at minute 30"
          d: "January 30 at 2:00"
        answer: "b"
        explanation: "minute=30, hour=2, any day, any month, weekday=1 (Monday)."
        points: 0.5

      - id: SA15
        type: multiple_choice
        difficulty: medium
        bloom: apply
        source: "SEM03-q15"
        question: "Cum schedule a job every 15 minutes in cron?"
        options:
          a: "15 * * * *"
          b: "*/15 * * * *"
          c: "0/15 * * * *"
          d: "* 15 * * *"
        answer: "b"
        explanation: "*/15 means every 15 units; 15 would be only at minute 15."
        points: 0.5

      - id: SA16
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "SEM03-q16"
        question: "A cron job runs manually but fails in cron. Most likely cause?"
        options:
          a: "Wrong syntax"
          b: "Missing absolute paths or environment variables"
          c: "Cron is disabled"
          d: "File permissions"
        answer: "b"
        explanation: "Cron has minimal PATH; use absolute paths and set environment."
        points: 0.75

      - id: SA17
        type: multiple_choice
        difficulty: hard
        bloom: evaluate
        source: "SEM03-q17"
        question: "Care is more efficient for deleting many files: find -exec rm {} + or find | while read; rm?"
        options:
          a: "They are equal"
          b: "-exec {} + batches files into fewer rm invocations"
          c: "while read is faster"
          d: "Neither works"
        answer: "b"
        explanation: "{} + batches arguments (like xargs); {} \\; runs rm once per file."
        points: 0.75

      - id: SA18
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Write a find comandă to delete all.tmp files older than 30 days."
        answer: "find /path -name '*.tmp' -mtime +30 -delete"
        accept_alternatives:
          - "find /path -name '*.tmp' -mtime +30 -exec rm {} +"
        points: 1.0

      - id: SA19
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Write a cron entry to run backup.sh every Sunday at 3:00 AM."
        answer: "0 3 * * 0 /path/to/backup.sh"
        accept_alternatives:
          - "0 3 * * 7 /path/to/backup.sh"
          - "0 3 * * SUN /path/to/backup.sh"
        points: 1.0

      - id: SA20
        type: practical
        difficulty: hard
        bloom: apply
        question: "Write a script care accepts -v (verbose) and -o outputfile options using getopts."
        answer: |
          while getopts 'vo:' opt; do
              case $opt in
                  v) VERBOSE=1 ;;
                  o) OUTPUT="$OPTARG" ;;
                  *) echo "Usage: $0 [-v] [-o file]" >&2; exit 1 ;;
              esac
          done
        points: 1.5


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 6: PROCESS MANAGEMENT
# Sources: Lectures 2-5
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Managementul proceselor"
    lectures: [2, 3, 4, 5]
    seminars: []
    question_count: 36
    
    questions:
      # --- Basic OS Concepts (Lecture 02) ---
      - id: PM01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L02-q01"
        question: "Ce este an interrupt?"
        options:
          a: "A fatal system error"
          b: "A hardware/software signal that requests CPU attention"
          c: "A jump instruction"
          d: "A type of memory"
        answer: "b"
        explanation: "Interrupts cause CPU to suspend current execution and run a handler."
        points: 0.5

      - id: PM02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L02-q02"
        question: "Care este diferența între an interrupt și a trap?"
        options:
          a: "Sunt identice"
          b: "Interrupt is hardware (async), trap is software (sync)"
          c: "Trap is faster"
          d: "Interrupt is generated by applications"
        answer: "b"
        explanation: "Interrupt = asynchronous, hardware. Trap = synchronous, software (syscall, exception)."
        points: 0.5

      - id: PM03
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L02-q03"
        question: "ce face Interrupt Vector Table (IVT) contain?"
        options:
          a: "List of all processes"
          b: "Addresses of handling routines for each interrupt type"
          c: "System passwords"
          d: "Hardware configuration"
        answer: "b"
        explanation: "IVT maps interrupt numbers to handler addresses."
        points: 0.5

      - id: PM04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L02-q04"
        question: "De ce must processor context be saved during interrupt handling?"
        options:
          a: "To clear memory"
          b: "To return to the exact state before the interrupt"
          c: "To speed up processing"
          d: "It is not necessary"
        answer: "b"
        explanation: "Context (registers, PC, flags) must be saved for correct process resumption."
        points: 0.5

      - id: PM05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L02-q05"
        question: "Ce înseamnă DMA (Direct Memory Access)?"
        options:
          a: "A type of RAM"
          b: "Data transfer between I/O and memory without CPU involvement"
          c: "A network protocol"
          d: "An encryption method"
        answer: "b"
        explanation: "DMA allows I/O devices to transfer data directly to/from memory."
        points: 0.5

      - id: PM06
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L02-q06"
        question: "Ce este polling and why is it inefficient?"
        options:
          a: "Polling = active waiting, CPU checks repeatedly, wasting cycles"
          b: "Polling = hardware interrupts"
          c: "Polling is very efficient"
          d: "Polling = DMA transfer"
        answer: "a"
        explanation: "In polling, CPU constantly checks device status (busy-wait), wasting cycles."
        points: 0.5

      # --- Processes (Lecture 03) ---
      - id: PM07
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L03-q01"
        question: "Ce este a process?"
        options:
          a: "An executable file stored on disk"
          b: "A program in execution with allocated resources"
          c: "A function from source code"
          d: "A type of memory"
        answer: "b"
        explanation: "Process = program in execution + address space + resources."
        points: 0.5

      - id: PM08
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L03-q02"
        question: "ce face PCB (Process Control Block) contain?"
        options:
          a: "Only program code"
          b: "PID, state, CPU registers, scheduling info, resources"
          c: "Only heap memory"
          d: "User password"
        answer: "b"
        explanation: "PCB contains all information OS needs to manage the process."
        points: 0.5

      - id: PM09
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L03-q03"
        question: "ce face fork() return in child process?"
        options:
          a: "Parent's PID"
          b: "0"
          c: "-1"
          d: "Child's PID"
        answer: "b"
        explanation: "fork() returns 0 in child, child's PID in parent, -1 on error."
        points: 0.5

      - id: PM10
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L03-q04"
        question: "Care sunt the 5 main states of a process?"
        options:
          a: "Start, Run, Stop, Pause, End"
          b: "New, Ready, Running, Waiting, Terminated"
          c: "Init, Active, Sleep, Wake, Exit"
          d: "Create, Execute, Block, Resume, Kill"
        answer: "b"
        explanation: "Standard 5-state model with transitions between states."
        points: 0.5

      - id: PM11
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L03-q05"
        question: "Ce face the exec() family?"
        options:
          a: "Creates a new process"
          b: "Replaces current process image with a new program"
          c: "Terminates current process"
          d: "Duplicates the process"
        answer: "b"
        explanation: "exec() replaces code, data, stack with new program; PID stays same."
        points: 0.5

      - id: PM12
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L03-q06"
        question: "Ce este a zombie process?"
        options:
          a: "Process consuming too much memory"
          b: "Terminated process whose parent hasn't called wait()"
          c: "Process blocked on I/O"
          d: "A virus"
        answer: "b"
        explanation: "Zombie = terminated but parent hasn't read exit status; occupies process table slot."
        points: 0.5

      - id: PM13
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L03-q07"
        question: "Ce se întâmplă cu un proces orfan?"
        options:
          a: "Se prăbușește"
          b: "Este adoptat de init (PID 1)"
          c: "Devine un proces zombie"
          d: "Este terminat"
        answer: "b"
        explanation: "Când părintele moare, procesele copil devin orfane și sunt adoptate de init (PID 1) pentru gestionare și curățare."
        points: 0.5

      - id: PM14
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L03-q09"
        question: "ce technique makes fork() efficient on modern systems?"
        options:
          a: "Immediate copying of entire memory"
          b: "Copy-on-Write (COW): pages shared, copied only on write"
          c: "Memory compression"
          d: "Automatic swap"
        answer: "b"
        explanation: "COW delays copying until modification, saving memory and time."
        points: 0.75

      - id: PM15
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L03-q11"
        question: "Un program apelează fork() de 3 ori în secvență. Câte procese există la final?"
        options:
          a: "3"
          b: "4"
          c: "8"
          d: "6"
        answer: "c"
        explanation: "Each fork doubles processes: 1→2→4→8. Formula: 2^n."
        points: 0.75

      # --- Scheduling (Lecture 04) ---
      - id: PM16
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L04-q01"
        question: "Ce este a scheduler?"
        options:
          a: "A code compiler"
          b: "OS component care decides which process runs on CPU"
          c: "A type of memory"
          d: "A network protocol"
        answer: "b"
        explanation: "Scheduler selects next process from Ready queue for CPU execution."
        points: 0.5

      - id: PM17
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L04-q02"
        question: "Ce înseamnă preemption?"
        options:
          a: "Forced termination"
          b: "OS can interrupt running process to run another"
          c: "Process creation"
          d: "Memory allocation"
        answer: "b"
        explanation: "Preemption = OS's ability to forcibly suspend a process."
        points: 0.5

      - id: PM18
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L04-q03"
        question: "Ce este turnaround time?"
        options:
          a: "System boot time"
          b: "Total time from submission to process completion"
          c: "CPU execution time"
          d: "Queue waiting time"
        answer: "b"
        explanation: "Turnaround = total time (submission → completion), includes waiting + execution."
        points: 0.5

      - id: PM19
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L04-q04"
        question: "Care este diferența între FCFS și SJF?"
        options:
          a: "FCFS is preemptive"
          b: "FCFS serves in arrival order; SJF serves shortest job first"
          c: "SJF is slower"
          d: "No difference"
        answer: "b"
        explanation: "FCFS = First Come First Served. SJF = Shortest Job First."
        points: 0.5

      - id: PM20
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L04-q05"
        question: "ce problemă face Round Robin solve?"
        options:
          a: "Minimises turnaround time"
          b: "Ensures fairness through equal time quanta"
          c: "Eliminates deadlocks"
          d: "Reduces memory"
        answer: "b"
        explanation: "RR gives each process a time quantum, preventing starvation."
        points: 0.5

      - id: PM21
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L04-q06"
        question: "Ce este starvation in scheduling?"
        options:
          a: "Process consuming too much CPU"
          b: "Process never receives CPU because others have higher priority"
          c: "Lack of RAM"
          d: "Disk error"
        answer: "b"
        explanation: "Starvation = process waits indefinitely because other processes preempt it."
        points: 0.5

      - id: PM22
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L04-q08"
        question: "Cum face aging work in priority scheduling?"
        options:
          a: "Terminates old processes"
          b: "Gradually increases priority of waiting processes"
          c: "Reduces priority of CPU-bound processes"
          d: "Deletes inactive processes"
        answer: "b"
        explanation: "Aging = periodic priority increment for waiting processes to prevent starvation."
        points: 0.5

      - id: PM23
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L04-q10"
        question: "Cuanta de timp în RR este 10ms. Procesul necesită 25ms CPU. Câte preempțiuni?"
        options:
          a: "1"
          b: "2"
          c: "3"
          d: "Never"
        answer: "b"
        explanation: "Runs 10ms (preempt), 10ms (preempt), 5ms (finish). 2 preemptions."
        points: 0.75

      - id: PM24
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L04-q11"
        question: "De ce is MLFQ considered the most versatile scheduling algorithm?"
        options:
          a: "Simplest to implement"
          b: "Combines advantages of multiple algorithms and adapts to behaviour"
          c: "Uses least CPU"
          d: "Doesn't require priorities"
        answer: "b"
        explanation: "MLFQ dynamically adjusts priorities based on process behaviour."
        points: 0.75

      - id: PM25
        type: practical
        difficulty: hard
        bloom: apply
        source: "L04-q12"
        question: "P1(burst=6), P2(burst=2), P3(burst=4) sosesc la t=0. Cu SJF, care este timpul mediu de așteptare?"
        options:
          a: "4.0"
          b: "3.33"
          c: "2.67"
          d: "5.0"
        answer: "c"
        explanation: "SJF order: P2(2), P3(4), P1(6). Waiting: P2=0, P3=2, P1=6. Avg = 8/3 = 2.67."
        points: 0.75

      # --- Threads (Lecture 05) ---
      - id: PM26
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L05-q01"
        question: "Ce este a thread?"
        options:
          a: "An independent process"
          b: "Smallest unit of execution, shares address space with other threads in same process"
          c: "A type of memory"
          d: "An executable file"
        answer: "b"
        explanation: "Thread = lightweight process, shares code/data/resources, has own stack."
        points: 0.5

      - id: PM27
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L05-q02"
        question: "ce do threads lui same process share?"
        options:
          a: "Nothing, completely isolated"
          b: "Code, global data, heap, open files"
          c: "Only the stack"
          d: "Only CPU registers"
        answer: "b"
        explanation: "Threads share entire address space (code, data, heap) and resources."
        points: 0.5

      - id: PM28
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L05-q03"
        question: "ce do threads NOT share?"
        options:
          a: "Program code"
          b: "Global variables"
          c: "Stack, CPU registers, thread ID"
          d: "Open files"
        answer: "c"
        explanation: "Each thread has own stack, registers, and TID."
        points: 0.5

      - id: PM29
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L05-q04"
        question: "De ce is creating a thread faster than fork()?"
        options:
          a: "Threads don't need memory"
          b: "Address space doesn't need duplication, only new stack allocated"
          c: "Threads don't run code"
          d: "Fork() is deprecated"
        answer: "b"
        explanation: "Thread reuses existing address space; fork() must create/copy entire space."
        points: 0.5

      - id: PM30
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L05-q06"
        question: "ce threading model do most modern systems use?"
        options:
          a: "Many-to-One"
          b: "One-to-One (1:1)"
          c: "Many-to-Many"
          d: "None-to-None"
        answer: "b"
        explanation: "1:1 maps each user thread to kernel thread, allowing full parallelism."
        points: 0.5

      - id: PM31
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L05-q08"
        question: "ce problemă can occur when a thread modifies a global variable?"
        options:
          a: "Variable becomes read-only"
          b: "Race condition: other threads may read inconsistent values"
          c: "Program terminates"
          d: "Memory doubles"
        answer: "b"
        explanation: "Unsynchronised concurrent access causes race conditions."
        points: 0.5

      - id: PM32
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L05-q10"
        question: "Pe un sistem cu 4 nuclee, câte thread-uri CPU-bound pentru performanță optimă?"
        options:
          a: "1 thread"
          b: "4 threads (one per core)"
          c: "100 threads"
          d: "8 threads"
        answer: "b"
        explanation: "For CPU-bound: #threads ≈ #cores. More adds context switch overhead."
        points: 0.75

      - id: PM33
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L05-q12"
        question: "Pentru un program care citește fișiere mari și le procesează, ce strategie de threading?"
        options:
          a: "Single thread for everything"
          b: "Separate thread for I/O and worker threads for processing (producer-consumer)"
          c: "One thread per byte"
          d: "Don't use threads"
        answer: "b"
        explanation: "Separating I/O from processing allows parallelism via producer-consumer pattern-ul."
        points: 0.75

      - id: PM34
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Ce este comanda to view the process tree in Linux?"
        answer: "pstree"
        accept_alternatives:
          - "ps --forest"
          - "ps auxf"
        points: 0.5

      - id: PM35
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Cum send SIGTERM to process with PID 1234?"
        answer: "kill 1234"
        accept_alternatives:
          - "kill -15 1234"
          - "kill -TERM 1234"
          - "kill -SIGTERM 1234"
        points: 0.5

      - id: PM36
        type: practical
        difficulty: hard
        bloom: apply
        question: "Write C code fragment showing fork() + exec() pattern-ul to run 'ls -l'."
        answer: |
          pid_t pid = fork();
          if (pid == 0) {
              execlp("ls", "ls", "-l", NULL);
          } else {
              wait(NULL);
          }
        points: 1.5


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 7: SYNCHRONISATION
# Sources: Lectures 6-7
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Sincronizare"
    lectures: [6, 7]
    seminars: []
    question_count: 24
    
    questions:
      # --- Part 1: Peterson, Locks, Mutex (Lecture 06) ---
      - id: SY01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L06-q01"
        question: "Ce este a critical section?"
        options:
          a: "A fatal system error"
          b: "Code that accesses shared resources, must be executed atomically"
          c: "A type of memory"
          d: "A system function"
        answer: "b"
        explanation: "Critical section = code accessing shared data; only one thread at a time."
        points: 0.5

      - id: SY02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L06-q02"
        question: "Ce este a race condition?"
        options:
          a: "Competition between processes for memory"
          b: "Outcome depends on non-deterministic execution order"
          c: "A sorting algorithm"
          d: "A type of thread"
        answer: "b"
        explanation: "Race condition = behaviour dependent on timing of concurrent operations."
        points: 0.5

      - id: SY03
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L06-q03"
        question: "Care sunt the 3 conditions for correct critical section solution?"
        options:
          a: "Speed, memory, CPU"
          b: "Mutual exclusion, progress, bounded waiting"
          c: "Read, write, execute"
          d: "Lock, unlock, wait"
        answer: "b"
        explanation: "Mutual exclusion (exclusivity), progress (no unnecessary blocking), bounded waiting (no starvation)."
        points: 0.5

      - id: SY04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L06-q04"
        question: "Ce este busy-waiting and why is it problematic?"
        options:
          a: "An optimisation technique"
          b: "Process repeatedly checks condition in loop, wasting CPU cycles"
          c: "Memory allocation method"
          d: "A type of interrupt"
        answer: "b"
        explanation: "Busy-wait = spinning in loop; wastes CPU. Better: sleep + wake."
        points: 0.5

      - id: SY05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L06-q06"
        question: "Ce face atomic test-and-set instruction?"
        options:
          a: "Tests memory"
          b: "Reads value, sets to true, returns old value - all atomically"
          c: "Increments counter"
          d: "Disables interrupts"
        answer: "b"
        explanation: "TAS: atomic { old = *ptr; *ptr = true; return old; }. Basis for spinlocks."
        points: 0.5

      - id: SY06
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L06-q07"
        question: "Care este diferența între mutex și spinlock?"
        options:
          a: "Identical"
          b: "Mutex sleeps when blocked; spinlock face busy-wait"
          c: "Spinlock is safer"
          d: "Mutex doesn't work on multi-core"
        answer: "b"
        explanation: "Mutex: sleep/wake (long waits). Spinlock: busy-wait (short waits)."
        points: 0.5

      - id: SY07
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L06-q11"
        question: "Ce este the trade-off between spinlock and mutex for short critical sections?"
        options:
          a: "No trade-off"
          b: "Spinlock avoids context switch but wastes CPU; for very short sections, spinlock may be better"
          c: "Mutex is always better"
          d: "Spinlock doesn't work"
        answer: "b"
        explanation: "dacă critical section < context switch time, spinlock avoids sleep/wake overhead."
        points: 0.75

      - id: SY08
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L06-q12"
        question: "1000 threads increment a shared counter. Optimal synchronisation?"
        options:
          a: "No synchronisation"
          b: "Global mutex"
          c: "Atomic operations (atomic_fetch_add)"
          d: "Interrupt disabling"
        answer: "c"
        explanation: "For single counter, atomic operations (lock-free) are more efficient than mutexes."
        points: 0.75

      # --- Part 2: Semaphores, Buffer (Lecture 07) ---
      - id: SY09
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L07-q01"
        question: "Ce este a semaphore?"
        options:
          a: "A type of memory"
          b: "Integer variable accessed through atomic wait() and signal()"
          c: "A sorting algorithm"
          d: "A type of file"
        answer: "b"
        explanation: "Semaphore = variable with atomic P(wait)/V(signal) for synchronisation."
        points: 0.5

      - id: SY10
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L07-q02"
        question: "ce face wait() (P) do on a semaphore?"
        options:
          a: "Increments value"
          b: "Decrements value; dacă negative, process blocks"
          c: "Deletes semaphore"
          d: "Displays value"
        answer: "b"
        explanation: "wait(): S--; dacă (S < 0) block(). Process waits dacă resource unavailable."
        points: 0.5

      - id: SY11
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L07-q03"
        question: "Care este diferența între semafor binar și semafor de numărare?"
        options:
          a: "No difference"
          b: "Binary: 0/1 (mutex). Counting: any integer (multiple resources)"
          c: "Counting is slower"
          d: "Binary doesn't exist"
        answer: "b"
        explanation: "Binary = 0/1, equivalent to mutex. Counting = N resources."
        points: 0.5

      - id: SY12
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L07-q04"
        question: "In Producer-Consumer cu bounded buffer, why 3 semaphores?"
        options:
          a: "One is sufficient"
          b: "mutex (buffer access), empty (free slots), full (occupied slots)"
          c: "For speed"
          d: "No semaphores needed"
        answer: "b"
        explanation: "mutex = exclusivity, empty = producer waits for free slot, full = consumer waits for data."
        points: 0.5

      - id: SY13
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L07-q05"
        question: "Ce este a monitor in synchronisation?"
        options:
          a: "A afișa device"
          b: "High-level construct encapsulating data and procedures with implicit mutual exclusion"
          c: "A type of semaphore"
          d: "A system process"
        answer: "b"
        explanation: "Monitor = ADT with built-in synchronisation; only one thread executes at a time."
        points: 0.5

      - id: SY14
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L07-q07"
        question: "De ce check condition in while loop, not dacă, with condition variables?"
        options:
          a: "dacă is slower"
          b: "Spurious wakeups: thread may wake without condition being true"
          c: "while is syntactically safer"
          d: "dacă doesn't work"
        answer: "b"
        explanation: "Spurious wakeups and other threads may modify condition; must re-check."
        points: 0.5

      - id: SY15
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L07-q09"
        question: "De ce is wait() order on semaphores critical for avoiding deadlock?"
        options:
          a: "Order doesn't matter"
          b: "Wrong order leads to circular wait: each holds one, waits for other"
          c: "For speed"
          d: "For memory savings"
        answer: "b"
        explanation: "P1: wait(A), wait(B); P2: wait(B), wait(A) → deadlock. Consistent order prevents this."
        points: 0.75

      - id: SY16
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L07-q10"
        question: "In Readers-Writers, why can solution cause writer starvation?"
        options:
          a: "Writers are slower"
          b: "Continuous readers prevent writers from getting exclusive access"
          c: "Writers don't use semaphores"
          d: "Implementation error"
        answer: "b"
        explanation: "With reader preference, continuous stream of readers indefinitely blocks writers."
        points: 0.75

      - id: SY17
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L07-q12"
        question: "Bounded buffer capacity 10. Initial semaphore values?"
        options:
          a: "mutex=0, empty=0, full=10"
          b: "mutex=1, empty=10, full=0"
          c: "mutex=10, empty=1, full=1"
          d: "mutex=1, empty=0, full=10"
        answer: "b"
        explanation: "mutex=1 (exclusivity), empty=10 (10 free slots), full=0 (0 elements initially)."
        points: 0.75

      - id: SY18
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce POSIX function initialises a mutex?"
        answer: "pthread_mutex_init"
        accept_alternatives:
          - "pthread_mutex_init()"
        points: 0.5

      - id: SY19
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce function releases a semaphore (signals)?"
        answer: "sem_post"
        accept_alternatives:
          - "sem_post()"
          - "signal"
          - "V"
        points: 0.5

      - id: SY20
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este priority inversion?"
        options:
          a: "High priority runs first"
          b: "Low-priority task blocks high-priority indirectly via shared resource"
          c: "Priorities are reversed"
          d: "No such thing"
        answer: "b"
        explanation: "Priority inversion: high blocks on lock held by low, while medium runs."
        points: 0.5

      - id: SY21
        type: multiple_choice
        difficulty: hard
        bloom: understand
        question: "Cum face priority inheritance protocol solve priority inversion?"
        options:
          a: "Disables priorities"
          b: "Temporarily raises holder's priority to highest waiter"
          c: "Kills low-priority tasks"
          d: "Uses spinlocks only"
        answer: "b"
        explanation: "Priority inheritance: lock holder inherits priority of highest waiting thread."
        points: 0.75

      - id: SY22
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este a barrier in parallel programming?"
        options:
          a: "A type of lock"
          b: "Synchronisation point where threads wait until all reach it"
          c: "Memory protection"
          d: "Thread termination"
        answer: "b"
        explanation: "Barrier: all threads must arrive before any proceed past the barrier."
        points: 0.5

      - id: SY23
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este a reader-writer lock advantage over mutex?"
        options:
          a: "Faster"
          b: "Allows multiple concurrent readers when no writer"
          c: "Uses less memory"
          d: "No advantage"
        answer: "b"
        explanation: "RW lock: multiple readers OR one writer. Better parallelism for read-heavy workloads."
        points: 0.5

      - id: SY24
        type: practical
        difficulty: hard
        bloom: create
        question: "Write pseudocode for producer in bounded buffer cu semaphores."
        answer: |
          while (true) {
              item = produce();
              wait(empty);
              wait(mutex);
              buffer[in] = item;
              in = (in + 1) % N;
              signal(mutex);
              signal(full);
          }
        points: 1.5


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 8: DEADLOCK
# Sources: Lecture 8
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Interblocaj (deadlock)"
    lectures: [8]
    seminars: []
    question_count: 12
    
    questions:
      - id: DL01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L08-q01"
        question: "Ce este a deadlock?"
        options:
          a: "A computer virus"
          b: "Processes mutually block each other, waiting for resources held by others"
          c: "A compilation error"
          d: "A type of memory"
        answer: "b"
        explanation: "Deadlock = impasse: each waits for resource held by another in the group."
        points: 0.5

      - id: DL02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L08-q02"
        question: "Care sunt the 4 Coffman conditions for deadlock?"
        options:
          a: "Read, write, execute, delete"
          b: "Mutual exclusion, hold and wait, no preemption, circular wait"
          c: "Lock, unlock, signal, wait"
          d: "Create, destroy, modify, access"
        answer: "b"
        explanation: "All 4 must be true simultaneously for deadlock to occur."
        points: 0.5

      - id: DL03
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L08-q03"
        question: "Ce este a Resource Allocation Graph (RAG)?"
        options:
          a: "A sorting algorithm"
          b: "Graph showing allocation and request relationships between processes and resources"
          c: "A type of memory"
          d: "A network protocol"
        answer: "b"
        explanation: "RAG: nodes = processes/resources, edges = allocations/requests. Cycle indicates potential deadlock."
        points: 0.5

      - id: DL04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L08-q04"
        question: "Cum can 'circular wait' be prevented?"
        options:
          a: "Encrypting resources"
          b: "Imposing total order on resource acquisition"
          c: "Increasing memory"
          d: "Disabling interrupts"
        answer: "b"
        explanation: "dacă all acquire resources in same order, cycle cannot form."
        points: 0.5

      - id: DL05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L08-q06"
        question: "Ce este a 'safe' state in Banker's Algorithm?"
        options:
          a: "System has no viruses"
          b: "există an execution sequence where all processes can complete"
          c: "Memory is sufficient"
          d: "CPU is not overloaded"
        answer: "b"
        explanation: "Safe state = at least one safe sequence exists: processes complete without deadlock."
        points: 0.5

      - id: DL06
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L08-q07"
        question: "De ce is Banker's Algorithm rarely used in practice?"
        options:
          a: "Too simple"
          b: "Requires a priori knowledge of maximum resource requirements"
          c: "Doesn't work on multi-core"
          d: "Consumes too much memory"
        answer: "b"
        explanation: "Modern programs don't declare max resources; plus computational overhead."
        points: 0.5

      - id: DL07
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L08-q08"
        question: "Difference between deadlock prevention and avoidance?"
        options:
          a: "Identical"
          b: "Prevention permanently eliminates one condition; avoidance dynamically checks each request"
          c: "Prevention is slower"
          d: "Avoidance doesn't work"
        answer: "b"
        explanation: "Prevention: structurally impossible. Avoidance: permits only dacă system stays safe."
        points: 0.5

      - id: DL08
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L08-q09"
        question: "În RAG cu o singură instanță per resursă, ce indică un ciclu?"
        options:
          a: "Good performance"
          b: "Guaranteed deadlock"
          c: "Possible deadlock"
          d: "No problem"
        answer: "b"
        explanation: "Single instances: cycle = certain deadlock. Multiple instances: necessary but not sufficient."
        points: 0.75

      - id: DL09
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L08-q10"
        question: "De ce can resource preemption be impossible for certain resurse?"
        options:
          a: "Always possible"
          b: "Some resources cannot be taken without corrupting state"
          c: "Preemption is too fast"
          d: "Requires special hardware"
        answer: "b"
        explanation: "Non-preemptable: printer mid-print, mutexes; cannot take without losing work."
        points: 0.75

      - id: DL10
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L08-q11"
        question: "Sistemul folosește detectare + recuperare pentru deadlock. Care este compromisul?"
        options:
          a: "No trade-off"
          b: "Less overhead normally, dar recovery (kill/rollback) can be costly"
          c: "Always better than prevention"
          d: "Doesn't work"
        answer: "b"
        explanation: "Detection runs periodically; recovery involves termination or rollback."
        points: 0.75

      - id: DL11
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L08-q12"
        question: "2 procese, 2 blocări (A, B). P1 dobândește A apoi B; P2 dobândește B apoi A. Cum se previne deadlock-ul?"
        options:
          a: "Use more locks"
          b: "Both acquire in same order: A then B"
          c: "Remove locks"
          d: "Increase P1's priority"
        answer: "b"
        explanation: "Consistent global order (A < B) eliminates circular wait."
        points: 0.75

      - id: DL12
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "Name one method to recover from deadlock."
        answer: "Process termination"
        accept_alternatives:
          - "Kill process"
          - "Resource preemption"
          - "Rollback"
          - "Checkpoint and restart"
        points: 0.5


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 9: MEMORY MANAGEMENT
# Sources: Lectures 9-10
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Managementul memoriei"
    lectures: [9, 10]
    seminars: []
    question_count: 24
    
    questions:
      # --- Part 1: Paging, Segmentation (Lecture 09) ---
      - id: MM01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L09-q01"
        question: "Ce este a logical (virtual) address?"
        options:
          a: "Physical address in RAM"
          b: "Address generated by CPU, seen by process"
          c: "Address on disk"
          d: "IP address"
        answer: "b"
        explanation: "Logical address = address seen by program; translated by MMU to physical."
        points: 0.5

      - id: MM02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L09-q02"
        question: "Ce este paging?"
        options:
          a: "Dividing program into functions"
          b: "Dividing memory into fixed-size blocks (pages and frames)"
          c: "Memory compression"
          d: "Data encryption"
        answer: "b"
        explanation: "Paging: logical space into pages, physical memory into frames of same size."
        points: 0.5

      - id: MM03
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L09-q04"
        question: "Care este diferența între fragmentarea internă și externă?"
        options:
          a: "Identical"
          b: "Internal: wasted within blocks. External: free space fragmented between blocks"
          c: "External doesn't exist"
          d: "Internal only on disk"
        answer: "b"
        explanation: "Internal: last frame partially used. External: free blocks too small."
        points: 0.5

      - id: MM04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L09-q05"
        question: "De ce face paging eliminate external fragmentation?"
        options:
          a: "Doesn't eliminate it"
          b: "Any free frame can be used for any page; contiguity doesn't matter"
          c: "Pages are compressed"
          d: "Frames are larger"
        answer: "b"
        explanation: "Frames have fixed size and are interchangeable."
        points: 0.5

      - id: MM05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L09-q07"
        question: "Ce face the MMU (Memory Management Unit)?"
        options:
          a: "Manages network"
          b: "Translates logical addresses to physical in hardware"
          c: "Compiles programs"
          d: "Stores passwords"
        answer: "b"
        explanation: "MMU = hardware for address translation and protection checking."
        points: 0.5

      - id: MM06
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L09-q09"
        question: "Sistemul are adrese pe 32 biți, pagini de 4KB. Câte intrări în tabelul de pagini?"
        options:
          a: "1024"
          b: "1 million (2^20)"
          c: "4 billion"
          d: "4096"
        answer: "b"
        explanation: "4KB = 2^12 offset. 32-12 = 20 bits for page number → 2^20 entries."
        points: 0.75

      - id: MM07
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L09-q10"
        question: "De ce are multi-level page tables used?"
        options:
          a: "For speed"
          b: "To save memory: don't allocate entries for unused pages"
          c: "For security"
          d: "Not used in practice"
        answer: "b"
        explanation: "Multi-level: allocate tables only for used regions, not entire space."
        points: 0.75

      - id: MM08
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L09-q12"
        question: "Adresă logică 0x00003A7F pe sistem cu pagini de 4KB. Care este numărul paginii?"
        options:
          a: "0x3A7F"
          b: "0x3"
          c: "0xA7F"
          d: "0x00003"
        answer: "b"
        explanation: "0x00003A7F: last 12 bits (0xA7F) = offset. Remainder (0x3) = page number."
        points: 0.75

      # --- Part 2: Virtual Memory, TLB (Lecture 10) ---
      - id: MM09
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L10-q01"
        question: "Ce este virtual memory?"
        options:
          a: "Additional RAM"
          b: "Technique using disk to extend apparent memory"
          c: "Cache memory"
          d: "ROM memory"
        answer: "b"
        explanation: "Virtual memory allows processes to use more memory than physical RAM."
        points: 0.5

      - id: MM10
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L10-q02"
        question: "Ce este TLB (Translation Lookaside Buffer)?"
        options:
          a: "A type of RAM"
          b: "Hardware cache for recent page→frame translations"
          c: "A replacement algorithm"
          d: "A software structure"
        answer: "b"
        explanation: "TLB = fast associative cache for frequently accessed PTEs."
        points: 0.5

      - id: MM11
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L10-q03"
        question: "Ce este a page fault?"
        options:
          a: "A programming error"
          b: "Access to page not in physical memory"
          c: "A virus"
          d: "A disk error"
        answer: "b"
        explanation: "Page fault = requested page not in RAM; OS brings it from disk."
        points: 0.5

      - id: MM12
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L10-q05"
        question: "Ce este Belady's anomaly?"
        options:
          a: "A hardware error"
          b: "More frames can cause more page faults for FIFO"
          c: "An optimal algorithm"
          d: "An optimisation"
        answer: "b"
        explanation: "Belady: FIFO can have more faults cu more frames. LRU doesn't have acest."
        points: 0.5

      - id: MM13
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L10-q06"
        question: "De ce is OPT algorithm not used in practice?"
        options:
          a: "Too slow"
          b: "Requires knowledge of future page accesses"
          c: "Consumes too much memory"
          d: "Doesn't work"
        answer: "b"
        explanation: "OPT replaces page used furthest in future - impossible to know."
        points: 0.5

      - id: MM14
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L10-q08"
        question: "Ce este thrashing?"
        options:
          a: "An optimisation"
          b: "System spending more time swapping than executing useful code"
          c: "A sorting algorithm"
          d: "A network error"
        answer: "b"
        explanation: "Thrashing: too few frames → continuous page faults → disastrous performance."
        points: 0.5

      - id: MM15
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L10-q10"
        question: "De ce face working set model help prevent thrashing?"
        options:
          a: "Deletes pages"
          b: "Allocates enough frames for process's recent active pages"
          c: "Increases CPU speed"
          d: "Doesn't help"
        answer: "b"
        explanation: "Working set = pages used recently. Allocating WS avoids excessive faults."
        points: 0.75

      - id: MM16
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L10-q12"
        question: "100MB RAM, 50 procese, fiecare cu working set de 3MB. Ce se întâmplă?"
        options:
          a: "Works normally"
          b: "Thrashing: 150MB > 100MB, continuous swapping"
          c: "Processes get more memory"
          d: "Disk becomes faster"
        answer: "b"
        explanation: "WS requirements (150MB) > RAM (100MB) → continuous faults."
        points: 0.75

      - id: MM17
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce Linux comandă displays memory usage?"
        answer: "free"
        accept_alternatives:
          - "free -h"
          - "cat /proc/meminfo"
          - "vmstat"
          - "top"
        points: 0.5

      - id: MM18
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce algorithm face Linux use for page replacement?"
        answer: "LRU approximation (clock)"
        accept_alternatives:
          - "LRU"
          - "Clock"
          - "Second chance"
          - "PFRA"
        points: 0.5

      - id: MM19
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce indică the 'dirty bit' in a page table entry?"
        options:
          a: "Page contains errors"
          b: "Page has been modified and must be written to disk before replacement"
          c: "Page is invalid"
          d: "Page is being accessed"
        answer: "b"
        explanation: "Dirty bit = modified. Clean pages can be discarded; dirty must be written back."
        points: 0.5

      - id: MM20
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este demand paging?"
        options:
          a: "Loading all pages at startup"
          b: "Loading pages only when they're accessed (on demand)"
          c: "Deleting unused pages"
          d: "Compressing pages"
        answer: "b"
        explanation: "Demand paging: pages loaded only when needed, not preloaded."
        points: 0.5

      - id: MM21
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este a valid bit in a page table entry?"
        options:
          a: "Page is error-free"
          b: "Page is currently in physical memory"
          c: "Page has correct permissions"
          d: "Page contains valid data"
        answer: "b"
        explanation: "Valid bit: 1 = page in RAM (legal to access), 0 = not in RAM (causes page fault)."
        points: 0.5

      - id: MM22
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        question: "De ce face TLB flushing occur on context switch?"
        options:
          a: "TLB is full"
          b: "Each process has its own address space and page table"
          c: "For security only"
          d: "It doesn't occur"
        answer: "b"
        explanation: "TLB entries are process-specific; must flush or use ASID to avoid wrong translations."
        points: 0.75

      - id: MM23
        type: multiple_choice
        difficulty: hard
        bloom: understand
        question: "Care sunt huge pages (large pages) and their advantage?"
        options:
          a: "Encrypted pages"
          b: "Larger page size (2MB/1GB) reducing TLB misses for large datasets"
          c: "Faster pages"
          d: "Compressed pages"
        answer: "b"
        explanation: "Huge pages: fewer TLB entries needed, better TLB hit rate for large memory."
        points: 0.75

      - id: MM24
        type: practical
        difficulty: hard
        bloom: apply
        question: "Dat fiind șirul de referințe 1,2,3,4,1,2,5,1,2,3,4,5 și 3 frame-uri cu LRU, câte page fault-uri?"
        options:
          a: "8"
          b: "9"
          c: "10"
          d: "12"
        answer: "c"
        explanation: "LRU trace: 1(F),2(F),3(F),4(F),1(F),2(F),5(F),1(H),2(H),3(F),4(F),5(F) = 10 faults."
        points: 1.0


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 10: FILE SYSTEMS
# Sources: Lectures 11-12
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Sisteme de fișiere"
    lectures: [11, 12]
    seminars: []
    question_count: 24
    
    questions:
      # --- Part 1: Inode, Pointers (Lecture 11) ---
      - id: FS01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L11-q01"
        question: "Ce este an inode?"
        options:
          a: "A type of processor"
          b: "Data structure storing file metadata (permissions, size, pointers to blocks)"
          c: "A directory"
          d: "A type of network"
        answer: "b"
        explanation: "Inode = index node, contains all file info EXCEPT the name."
        points: 0.5

      - id: FS02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L11-q02"
        question: "ce face an inode NOT contain?"
        options:
          a: "File permissions"
          b: "File name"
          c: "File size"
          d: "Pointers to data blocks"
        answer: "b"
        explanation: "Name is stored in directory, not inode. Inode identified by number."
        points: 0.5

      - id: FS03
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L11-q03"
        question: "Ce este a hard link?"
        options:
          a: "A copy of the file"
          b: "Directory entry pointing to same inode as another file"
          c: "A symbolic link"
          d: "A network connection"
        answer: "b"
        explanation: "Hard link = another name for same inode. File exists until link count=0."
        points: 0.5

      - id: FS04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L11-q04"
        question: "De ce do inodes use indirect pointers for large files?"
        options:
          a: "For security"
          b: "To allow any file size without increasing inode structure"
          c: "For speed"
          d: "They don't"
        answer: "b"
        explanation: "Direct: small files (fast). Indirect: large files without expanding inode."
        points: 0.5

      - id: FS05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L11-q05"
        question: "Care este diferența între hard link și symbolic link?"
        options:
          a: "Identical"
          b: "Hard: same inode. Symlink: separate file containing path"
          c: "Symlink is faster"
          d: "Hard link works across filesystems"
        answer: "b"
        explanation: "Hard: shares inode, can't cross filesystem. Symlink: independent path file."
        points: 0.5

      - id: FS06
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L11-q06"
        question: "Ce se întâmplă when deleting a file cu hard links?"
        options:
          a: "All hard links deleted"
          b: "Link count decreases; data deleted only when count=0"
          c: "File moved to Trash"
          d: "Inode duplicated"
        answer: "b"
        explanation: "Deletion decreases link count. Data remains until no links exist."
        points: 0.5

      - id: FS07
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L11-q09"
        question: "Inode: 12 direct, 1 single indirect, 1 double indirect. Block=4KB, pointer=4B. Max file size?"
        options:
          a: "48 KB"
          b: "~4 GB"
          c: "~4 TB"
          d: "12 KB"
        answer: "b"
        explanation: "Direct: 12×4KB. Single: 1024×4KB. Double: 1024×1024×4KB. Total ≈ 4GB."
        points: 0.75

      - id: FS08
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L11-q10"
        question: "De ce are journaling filesystems safer during crash?"
        options:
          a: "Faster"
          b: "Record operations in journal BEFORE applying, allowing recovery"
          c: "Use encryption"
          d: "Not safer"
        answer: "b"
        explanation: "Journaling: write-ahead logging. On crash, check journal and complete/rollback."
        points: 0.75

      # --- Part 2: Allocation, Structures (Lecture 12) ---
      - id: FS09
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L12-q01"
        question: "Care sunt the 3 main disk space allocation methods?"
        options:
          a: "Fast, slow, medium"
          b: "Contiguous, linked, indexed"
          c: "FIFO, LIFO, random"
          d: "Read, write, execute"
        answer: "b"
        explanation: "Contiguous: consecutive blocks. Linked: linked lists. Indexed: pointer table."
        points: 0.5

      - id: FS10
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L12-q02"
        question: "Ce este a bitmap in free space management?"
        options:
          a: "A graphical image"
          b: "Bit vector where each bit indicates free(0) or occupied(1) block"
          c: "Compression algorithm"
          d: "A file type"
        answer: "b"
        explanation: "Bitmap: 1 bit/block, efficient for finding consecutive free blocks."
        points: 0.5

      - id: FS11
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L12-q04"
        question: "Ce este the main advantage of contiguous allocation?"
        options:
          a: "Space efficiency"
          b: "Very fast sequential and random access (single seek)"
          c: "Easy extension"
          d: "No advantages"
        answer: "b"
        explanation: "Contiguous: single seek for any access. Disadvantage: external fragmentation."
        points: 0.5

      - id: FS12
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L12-q05"
        question: "De ce face linked allocation have slow random access?"
        options:
          a: "More secure"
          b: "Must traverse list from beginning to desired block"
          c: "Uses encryption"
          d: "Not slow"
        answer: "b"
        explanation: "For block N, must read N-1 blocks to follow pointers. O(n) vs O(1)."
        points: 0.5

      - id: FS13
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L12-q06"
        question: "ce do extents solve in modern filesystems?"
        options:
          a: "Security"
          b: "Reduces overhead for large contiguous files (stores start:length vs individual pointers)"
          c: "Increases network speed"
          d: "Automatic compression"
        answer: "b"
        explanation: "Extent = (start_block, length). 1GB contiguous: 1 extent vs thousands of pointers."
        points: 0.5

      - id: FS14
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L12-q07"
        question: "De ce is VFS useful in Linux?"
        options:
          a: "Increases speed"
          b: "Provides uniform interface for all filesystems"
          c: "Encrypts data"
          d: "Manages memory"
        answer: "b"
        explanation: "VFS: abstraction. Applications use same syscalls regardless of physical filesystem."
        points: 0.5

      - id: FS15
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L12-q08"
        question: "Ce este a mount point?"
        options:
          a: "Hardware type"
          b: "Directory where filesystem becomes accessible in hierarchy"
          c: "Boot partition"
          d: "Network server"
        answer: "b"
        explanation: "Mount: attaches filesystem to directory. /mnt/usb makes USB accessible."
        points: 0.5

      - id: FS16
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L12-q09"
        question: "Fișier de 1MB pe FAT32 cu clustere de 32KB. Câte intrări FAT?"
        options:
          a: "1"
          b: "32"
          c: "1024"
          d: "1048576"
        answer: "b"
        explanation: "1MB / 32KB = 32 clusters. Each cluster has one FAT entry."
        points: 0.75

      - id: FS17
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L12-q11"
        question: "Trade-off for large vs small block size?"
        options:
          a: "No trade-off"
          b: "Large: less overhead but more internal fragmentation. Small: opposite"
          c: "Large always better"
          d: "Small always better"
        answer: "b"
        explanation: "Large: efficient for large files, wasteful for small. Small: opposite."
        points: 0.75

      - id: FS18
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L12-q12"
        question: "SSD vs HDD filesystem features?"
        options:
          a: "Same for both"
          b: "SSD: TRIM support, no defrag. HDD: periodic defrag, write cache"
          c: "HDD: TRIM. SSD: defrag"
          d: "Storage type doesn't matter"
        answer: "b"
        explanation: "SSD: TRIM for garbage collection. HDD: defrag (seek time matters)."
        points: 0.75

      - id: FS19
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce comandă shows filesystem disk usage in Linux?"
        answer: "df"
        accept_alternatives:
          - "df -h"
          - "df -H"
        points: 0.5

      - id: FS20
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce comandă shows directory space usage?"
        answer: "du"
        accept_alternatives:
          - "du -h"
          - "du -sh"
        points: 0.5

      - id: FS21
        type: multiple_choice
        difficulty: medium
        bloom: apply
        question: "ce face 'ln -s target link' create?"
        options:
          a: "Hard link"
          b: "Symbolic link"
          c: "Copy of file"
          d: "Directory"
        answer: "b"
        explanation: "-s creates symbolic (soft) link. Without -s creates hard link."
        points: 0.5

      - id: FS22
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este the purpose of /proc in Linux?"
        options:
          a: "Store procedures"
          b: "Virtual filesystem providing process and system information"
          c: "Temporary files"
          d: "User home directories"
        answer: "b"
        explanation: "/proc = pseudo-filesystem exposing kernel/process data as files."
        points: 0.5

      - id: FS23
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce face sync command?"
        options:
          a: "Synchronises time"
          b: "Flushes filesystem buffers to disk"
          c: "Syncs files between servers"
          d: "Compares files"
        answer: "b"
        explanation: "sync forces write lui buffered data to disk, ensuring persistence."
        points: 0.5

      - id: FS24
        type: practical
        difficulty: hard
        bloom: apply
        question: "Write comandă to create ext4 filesystem on /dev/sdb1."
        answer: "mkfs.ext4 /dev/sdb1"
        accept_alternatives:
          - "mkfs -t ext4 /dev/sdb1"
          - "mke2fs -t ext4 /dev/sdb1"
        points: 1.0


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 11: SECURITY
# Sources: Lecture 13
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Securitate"
    lectures: [13]
    seminars: []
    question_count: 12
    
    questions:
      - id: SE01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L13-q01"
        question: "ce face CIA triad mean in securitate?"
        options:
          a: "Central Intelligence Agency"
          b: "Confidentiality, Integrity, Availability"
          c: "Create, Install, Activate"
          d: "Control, Inspect, Authenticate"
        answer: "b"
        explanation: "CIA: Confidentiality (authorised access), Integrity (unaltered), Availability (accessible)."
        points: 0.5

      - id: SE02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L13-q02"
        question: "ce do permissions rwxr-xr-- reprezintă?"
        options:
          a: "Everyone has full access"
          b: "Owner: rwx, Group: r-x, Others: r--"
          c: "File is encrypted"
          d: "File is executable"
        answer: "b"
        explanation: "rwx (owner=7), r-x (group=5), r-- (others=4). Octal: 754."
        points: 0.5

      - id: SE03
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L13-q03"
        question: "Ce este the SUID bit?"
        options:
          a: "A virus"
          b: "Executable runs with owner's permissions, not executor's"
          c: "A type of encryption"
          d: "A network command"
        answer: "b"
        explanation: "SUID: allows users to run programs with elevated privileges (e.g., passwd)."
        points: 0.5

      - id: SE04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L13-q04"
        question: "Difference between authentication and authorisation?"
        options:
          a: "Identical"
          b: "Authentication: WHO you are. Authorisation: WHAT you can do"
          c: "Authorisation comes first"
          d: "Authentication not necessary"
        answer: "b"
        explanation: "Authentication = identity verification. Authorisation = access control."
        points: 0.5

      - id: SE05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L13-q05"
        question: "Ce este the 'least privilege' principle?"
        options:
          a: "All users have root"
          b: "Processes receive only minimum permissions for their task"
          c: "Privileges increase automatically"
          d: "Doesn't apply"
        answer: "b"
        explanation: "Least privilege: minimises attack surface. Compromise has limited impact."
        points: 0.5

      - id: SE06
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L13-q06"
        question: "Ce este a buffer overflow?"
        options:
          a: "RAM is full"
          b: "Data exceeds buffer boundary, overwriting adjacent memory"
          c: "A type of compression"
          d: "A network error"
        answer: "b"
        explanation: "Buffer overflow: can overwrite return address, enabling code execution."
        points: 0.5

      - id: SE07
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L13-q07"
        question: "Ce este ASLR?"
        options:
          a: "An encryption algorithm"
          b: "Randomises memory positions to make exploitation harder"
          c: "A firewall"
          d: "A permission type"
        answer: "b"
        explanation: "ASLR: attacker doesn't know where data is → overflow doesn't know where to jump."
        points: 0.5

      - id: SE08
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L13-q08"
        question: "De ce face sticky bit on /tmp prevent deleting others' files?"
        options:
          a: "Encrypts files"
          b: "Only file owner or root can delete files in directory"
          c: "Compresses files"
          d: "Hides files"
        answer: "b"
        explanation: "Sticky bit (t): in world-writable dirs, prevents deletion by non-owners."
        points: 0.5

      - id: SE09
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L13-q09"
        question: "De ce face DEP/NX help prevent buffer overflow exploits?"
        options:
          a: "Encrypts memory"
          b: "Marks regions non-executable: injected data cannot run as code"
          c: "Increases speed"
          d: "Doesn't help"
        answer: "b"
        explanation: "NX: stack/heap non-executable. Shellcode can't run directly."
        points: 0.75

      - id: SE10
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L13-q10"
        question: "ce advantage face sandboxing offer?"
        options:
          a: "Increases speed"
          b: "Limits syscalls and resources, reducing compromise impact"
          c: "Saves memory"
          d: "No advantages"
        answer: "b"
        explanation: "Sandbox: compromised app can't access entire system, only permitted resources."
        points: 0.75

      - id: SE11
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L13-q11"
        question: "Main risk of SUID root programs?"
        options:
          a: "Too slow"
          b: "Any vulnerability gives attacker full root access"
          c: "Consume too much memory"
          d: "No risk"
        answer: "b"
        explanation: "Bug in SUID root = privilege escalation. Attacker gains root."
        points: 0.75

      - id: SE12
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L13-q12"
        question: "File has -rwsr-xr-x owned by root. Security risk?"
        options:
          a: "None"
          b: "SUID root: any vulnerability allows root escalation"
          c: "File corrupted"
          d: "Normal permissions"
        answer: "b"
        explanation: "SUID (s in owner execute) + root owner = execution as root. Audit carefully."
        points: 0.75


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 12: VIRTUALISATION AND CONTAINERS
# Sources: Lectures 14, 16
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Virtualizare și containere"
    lectures: [14, 16]
    seminars: []
    question_count: 22
    
    questions:
      # --- Virtualisation (Lecture 14) ---
      - id: VC01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L14-q01"
        question: "Ce este a hypervisor (VMM)?"
        options:
          a: "A type of processor"
          b: "Software care creează and manages VMs, providing hardware abstraction"
          c: "A network protocol"
          d: "A type of memory"
        answer: "b"
        explanation: "Hypervisor = layer allowing multiple OSes on same physical hardware."
        points: 0.5

      - id: VC02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L14-q02"
        question: "Difference between Type 1 and Type 2 hypervisors?"
        options:
          a: "No difference"
          b: "Type 1 (bare-metal): on hardware. Type 2 (hosted): on host OS"
          c: "Type 2 is faster"
          d: "Type 1 is software, Type 2 hardware"
        answer: "b"
        explanation: "Type 1: ESXi, Xen (performance). Type 2: VirtualBox, Workstation (convenience)."
        points: 0.5

      - id: VC03
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L14-q03"
        question: "Ce este paravirtualisation?"
        options:
          a: "Very fast virtualisation"
          b: "Guest OS modified to know it's virtualised, uses hypercalls"
          c: "Network-only virtualisation"
          d: "Hardware virtualisation"
        answer: "b"
        explanation: "Paravirtualisation: modified guest uses hypercalls instead of privileged instructions."
        points: 0.5

      - id: VC04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L14-q04"
        question: "Cum do Intel VT-x__PATH0__ help?"
        options:
          a: "Increase CPU speed"
          b: "Add ring -1 for hypervisor, enabling efficient traps"
          c: "Encrypt data"
          d: "Manage memory"
        answer: "b"
        explanation: "Hardware virtualisation: hypervisor in VMX root, guest in non-root. Fast VM exits."
        points: 0.5

      - id: VC05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L14-q05"
        question: "Ce este a shadow page table?"
        options:
          a: "A backup copy"
          b: "Hypervisor maintains guest-virtual → host-physical translation"
          c: "A type of encryption"
          d: "Not necessary"
        answer: "b"
        explanation: "Guest has its own PT. Shadow PT: guest VA→host PA for hardware MMU."
        points: 0.5

      - id: VC06
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L14-q07"
        question: "De ce are containers more lightweight than VMs?"
        options:
          a: "Not more lightweight"
          b: "Containers share host kernel; VMs each have own kernel"
          c: "Containers have no isolation"
          d: "VMs are older"
        answer: "b"
        explanation: "Container: isolated processes without full OS overhead."
        points: 0.5

      - id: VC07
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L14-q08"
        question: "ce Linux mechanisms do containers use?"
        options:
          a: "Hardware virtualisation"
          b: "Namespaces (isolation) and cgroups (limits)"
          c: "Shadow page tables"
          d: "Type 2 hypervisor"
        answer: "b"
        explanation: "Namespaces: isolate PID, network, mount. Cgroups: limit CPU, memory, I/O."
        points: 0.5

      - id: VC08
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L14-q09"
        question: "Când prefer full virtualisation over containers?"
        options:
          a: "Always"
          b: "Need different OSes or maximum isolation (security boundaries)"
          c: "Maximum performance"
          d: "Never"
        answer: "b"
        explanation: "VM: kernel isolation, different OSes. Container: same kernel, weaker isolation."
        points: 0.75

      - id: VC09
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L14-q11"
        question: "De ce is live migration possible?"
        options:
          a: "Not possible"
          b: "Memory copied incrementally while VM runs, short freeze for final state"
          c: "VM has no state"
          d: "Uses encryption"
        answer: "b"
        explanation: "Pre-copy: iterative RAM copy. Short stop, copy dirty pages, resume on new host."
        points: 0.75

      - id: VC10
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L14-q12"
        question: "Aveți 64 GB RAM și doriți 100 de instanțe izolate ale aceleiași aplicații. Ce alegeți?"
        options:
          a: "100 de mașini virtuale complete"
          b: "Containere: partajează kernel‑ul, overhead de ordinul MB per instanță (nu GB)"
          c: "100 de procese fără izolare"
          d: "Nu este posibil"
        answer: "b"
        explanation: "Containerele au overhead tipic ~10–50 MB, pe când o VM are adesea ~1 GB sau mai mult. În 64 GB RAM, 100 de containere sunt, în mod realist, fezabile."
        points: 0.75

      # --- Advanced Containerisation (Lecture 16) ---
      - id: VC11
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L16-q01"
        question: "Ce este a Linux namespace?"
        options:
          a: "A type of file"
          b: "Kernel mechanism isolating system resources for process groups"
          c: "A network protocol"
          d: "A type of memory"
        answer: "b"
        explanation: "Namespace: isolates PID, network, mount, user, IPC, cgroup, UTS."
        points: 0.5

      - id: VC12
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L16-q02"
        question: "Ce este cgroups?"
        options:
          a: "A type of container"
          b: "Kernel mechanism limiting and monitoring resources per process group"
          c: "A communication protocol"
          d: "A filesystem"
        answer: "b"
        explanation: "Cgroups: limits and accounts for CPU, memory, I/O."
        points: 0.5

      - id: VC13
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L16-q03"
        question: "ce face PID namespace isolate?"
        options:
          a: "The network"
          b: "PID space: container sees only its processes, with own PID 1"
          c: "Memory"
          d: "Files"
        answer: "b"
        explanation: "PID namespace: init (PID 1) in container. Can't see host processes."
        points: 0.5

      - id: VC14
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L16-q05"
        question: "Ce face 'unshare' command?"
        options:
          a: "Deletes files"
          b: "Creates new namespaces and executes program within them"
          c: "Shares memory"
          d: "Configures network"
        answer: "b"
        explanation: "unshare: creates namespace(s) and runs command. Basis for simple containers."
        points: 0.5

      - id: VC15
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L16-q06"
        question: "Ce este overlay filesystem and why face Docker use it?"
        options:
          a: "A type of RAID"
          b: "Layers multiple directories: read-only with writable on top"
          c: "Encrypted filesystem"
          d: "Network filesystem"
        answer: "b"
        explanation: "Overlay: image layers (ro) + container layer (rw). Efficient sharing."
        points: 0.5

      - id: VC16
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L16-q07"
        question: "De ce do rootless containers need user namespace?"
        options:
          a: "Don't need it"
          b: "Maps UID 0 in container to non-root on host, allowing safe 'root' operations"
          c: "For speed"
          d: "For networking"
        answer: "b"
        explanation: "User NS: root in container = normal user on host. Escape doesn't give root."
        points: 0.75

      - id: VC17
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L16-q08"
        question: "Security difference: container escape vs VM escape?"
        options:
          a: "No difference"
          b: "Container: shared kernel, escape = host access. VM: must break hypervisor"
          c: "VM escape is easier"
          d: "Container is more secure"
        answer: "b"
        explanation: "Container: kernel vulnerability = host access. VM: hardware isolation."
        points: 0.75

      - id: VC18
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L16-q10"
        question: "Limitați container-ul la 512MB RAM și 0.5 CPU. Ce controllere cgroup?"
        options:
          a: "Only memory"
          b: "memory controller for RAM, cpu controller for quota"
          c: "Only cpu"
          d: "Cannot limit"
        answer: "b"
        explanation: "memory.max=512M, cpu.max=50000 100000 (50% of one core)."
        points: 0.75

      - id: VC19
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce comandă lists running Docker containers?"
        answer: "docker ps"
        accept_alternatives:
          - "docker container ls"
        points: 0.5

      - id: VC20
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce comandă enters a running container's shell?"
        answer: "docker exec -it container_name /bin/bash"
        accept_alternatives:
          - "docker exec -it container_name bash"
          - "docker exec -it container_name sh"
        points: 0.5

      - id: VC21
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este a container image?"
        options:
          a: "A running container"
          b: "Read-only template containing application and dependencies"
          c: "A virtual machine"
          d: "A network configuration"
        answer: "b"
        explanation: "Image = template. Container = running instance of image with writable layer."
        points: 0.5

      - id: VC22
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "Ce este Kubernetes?"
        options:
          a: "A container runtime"
          b: "Container orchestration platform for managing containerised workloads"
          c: "A hypervisor"
          d: "A Linux distribution"
        answer: "b"
        explanation: "K8s: orchestrates deployment, scaling, and management of containers."
        points: 0.5


# ═══════════════════════════════════════════════════════════════════════════════
# CATEGORY 13: NETWORKING AND ADVANCED TOPICS
# Sources: Lectures 15, 17, 18
# ═══════════════════════════════════════════════════════════════════════════════

  - name: "Rețelistică și subiecte avansate"
    lectures: [15, 17, 18]
    seminars: []
    question_count: 20
    
    questions:
      # --- Network (Lecture 15) ---
      - id: NA01
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L15-q01"
        question: "Ce este a socket in network programming?"
        options:
          a: "A network cable"
          b: "Communication endpoint: IP + port combination"
          c: "A type of server"
          d: "An encryption protocol"
        answer: "b"
        explanation: "Socket = OS abstraction for network communication, identified by IP:port."
        points: 0.5

      - id: NA02
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L15-q02"
        question: "Main difference between TCP and UDP?"
        options:
          a: "TCP is older"
          b: "TCP: connection-oriented, reliable. UDP: connectionless, best-effort"
          c: "UDP is more secure"
          d: "No difference"
        answer: "b"
        explanation: "TCP: ordered delivery. UDP: fast, no guarantees (streaming, gaming)."
        points: 0.5

      - id: NA03
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L15-q03"
        question: "ce face bind() face în socket API?"
        options:
          a: "Connects to server"
          b: "Associates socket with local IP and port"
          c: "Sends data"
          d: "Closes connection"
        answer: "b"
        explanation: "bind(): server specifies which IP:port to listen on."
        points: 0.5

      - id: NA04
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L15-q04"
        question: "De ce face TCP server call listen() and accept()?"
        options:
          a: "To send data"
          b: "listen(): marks passive. accept(): accepts connections, creates new socket per client"
          c: "For encryption"
          d: "To close connection"
        answer: "b"
        explanation: "listen(): sets up queue. accept(): blocks until client, returns new socket."
        points: 0.5

      - id: NA05
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L15-q05"
        question: "Ce este I/O multiplexing with select()/poll()/epoll()?"
        options:
          a: "Creating threads"
          b: "Single thread monitors multiple sockets for I/O events"
          c: "Data compression"
          d: "Connection encryption"
        answer: "b"
        explanation: "Multiplexing: one thread handles thousands of connections efficiently."
        points: 0.5

      - id: NA06
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L15-q07"
        question: "Server handles 10,000 connections. Most suitable model?"
        options:
          a: "One thread per connection"
          b: "Event-driven with epoll and small worker pool"
          c: "One process per connection"
          d: "Sequential processing"
        answer: "b"
        explanation: "10K threads = large overhead. Event loop with epoll: efficient, scalable."
        points: 0.75

      - id: NA07
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L15-q10"
        question: "Writing a chat server. Problem with partial messages on TCP?"
        options:
          a: "TCP guarantees complete messages"
          b: "TCP is stream-based: need framing protocol (length prefix or delimiter)"
          c: "Use UDP instead"
          d: "No problems"
        answer: "b"
        explanation: "TCP: stream of bytes. recv() may return partial. Implement framing."
        points: 0.75

      # --- Kernel Programming (Lecture 17) ---
      - id: NA08
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L17-q01"
        question: "Ce este a kernel module?"
        options:
          a: "A type of application"
          b: "Code loadable into kernel at runtime without recompiling"
          c: "A configuration file"
          d: "A network protocol"
        answer: "b"
        explanation: "Kernel module: extends functionality (drivers, filesystems) dynamically."
        points: 0.5

      - id: NA09
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L17-q02"
        question: "Commands to manage kernel modules?"
        options:
          a: "apt install/remove"
          b: "insmod, rmmod, modprobe, lsmod"
          c: "mount, umount"
          d: "start, stop"
        answer: "b"
        explanation: "insmod: load. rmmod: unload. modprobe: with dependencies. lsmod: list."
        points: 0.5

      - id: NA10
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L17-q05"
        question: "De ce can't you use printf() in kernel?"
        options:
          a: "Too slow"
          b: "printf() is from libc (userspace). Kernel uses printk()"
          c: "Kernel has no output"
          d: "printf() deprecated"
        answer: "b"
        explanation: "Kernel lacks libc. printk(KERN_INFO ...) writes to kernel log (dmesg)."
        points: 0.5

      - id: NA11
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L17-q07"
        question: "De ce prefer spinlocks over mutexes in interrupt handlers?"
        options:
          a: "Safer"
          b: "Mutexes can sleep; in interrupt context you cannot sleep"
          c: "Spinlocks slower"
          d: "No difference"
        answer: "b"
        explanation: "Interrupt: no process context, cannot sleep. Spinlock: busy-wait, OK for short."
        points: 0.75

      - id: NA12
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L17-q08"
        question: "Ce este eBPF and why revolutionary?"
        options:
          a: "A firewall"
          b: "Allows custom code in kernel safely (sandbox) without traditional modules"
          c: "A network protocol"
          d: "A filesystem"
        answer: "b"
        explanation: "eBPF: verified program, sandbox in kernel. Tracing, networking without crash risk."
        points: 0.75

      - id: NA13
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L17-q10"
        question: "Înregistrați handler pentru întrerupere hardware. Ce funcție kernel?"
        options:
          a: "malloc()"
          b: "request_irq()"
          c: "printf()"
          d: "fork()"
        answer: "b"
        explanation: "request_irq(irq, handler, flags, name, dev_id) registers IRQ handler."
        points: 0.75

      # --- NPU Integration (Lecture 18) ---
      - id: NA14
        type: multiple_choice
        difficulty: easy
        bloom: remember
        source: "L18-q01"
        question: "Ce este an NPU?"
        options:
          a: "A type of RAM"
          b: "Specialised processor for ML/AI operations"
          c: "A network protocol"
          d: "A storage type"
        answer: "b"
        explanation: "NPU: hardware optimised for AI inference, energy-efficient for ML."
        points: 0.5

      - id: NA15
        type: multiple_choice
        difficulty: medium
        bloom: understand
        source: "L18-q03"
        question: "De ce are NPUs more energy-efficient than CPUs for AI?"
        options:
          a: "Not more efficient"
          b: "Specialised architecture: many parallel MAC units without general-purpose overhead"
          c: "Use less memory"
          d: "Newer"
        answer: "b"
        explanation: "NPU: thousands of MAC units optimised for tensor ops. CPU: general overhead."
        points: 0.5

      - id: NA16
        type: multiple_choice
        difficulty: hard
        bloom: analyse
        source: "L18-q07"
        question: "Când prefer CPU vs NPU for AI inference?"
        options:
          a: "Always NPU"
          b: "NPU: large models, batch, efficiency. CPU: small models, minimal latency"
          c: "Always CPU"
          d: "Doesn't matter"
        answer: "b"
        explanation: "NPU: throughput, efficiency. CPU: transfer overhead can exceed benefit for small."
        points: 0.75

      - id: NA17
        type: multiple_choice
        difficulty: hard
        bloom: apply
        source: "L18-q10"
        question: "Un laptop rulează inferență AI continuă. De ce ați prefera un NPU în locul unui GPU?"
        options:
          a: "GPU este întotdeauna mai bun"
          b: "NPU: consum mai mic (≈1–5 W vs ≈15–50 W), autonomie mai bună, mai puțin throttling termic"
          c: "NPU este întotdeauna mai rapid"
          d: "GPU‑ul nu poate face AI"
        answer: "b"
        explanation: "Într‑un laptop, GPU‑ul este limitat de consum și temperatură. Un NPU este optimizat pentru eficiență energetică și poate susține inferența cu consum redus, prelungind autonomia și reducând throttling‑ul termic."
        points: 0.75

      - id: NA18
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce comandă shows network interfaces in Linux?"
        answer: "ip addr"
        accept_alternatives:
          - "ip a"
          - "ifconfig"
          - "ip link"
        points: 0.5

      - id: NA19
        type: short_answer
        difficulty: medium
        bloom: apply
        question: "ce comandă shows listening ports?"
        answer: "ss -tuln"
        accept_alternatives:
          - "netstat -tuln"
          - "ss -l"
          - "lsof -i"
        points: 0.5

      - id: NA20
        type: multiple_choice
        difficulty: medium
        bloom: understand
        question: "La ce se folosește a network namespace?"
        options:
          a: "File isolation"
          b: "Creating isolated network stacks (interfaces, routing, firewall)"
          c: "Memory isolation"
          d: "Process isolation"
        answer: "b"
        explanation: "Network NS: container/process has own network stack, IP, routing."
        points: 0.5


# ═══════════════════════════════════════════════════════════════════════════════
# END OF CONSOLIDATED QUESTION POOL
# ═══════════════════════════════════════════════════════════════════════════════
# 
# Total: 256 questions across 13 categories
# Ready for test generation with test_generator.py
# ═══════════════════════════════════════════════════════════════════════════════
