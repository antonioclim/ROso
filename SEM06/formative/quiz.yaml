# ═══════════════════════════════════════════════════════════════════════════════
# quiz.yaml — Quiz Formativ CAPSTONE SEM06
# ═══════════════════════════════════════════════════════════════════════════════
# Sisteme de Operare | ASE București - CSIE
# Seminar 6: Proiecte Integrate (Monitor, Backup, Deployer)
# Versiune: 1.0.0 | Ianuarie 2025
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  seminar: 6
  titlu: "CAPSTONE: Proiecte Integrate Bash"
  versiune: "1.0.0"
  limba: "ro"
  timp_estimat_minute: 25
  punctaj_total: 100
  prag_promovare: 60
  
  distributie_bloom:
    remember: 3      # 17%
    understand: 5    # 28%
    apply: 6         # 33%
    analyse: 2       # 11%
    evaluate: 2      # 11%
  
  subiecte:
    - "Arhitectură modulară Bash"
    - "Error handling și trap"
    - "Logging profesional"
    - "Backup incremental"
    - "Deployment strategies"
    - "Health checks"
    - "Testing în Bash"

# ═══════════════════════════════════════════════════════════════════════════════
# ÎNTREBĂRI
# ═══════════════════════════════════════════════════════════════════════════════

intrebari:

  # ─────────────────────────────────────────────────────────────────────────────
  # REMEMBER (3 întrebări) - 15%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q01
    tip: mcq
    bloom: remember
    puncte: 5
    subiect: "Error handling"
    text: |
      Care comandă setează comportamentul strict în Bash pentru a opri
      execuția la prima eroare, variabile nedefinite și erori în pipe?
    optiuni:
      a: "set -e"
      b: "set -euo pipefail"
      c: "set -x"
      d: "set -v"
    corect: b
    explicatie: |
      `set -euo pipefail` combină:
      - `-e`: oprește la prima eroare (exit code != 0)
      - `-u`: eroare la variabile nedefinite
      - `-o pipefail`: pipe-ul returnează eroarea primei comenzi care eșuează
    misconceptii:
      a: "Doar -e oprește la erori, dar nu detectează variabile nedefinite"
      c: "-x activează debug mode (print comenzi), nu error handling"
      d: "-v afișează liniile citite, nu gestionează erori"

  - id: q02
    tip: mcq
    bloom: remember
    puncte: 5
    subiect: "Trap și semnale"
    text: |
      Care semnal este trimis unui proces când utilizatorul apasă Ctrl+C?
    optiuni:
      a: "SIGTERM"
      b: "SIGKILL"
      c: "SIGINT"
      d: "SIGHUP"
    corect: c
    explicatie: |
      SIGINT (Signal Interrupt) este trimis de terminal când utilizatorul
      apasă Ctrl+C. Poate fi capturat cu `trap` pentru cleanup.
    misconceptii:
      a: "SIGTERM este semnalul default al comenzii kill, nu Ctrl+C"
      b: "SIGKILL nu poate fi capturat și termină imediat procesul"
      d: "SIGHUP este trimis când terminalul se închide"

  - id: q03
    tip: mcq
    bloom: remember
    puncte: 5
    subiect: "Exit codes"
    text: |
      Ce exit code indică execuție reușită în convenția Unix?
    optiuni:
      a: "1"
      b: "-1"
      c: "0"
      d: "255"
    corect: c
    explicatie: |
      Convenția Unix: exit code 0 = succes, orice altceva = eroare.
      Verifici cu `$?` sau direct în condiții: `if command; then ...`
    misconceptii:
      a: "1 indică eroare generică"
      b: "Exit codes sunt 0-255, -1 nu e valid"
      d: "255 indică eroare, nu succes"

  # ─────────────────────────────────────────────────────────────────────────────
  # UNDERSTAND (5 întrebări) - 28%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q04
    tip: mcq
    bloom: understand
    puncte: 6
    subiect: "Arhitectură modulară"
    text: |
      De ce separăm codul în lib/core.sh, lib/utils.sh, lib/config.sh
      în loc să scriem totul într-un singur fișier?
    optiuni:
      a: "Pentru că Bash nu permite fișiere mai mari de 1000 linii"
      b: "Pentru reutilizare, testare izolată și mentenanță ușoară"
      c: "Pentru că `source` funcționează doar cu fișiere mici"
      d: "Pentru a face scriptul mai greu de înțeles de alții"
    corect: b
    explicatie: |
      Arhitectura modulară oferă:
      - Reutilizare: funcțiile din utils.sh pot fi folosite în mai multe proiecte
      - Testare: poți testa fiecare modul independent
      - Mentenanță: modificările într-un modul nu afectează altele
      - Claritate: fiecare fișier are o responsabilitate clară
    misconceptii:
      a: "Bash nu are limite de dimensiune pentru fișiere"
      c: "`source` funcționează cu fișiere de orice dimensiune"
      d: "Modularizarea crește claritatea, nu o reduce"

  - id: q05
    tip: mcq
    bloom: understand
    puncte: 6
    subiect: "Backup incremental"
    text: |
      Cum funcționează un backup incremental față de unul full?
    optiuni:
      a: "Copiază toate fișierele la fiecare rulare"
      b: "Copiază doar fișierele modificate de la ultimul backup"
      c: "Comprimă fișierele mai mult decât backup-ul full"
      d: "Șterge fișierele vechi automat"
    corect: b
    explicatie: |
      Backup incremental:
      - Folosește `find -newer timestamp_file` pentru a găsi fișiere modificate
      - Economisește timp și spațiu copiind doar schimbările
      - Necesită backup full periodic ca bază
      - Restore-ul necesită full + toate incrementalele
    misconceptii:
      a: "Aceasta e definiția backup-ului full"
      c: "Compresia nu definește tipul de backup"
      d: "Rotația/ștergerea e separată de tipul de backup"

  - id: q06
    tip: mcq
    bloom: understand
    puncte: 6
    subiect: "Health checks"
    text: |
      Ce verifică un health check HTTP pentru o aplicație web?
    optiuni:
      a: "Dacă portul 22 SSH este deschis"
      b: "Dacă aplicația răspunde cu cod 2xx la un endpoint specific"
      c: "Dacă CPU-ul serverului este sub 50%"
      d: "Dacă utilizatorul admin poate face login"
    corect: b
    explicatie: |
      Health check HTTP:
      - Trimite request GET la un endpoint (ex: /health, /status)
      - Verifică răspuns HTTP 2xx (200, 201, etc.)
      - Opțional verifică și conținutul răspunsului (JSON cu status)
      - Este diferit de monitorizarea resurselor sistem
    misconceptii:
      a: "SSH e pentru administrare, nu pentru health check aplicație"
      c: "Monitorizarea CPU e separată de health check-ul aplicației"
      d: "Autentificarea e funcționalitate, nu health check"

  - id: q07
    tip: mcq
    bloom: understand
    puncte: 6
    subiect: "Logging"
    text: |
      Care este ordinea corectă a nivelurilor de logging de la cel mai
      puțin sever la cel mai sever?
    optiuni:
      a: "ERROR, WARN, INFO, DEBUG"
      b: "DEBUG, INFO, WARN, ERROR"
      c: "INFO, DEBUG, ERROR, WARN"
      d: "WARN, ERROR, DEBUG, INFO"
    corect: b
    explicatie: |
      Ordinea standard a nivelurilor de logging:
      DEBUG < INFO < WARN < ERROR < FATAL
      - DEBUG: informații detaliate pentru debugging
      - INFO: evenimente normale de execuție
      - WARN: situații neașteptate dar recuperabile
      - ERROR: erori care afectează funcționalitatea
    misconceptii:
      a: "Ordinea este inversată"
      c: "DEBUG este mai puțin sever decât INFO"
      d: "Ordinea este complet incorectă"

  - id: q08
    tip: mcq
    bloom: understand
    puncte: 6
    subiect: "Deployment strategies"
    text: |
      Care este avantajul principal al strategiei Blue-Green deployment?
    optiuni:
      a: "Necesită mai puțină memorie decât Rolling deployment"
      b: "Permite rollback instant prin switch de traffic"
      c: "Nu necesită load balancer"
      d: "Funcționează fără downtime niciodată"
    corect: b
    explicatie: |
      Blue-Green deployment:
      - Două medii identice: Blue (activ) și Green (nou)
      - Deploy-ul se face pe Green în timp ce Blue servește traficul
      - Switch-ul de traffic este instant (DNS sau load balancer)
      - Rollback = switch înapoi la Blue, care e încă funcțional
    misconceptii:
      a: "Blue-Green necesită dublul resurselor"
      c: "Switch-ul de traffic necesită load balancer sau DNS"
      d: "Switch-ul în sine poate cauza micro-downtime"

  # ─────────────────────────────────────────────────────────────────────────────
  # APPLY (6 întrebări) - 33%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q09
    tip: mcq
    bloom: apply
    puncte: 6
    subiect: "Trap cleanup"
    text: |
      Care este sintaxa corectă pentru a executa funcția `cleanup`
      la terminarea scriptului (normal sau prin Ctrl+C)?
    optiuni:
      a: "trap cleanup EXIT SIGINT"
      b: "trap 'cleanup' EXIT INT"
      c: "on_exit cleanup"
      d: "finally { cleanup }"
    corect: b
    explicatie: |
      Sintaxa corectă `trap`:
      - `trap 'comandă' SEMNALE...`
      - EXIT = la terminare normală sau exit
      - INT = SIGINT (Ctrl+C) - fără prefixul SIG
      - Ghilimelele simple previn expansiunea prematură
    misconceptii:
      a: "SIGINT nu e valid, se folosește INT"
      c: "on_exit nu există în Bash standard"
      d: "finally e din alte limbaje, nu Bash"

  - id: q10
    tip: mcq
    bloom: apply
    puncte: 6
    subiect: "Find cu timestamp"
    text: |
      Care comandă găsește fișierele modificate după timestamp.txt?
    optiuni:
      a: "find /data -newer timestamp.txt -type f"
      b: "find /data -mtime +timestamp.txt"
      c: "find /data --after timestamp.txt"
      d: "find /data -modified > timestamp.txt"
    corect: a
    explicatie: |
      `find -newer`:
      - Compară mtime al fișierelor cu mtime al fișierului de referință
      - Returnează fișierele modificate DUPĂ referință
      - Esențial pentru backup incremental
      - `-type f` filtrează doar fișiere regulate
    misconceptii:
      b: "-mtime folosește zile, nu fișier de referință"
      c: "--after nu e opțiune validă pentru find"
      d: "Sintaxă invalidă, redirecționare greșită"

  - id: q11
    tip: mcq
    bloom: apply
    puncte: 6
    subiect: "Funcții cu return"
    text: |
      Cum returnezi o valoare numerică dintr-o funcție Bash?
    optiuni:
      a: "return $valoare unde valoare e 0-255"
      b: "echo $valoare și capturezi cu $(funcție)"
      c: "Ambele metode sunt corecte, pentru scopuri diferite"
      d: "export RESULT=$valoare"
    corect: c
    explicatie: |
      Bash oferă două metode:
      - `return N`: setează exit code (0-255), verifici cu $?
      - `echo valoare`: output capturat cu $(funcție)
      
      Folosește `return` pentru status (succes/eroare),
      `echo` pentru valori (string, numere mari, output complex).
    misconceptii:
      a: "Corect dar incomplet - funcționează doar pentru 0-255"
      b: "Corect dar incomplet - doar pentru valori, nu status"
      d: "Export modifică environment, nu e pattern pentru return"

  - id: q12
    tip: mcq
    bloom: apply
    puncte: 6
    subiect: "Verificare HTTP"
    text: |
      Care comandă verifică dacă un server web răspunde cu succes?
    optiuni:
      a: "ping localhost:8080"
      b: "curl -sf http://localhost:8080/health"
      c: "wget --check localhost:8080"
      d: "nc -z localhost 8080"
    corect: b
    explicatie: |
      `curl -sf`:
      - `-s`: silent (fără progress bar)
      - `-f`: fail silently pe erori HTTP (returnează exit code != 0)
      - Verifică răspuns HTTP real, nu doar conexiune TCP
      
      `nc -z` verifică doar dacă portul e deschis, nu răspunsul HTTP.
    misconceptii:
      a: "ping verifică ICMP, nu HTTP, și nu acceptă port"
      c: "--check nu e opțiune validă wget"
      d: "nc -z verifică doar port TCP deschis, nu HTTP"

  - id: q13
    tip: mcq
    bloom: apply
    puncte: 6
    subiect: "Arrays în Bash"
    text: |
      Care sintaxă iterează corect peste elementele unui array?
    optiuni:
      a: 'for item in $ARRAY; do'
      b: 'for item in ${ARRAY[@]}; do'
      c: 'for item in "${ARRAY[@]}"; do'
      d: 'foreach item in ARRAY; do'
    corect: c
    explicatie: |
      `"${ARRAY[@]}"` - forma corectă:
      - `[@]` expandează toate elementele
      - Ghilimelele duble păstrează elementele cu spații ca unități
      - Fără ghilimele, "hello world" devine două elemente
    misconceptii:
      a: "$ARRAY fără [@] returnează doar primul element"
      b: "Fără ghilimele, spațiile din elemente cauzează probleme"
      d: "foreach nu există în Bash"

  - id: q14
    tip: mcq
    bloom: apply
    puncte: 6
    subiect: "Checksum verificare"
    text: |
      Care comandă verifică integritatea unui backup folosind checksum?
    optiuni:
      a: "md5sum -c backup.md5"
      b: "sha256sum backup.tar.gz"
      c: "diff backup.md5 backup.tar.gz"
      d: "cmp --checksum backup.tar.gz"
    corect: a
    explicatie: |
      `md5sum -c file.md5`:
      - `-c` (check) citește fișierul cu hash-uri și verifică fiecare
      - Formatul: "hash  filename" (două spații)
      - Returnează exit code 0 dacă toate verificările trec
      
      Fără `-c`, doar calculează hash-ul, nu verifică.
    misconceptii:
      b: "Calculează hash, nu verifică unul existent"
      c: "diff compară conținut, nu verifică checksum"
      d: "--checksum nu e opțiune validă pentru cmp"

  # ─────────────────────────────────────────────────────────────────────────────
  # ANALYSE (2 întrebări) - 11%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q15
    tip: mcq
    bloom: analyse
    puncte: 8
    subiect: "Debug script"
    text: |
      Un script de backup afișează "Backup completed" dar fișierul
      arhivă este gol. Care e cea mai probabilă cauză?
      
      ```bash
      tar czf "$BACKUP_FILE" "$SOURCE_DIR" 2>/dev/null
      echo "Backup completed"
      ```
    optiuni:
      a: "Comanda tar a eșuat dar eroarea a fost suprimată"
      b: "echo nu funcționează după tar"
      c: "BACKUP_FILE nu e definit"
      d: "SOURCE_DIR conține doar directoare goale"
    corect: a
    explicatie: |
      `2>/dev/null` suprimă stderr, ascunzând erorile tar:
      - Poate fi eroare de permisiuni pe SOURCE_DIR
      - SOURCE_DIR poate fi un path invalid
      - Fără `set -e`, scriptul continuă după erori
      
      Fix: elimină `2>/dev/null` sau verifică `$?` după tar.
    misconceptii:
      b: "echo funcționează independent de comenzile anterioare"
      c: "BACKUP_FILE nedefinit ar cauza eroare la tar, nu arhivă goală"
      d: "tar ar include directoarele, chiar goale"

  - id: q16
    tip: mcq
    bloom: analyse
    puncte: 8
    subiect: "Race condition"
    text: |
      De ce acest pattern pentru PID file poate cauza probleme?
      
      ```bash
      if [[ ! -f "$PID_FILE" ]]; then
          echo $$ > "$PID_FILE"
      fi
      ```
    optiuni:
      a: "$$ nu conține PID-ul corect"
      b: "Două instanțe pot verifica simultan și ambele scriu"
      c: "PID_FILE trebuie să fie în /var/run"
      d: "Echo nu poate scrie în fișiere"
    corect: b
    explicatie: |
      Race condition (TOCTOU - Time Of Check To Time Of Use):
      - Instanța A verifică: fișierul nu există
      - Instanța B verifică: fișierul nu există
      - Ambele scriu PID-ul lor
      
      Fix: folosește `mkdir` atomic sau `flock`:
      ```bash
      exec 200>"$LOCK_FILE"
      flock -n 200 || exit 1
      ```
    misconceptii:
      a: "$$ conține corect PID-ul procesului curent"
      c: "Locația nu afectează race condition"
      d: "echo poate scrie în fișiere cu redirecționare"

  # ─────────────────────────────────────────────────────────────────────────────
  # EVALUATE (2 întrebări) - 11%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q17
    tip: mcq
    bloom: evaluate
    puncte: 8
    subiect: "Deployment strategy"
    text: |
      Pentru o aplicație care necesită zero downtime și rollback instant,
      dar ai resurse limitate (nu poți dubla infrastructura), care
      strategie e cea mai potrivită?
    optiuni:
      a: "Blue-Green deployment"
      b: "Rolling deployment"
      c: "Recreate deployment"
      d: "Big bang deployment"
    corect: b
    explicatie: |
      Rolling deployment:
      - Înlocuiește instanțele una câte una
      - Nu necesită dublul resurselor (vs Blue-Green)
      - Zero downtime (mereu există instanțe active)
      - Rollback posibil dar nu instant (trebuie re-deploy)
      
      Trade-off: rollback mai lent, dar economie de resurse.
    misconceptii:
      a: "Blue-Green necesită dublul infrastructurii"
      c: "Recreate oprește totul înainte de deploy - downtime"
      d: "Big bang nu oferă zero downtime"

  - id: q18
    tip: mcq
    bloom: evaluate
    puncte: 8
    subiect: "Alegere compresie"
    text: |
      Pentru backup-uri zilnice pe un server cu CPU limitat dar
      spațiu de stocare suficient, care algoritm de compresie alegi?
    optiuni:
      a: "xz (cel mai bun ratio de compresie)"
      b: "gzip (echilibru viteză/compresie)"
      c: "zstd (rapid cu compresie bună)"
      d: "Fără compresie (cel mai rapid)"
    corect: c
    explicatie: |
      zstd oferă cel mai bun trade-off:
      - Viteză comparabilă cu gzip sau mai rapidă
      - Compresie mai bună decât gzip
      - CPU usage mult mai mic decât xz
      - Suport nativ în tar modern (`tar --zstd`)
      
      xz ar folosi prea mult CPU pentru backup-uri frecvente.
    misconceptii:
      a: "xz e lent și consumă mult CPU"
      b: "gzip e ok dar zstd e superior în ambele aspecte"
      d: "Fără compresie risipește spațiu inutil"

# ═══════════════════════════════════════════════════════════════════════════════
# CONFIGURARE RUNNER
# ═══════════════════════════════════════════════════════════════════════════════

configurare:
  afiseaza_explicatii: true
  afiseaza_misconceptii: true
  ordine_aleatoare: false
  permite_revenire: true
  timp_limita: false
  
  mesaje:
    bun_venit: "Quiz CAPSTONE - Proiecte Integrate Bash"
    final_pass: "Ai demonstrat înțelegerea conceptelor CAPSTONE!"
    final_fail: "Revizuiește materialele și încearcă din nou."
    
  feedback_nivel:
    90: "Excelent! Ești pregătit pentru proiecte avansate."
    75: "Bine! Consolidează conceptele de deployment."
    60: "Suficient. Focusează-te pe error handling și testing."
    0: "Necesită studiu suplimentar. Începe cu arhitectura modulară."
