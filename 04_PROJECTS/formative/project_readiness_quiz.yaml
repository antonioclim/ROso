# Chestionar de Pregătire pentru Proiect
# Evaluare Formativă pentru verificarea pregătirii studenților înainte de proiecte
# Format: YAML pentru parsare ușoară și integrare cu sistemele de evaluare

quiz:
  title: "Verificare Pregătire Proiect SO - SEM-PROJ"
  description: |
    Acest chestionar verifică dacă ai cunoștințele necesare pentru a începe
    lucrul la proiectul de semestru. Parcurge întrebările pentru a te
    autoevalua. Scor recomandat: minimum 70%.
  passing_score: 70
  time_limit_minutes: 30
  
sections:
  - name: "Fundamente Bash"
    weight: 25
    questions:
      - id: bash_01
        type: multiple_choice
        difficulty: easy
        question: |
          What is the difference between `$var` and `${var}`?
        options:
          a: "Nu există nicio diferență"
          b: "${var} allows concatenation and manipulations (e.g. ${var}_suffix)"
          c: "$var is pentru numere, ${var} pentru șiruri"
          d: "${var} este învechit"
        correct: b
        explanation: |
          `${var}` allows clear delimitation of the variable name and operations
          such as ${var:-default}, ${var%pattern}, ${var#prefix}.
          
      - id: bash_02
        type: multiple_choice
        difficulty: easy
        question: |
          What does the line `set -euo pipefail` do at the beginning of a script?
        options:
          a: "Sets environment variables"
          b: "Stops the script on errors, undefined variables and pipeline errors"
          c: "Activates debug mode"
          d: "Disables glob expansion"
        correct: b
        explanation: |
          -e: exit on error, -u: error on undefined variable,
          -o pipefail: pipeline fails if any command fails.
          Aceasta este o bună practică pentru scripturi robuste.
          
      - id: bash_03
        type: multiple_choice
        difficulty: medium
        question: |
          What is the output of the following code?
          ```bash
          arr=(a b c d)
          echo ${#arr[@]}
          ```
        options:
          a: "a b c d"
          b: "4"
          c: "abcd"
          d: "Error: syntax error"
        correct: b
        explanation: |
          ${#arr[@]} returnează numărul de elemente in the array.
          ${arr[@]} returnează toate elementele, ${arr[0]} primul element.
          
      - id: bash_04
        type: multiple_choice
        difficulty: medium
        question: |
          How do you read a file line by line in a while loop, correctly?
        options:
          a: "for line in $(cat file); do"
          b: "while read line; do ... done < file"
          c: "cat file | while read line; do"
          d: "Both b and c are correct"
        correct: b
        explanation: |
          Option b este preferată. Option c creează un subshell,
          so variables set in the loop do not persist. Option a
          performs word splitting and breaks lines at spaces.
          
      - id: bash_05
        type: code_completion
        difficulty: hard
        question: |
          Complete the code to process options with getopts:
          ```bash
          while getopts "v:o:h" opt; do
              case $opt in
                  v) VERBOSE=________ ;;
                  o) OUTPUT=________ ;;
                  h) show_help; exit 0 ;;
                  *) echo "Invalid option"; exit 1 ;;
              esac
          done
          ```
        answer: ["$OPTARG", "$OPTARG"]
        explanation: |
          $OPTARG contains the argument value for options
          that require arguments (those followed by : in optstring).

  - name: "Comenzi și Utilitare"
    weight: 25
    questions:
      - id: cmd_01
        type: multiple_choice
        difficulty: easy
        question: |
          Which command finds all .log files modified in the last 24 hours?
        options:
          a: "find . -name '*.log' -mtime -1"
          b: "find . -name '*.log' -mtime 1"
          c: "find . -name '*.log' -mmin -1440"
          d: "Both a and c"
        correct: d
        explanation: |
          -mtime -1 means modified in less than 1 day.
          -mmin -1440 means modified in less than 1440 minutes (24 hours).
          -mtime 1 (without minus) means exactly between 1 and 2 days.
          
      - id: cmd_02
        type: multiple_choice
        difficulty: medium
        question: |
          Which command extracts column 3 from a CSV with delimiter ','?
        options:
          a: "cut -d, -f3 file.csv"
          b: "awk -F, '{print $3}' file.csv"
          c: "sed 's/.*,\\([^,]*\\),.*/\\1/' file.csv"
          d: "Both a and b are correct"
        correct: d
        explanation: |
          cut -d, -f3 and awk -F, '{print $3}' do the same thing.
          AWK is more flexible for complex processing.
          
      - id: cmd_03
        type: multiple_choice
        difficulty: medium
        question: |
          What does the command `grep -v '^#' file | grep -v '^$'` do?
        options:
          a: "Displays only comments"
          b: "Removes comments and empty lines"
          c: "Counts lines with #"
          d: "Replaces # with space"
        correct: b
        explanation: |
          -v inverts the match. ^# matches lines starting with #.
          ^$ matches empty lines. Result: lines that are not comments
          and are not empty - useful for configuration parsing.
          
      - id: cmd_04
        type: multiple_choice
        difficulty: hard
        question: |
          Which command sorts processes by memory usage (descending)?
        options:
          a: "ps aux --sort=-rss"
          b: "ps aux | sort -k4 -n -r"
          c: "top -o %MEM"
          d: "All are correct"
        correct: d
        explanation: |
          ps aux --sort=-rss sorts directly.
          sort -k4 -n -r sorts column 4 numerically descending.
          top -o %MEM sorts in the interface.
          
      - id: cmd_05
        type: code_completion
        difficulty: hard
        question: |
          Complete to find duplicate files by MD5 hash:
          ```bash
          find . -type f -exec md5sum {} \; | ________ | ________ | cut -d' ' -f2-
          ```
        answer: ["sort", "uniq -d -w32"]
        explanation: |
          sort: sorts by hash to group duplicates.
          uniq -d -w32: displays only duplicates, comparing the first 32 characters (the MD5 hash).

  - name: "Processes and System"
    weight: 25
    questions:
      - id: proc_01
        type: multiple_choice
        difficulty: easy
        question: |
          Which signal is sent by default by `kill <pid>`?
        options:
          a: "SIGKILL (9)"
          b: "SIGTERM (15)"
          c: "SIGHUP (1)"
          d: "SIGINT (2)"
        correct: b
        explanation: |
          SIGTERM (15) is the default and allows the process to perform cleanup.
          SIGKILL (9) forces termination without cleanup.
          SIGHUP is for "hang up", SIGINT for Ctrl+C.
          
      - id: proc_02
        type: multiple_choice
        difficulty: medium
        question: |
          How do you run a command in the background and detach it from the terminal?
        options:
          a: "command &"
          b: "nohup command &"
          c: "command & disown"
          d: "Both b and c"
        correct: d
        explanation: |
          nohup prevents SIGHUP when the terminal closes.
          disown removes the job from the shell's list.
          Both allow the command to continue after logout.
          
      - id: proc_03
        type: multiple_choice
        difficulty: medium
        question: |
          What information does the /proc/[pid]/status file provide?
        options:
          a: "Only PID and PPID"
          b: "Process state, memory, threads, capabilities"
          c: "Only CPU usage"
          d: "Process command history"
        correct: b
        explanation: |
          /proc/[pid]/status contains: State, Pid, PPid, Uid, Gid,
          VmSize, VmRSS, Threads, and many more.
          It is a complete source of information about the process.
          
      - id: proc_04
        type: multiple_choice
        difficulty: hard
        question: |
          What is the difference between a zombie process and an orphan process?
        options:
          a: "Zombie: terminated but not reaped; Orphan: parent dead, adopted by init"
          b: "Zombie: no memory; Orphan: no CPU"
          c: "Nu există nicio diferență"
          d: "Zombie: adopted by init; Orphan: terminated"
        correct: a
        explanation: |
          Zombie: terminated process whose exit status has not been
          reaped by the parent with wait(). Occupies a slot in the process table.
          Orphan: process whose parent has died; adopted by init (PID 1).
          
      - id: proc_05
        type: code_completion
        difficulty: hard
        question: |
          Complete the trap for cleanup on termination:
          ```bash
          cleanup() {
              rm -f "$TMPFILE"
              kill "$BG_PID" 2>/dev/null
          }
          trap ________ EXIT
          trap ________ INT TERM
          ```
        answer: ["cleanup", "cleanup"]
        explanation: |
          EXIT trap executes on any script exit.
          INT TERM trap executes on Ctrl+C and kill.
          Best practice: trap cleanup on both for robustness.

  - name: "Networking and Security"
    weight: 15
    questions:
      - id: net_01
        type: multiple_choice
        difficulty: easy
        question: |
          Which command checks if port 80 is open on localhost?
        options:
          a: "nc -zv localhost 80"
          b: "ping localhost:80"
          c: "telnet localhost 80"
          d: "Both a and c"
        correct: d
        explanation: |
          nc -zv performs a quick scan (-z) with verbose (-v).
          telnet can connect and allows interaction.
          ping cannot specify ports (ICMP has no ports).
          
      - id: net_02
        type: multiple_choice
        difficulty: medium
        question: |
          What does permission 4755 mean on an executable?
        options:
          a: "rwxr-xr-x with SUID bit"
          b: "rwxrwxrwx"
          c: "r--r--r-x"
          d: "Normal rwxr-xr-x"
        correct: a
        explanation: |
          4xxx = SUID bit. When executed, the process runs
          with the owner's permissions, not the user's.
          2xxx = SGID, 1xxx = sticky bit.
          
      - id: net_03
        type: multiple_choice
        difficulty: hard
        question: |
          Which command displays all established TCP connections with PID?
        options:
          a: "netstat -tuln"
          b: "ss -tnp state established"
          c: "lsof -i TCP"
          d: "Both b and c"
        correct: d
        explanation: |
          ss -tnp state established: TCP, numeric, with PID, only established.
          lsof -i TCP: lists files (sockets) TCP with PID.
          netstat -tuln displays LISTENING, not established.

  - name: "Project and Best Practices"
    weight: 10
    questions:
      - id: proj_01
        type: multiple_choice
        difficulty: easy
        question: |
          What should the project's README.md contain?
        options:
          a: "Only the title"
          b: "Description, installation, usage, examples"
          c: "Only the source code"
          d: "Only hardware requirements"
        correct: b
        explanation: |
          A complete README.md includes: description, requirements/dependencies,
          installation instructions, usage examples, contributions.
          
      - id: proj_02
        type: multiple_choice
        difficulty: medium
        question: |
          What is the recommended structure for a Bash project?
        options:
          a: "One large file"
          b: "src/, lib/, tests/, docs/, etc/, Makefile"
          c: "Only the main file and README"
          d: "There is no standard"
        correct: b
        explanation: |
          The modular structure allows: organised code in lib/,
          separate tests, documentation in docs/, configurations in etc/.
          Makefile orchestrates build, test, install.
          
      - id: proj_03
        type: multiple_choice
        difficulty: medium
        question: |
          How do you verify that your script has no style errors?
        options:
          a: "bash -n script.sh"
          b: "shellcheck script.sh"
          c: "chmod +x and run"
          d: "Both a and b"
        correct: d
        explanation: |
          bash -n: checks syntax without executing.
          shellcheck: analyses code for errors and bad practices.
          Both are essential for quality code.

# Scoring and feedback
scoring:
  easy: 1
  medium: 2
  hard: 3

feedback:
  90-100: |
    Excellent! You are ready to tackle any project level.
    Recommendation: MEDIUM or ADVANCED project.
  70-89: |
    Good! You have a solid foundation.
    Recommendation: EASY or MEDIUM project.
    Review sections with lower scores.
  50-69: |
    You need more practice.
    Recommendation: EASY project.
    Go through the corresponding seminar for weak sections.
  0-49: |
    Insufficient preparation.
    Recommendation: review course and seminar materials
    before starting the project. Consult additional tutorials.

# Mapping to seminars for additional study
study_resources:
  "Fundamente Bash":
    - "Seminar 2: Variables and expansions"
    - "Seminar 3: Flow control"
  "Comenzi și Utilitare":
    - "Seminar 4: Text processing (grep, sed, awk)"
    - "Seminar 5: File search and manipulation"
  "Processes and System":
    - "Seminar 2: Processes and signals"
    - "Seminar 6: System monitoring"
  "Networking and Security":
    - "Seminar 7: Networking basics"
    - "Seminar 8: Security"
  "Project and Best Practices":
    - "Seminar 1: Introduction and project structure"
    - "Bash style guide (docs/)"
