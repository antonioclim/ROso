# ═══════════════════════════════════════════════════════════════════════════════
# Quiz Formativ: Seminarul 04 — Text Processing
# ═══════════════════════════════════════════════════════════════════════════════
# Sisteme de Operare | ASE București - CSIE
# Versiune: 1.0 | Data: Ianuarie 2025
# Rulare: python3 quiz_runner.py quiz.yaml
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  seminar: 4
  subiect: "Text Processing — Regex, GREP, SED, AWK"
  versiune: "1.0"
  limba: "ro"
  timp_estimat_minute: 15
  punctaj_total: 100
  prag_promovare: 60
  
  # Distribuție Bloom pentru începători (Anul 1)
  distributie_bloom:
    remember: 3      # 20%
    understand: 5    # 33%
    apply: 5         # 33%
    analyse: 2       # 14%

  learning_outcomes:
    - id: LO1
      descriere: "Scrie expresii regulate BRE și ERE funcționale"
    - id: LO2
      descriere: "Folosește grep cu opțiunile principale pentru căutare text"
    - id: LO3
      descriere: "Transformă text cu sed (substituție, ștergere, inserare)"
    - id: LO4
      descriere: "Procesează date structurate cu awk (câmpuri, calcule)"
    - id: LO5
      descriere: "Combină tools în pipeline-uri eficiente"

# ═══════════════════════════════════════════════════════════════════════════════
# ÎNTREBĂRI
# ═══════════════════════════════════════════════════════════════════════════════

intrebari:

  # ─────────────────────────────────────────────────────────────────────────────
  # REMEMBER (3 întrebări) — 20%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: R1
    tip: mcq
    bloom: remember
    lo: [LO1]
    punctaj: 6
    text: |
      Care metacaracter regex potrivește ORICE caracter singur (exceptând newline)?
    optiuni:
      - "."
      - "*"
      - "?"
      - "+"
    corect: 0
    explicatie: |
      Punctul (.) potrivește exact un caracter, oricare ar fi el.
      * = zero sau mai multe din precedent
      ? = zero sau unu din precedent
      + = unul sau mai multe din precedent
    misconceptii:
      1: "Confuzie cu * din globbing shell (unde * = orice caractere)"
      2: "Confuzie cu ? din globbing shell (unde ? = un caracter)"

  - id: R2
    tip: mcq
    bloom: remember
    lo: [LO2]
    punctaj: 6
    text: |
      Care opțiune grep afișează DOAR textul care s-a potrivit, nu linia întreagă?
    optiuni:
      - "-o"
      - "-v"
      - "-c"
      - "-l"
    corect: 0
    explicatie: |
      -o (only-matching) afișează doar porțiunea care s-a potrivit.
      -v = inversează selecția (linii care NU se potrivesc)
      -c = numără liniile potrivite
      -l = afișează doar numele fișierelor cu potriviri
    misconceptii:
      1: "Confuzie -v cu 'verbose' (în grep înseamnă invert)"
      2: "Confuzie -c cu 'count characters' (numără linii)"

  - id: R3
    tip: mcq
    bloom: remember
    lo: [LO3]
    punctaj: 6
    text: |
      În sed, ce comandă șterge liniile care se potrivesc unui pattern?
    optiuni:
      - "d"
      - "p"
      - "s"
      - "q"
    corect: 0
    explicatie: |
      d = delete (șterge linia)
      p = print (afișează linia)
      s = substitute (înlocuiește)
      q = quit (oprește procesarea)
    misconceptii:
      1: "Confuzie cu 'p' care face opusul (printează)"

  # ─────────────────────────────────────────────────────────────────────────────
  # UNDERSTAND (5 întrebări) — 33%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: U1
    tip: mcq
    bloom: understand
    lo: [LO1]
    punctaj: 7
    text: |
      Care este diferența PRINCIPALĂ între BRE și ERE în grep?
    optiuni:
      - "În BRE, metacaracterele +, ?, {}, (), | necesită escape cu backslash"
      - "BRE este mai rapid decât ERE"
      - "ERE nu suportă grupări cu paranteze"
      - "BRE funcționează doar pe Linux, ERE pe toate sistemele"
    corect: 0
    explicatie: |
      În BRE (Basic Regular Expressions), caracterele +, ?, {}, (), | sunt 
      literale implicit și trebuie escapate (\+, \?, etc.) pentru a fi metacaractere.
      În ERE (Extended), acestea sunt metacaractere implicit.
      
      Exemplu:
        grep 'ab+c' file       # BRE: caută literal "ab+c"
        grep -E 'ab+c' file    # ERE: caută "a" urmat de 1+ "b" urmat de "c"
    misconceptii:
      0: "Confuzie comună între când să folosești escape"

  - id: U2
    tip: mcq
    bloom: understand
    lo: [LO1, LO2]
    punctaj: 7
    text: |
      Ce potrivește pattern-ul regex `^[^#]` ?
    optiuni:
      - "Linii care NU încep cu #"
      - "Linii care încep cu #"
      - "Caracterul ^ urmat de #"
      - "Orice linie care conține #"
    corect: 0
    explicatie: |
      Primul ^ = anchor pentru începutul liniei
      [^#] = orice caracter EXCEPTÂND #
      Deci: linii care încep cu orice caracter diferit de #
      
      Notă: ^ are două semnificații diferite:
      - În afara [] = început de linie
      - În interiorul [] la început = negație
    misconceptii:
      1: "Confuzie: al doilea ^ nu mai este anchor, ci negație în character class"

  - id: U3
    tip: predict
    bloom: understand
    lo: [LO2]
    punctaj: 7
    text: |
      Ce va afișa această comandă?
      
      echo -e "abc\nABC\nabC" | grep -i 'abc'
    optiuni:
      - "abc, ABC, abC (toate trei liniile)"
      - "doar abc"
      - "abc și ABC"
      - "Eroare: pattern invalid"
    corect: 0
    explicatie: |
      Opțiunea -i face căutarea case-insensitive.
      Toate cele trei variante (abc, ABC, abC) se potrivesc.
    misconceptii:
      1: "Uitarea că -i ignoră case pentru TOATE caracterele"

  - id: U4
    tip: predict
    bloom: understand
    lo: [LO3]
    punctaj: 7
    text: |
      Ce va afișa această comandă?
      
      echo "hello world" | sed 's/o/O/'
    optiuni:
      - "hellO world"
      - "hellO wOrld"
      - "HELLO WORLD"
      - "hello world"
    corect: 0
    explicatie: |
      Fără flag-ul 'g', sed înlocuiește doar PRIMA apariție pe fiecare linie.
      Pentru a înlocui toate aparițiile: sed 's/o/O/g'
    misconceptii:
      1: "Presupunerea că sed înlocuiește toate aparițiile implicit"

  - id: U5
    tip: predict
    bloom: understand
    lo: [LO4]
    punctaj: 7
    text: |
      Ce va afișa această comandă pentru linia "ana:are:mere"?
      
      echo "ana:are:mere" | awk -F: '{print $2}'
    optiuni:
      - "are"
      - "ana"
      - "mere"
      - "ana:are:mere"
    corect: 0
    explicatie: |
      -F: setează delimitatorul la ":"
      $2 = al doilea câmp
      Linia se împarte în: $1=ana, $2=are, $3=mere
    misconceptii:
      1: "Confuzie despre indexarea câmpurilor (începe de la 1, nu 0)"
      2: "Uitarea că -F schimbă delimitatorul implicit (spațiu)"

  # ─────────────────────────────────────────────────────────────────────────────
  # APPLY (5 întrebări) — 33%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: A1
    tip: mcq
    bloom: apply
    lo: [LO1, LO2]
    punctaj: 8
    text: |
      Care comandă extrage TOATE adresele IP din fișierul log.txt?
    optiuni:
      - "grep -oE '([0-9]{1,3}\\.){3}[0-9]{1,3}' log.txt"
      - "grep -o '[0-9]*' log.txt"
      - "grep 'IP' log.txt"
      - "grep -E '[0-9].[0-9].[0-9].[0-9]' log.txt"
    corect: 0
    explicatie: |
      Pattern-ul corect:
      - [0-9]{1,3} = 1-3 cifre
      - \\. = punct literal (escapat)
      - (){3} = grupul se repetă de 3 ori
      - -o = afișează doar match-urile
      - -E = Extended regex (pentru {})
      
      Varianta D greșește pentru că . neescapat potrivește orice caracter.
    misconceptii:
      3: "Punctul neescapat potrivește orice caracter, nu doar '.'"

  - id: A2
    tip: mcq
    bloom: apply
    lo: [LO3]
    punctaj: 8
    text: |
      Care comandă sed șterge toate liniile goale dintr-un fișier?
    optiuni:
      - "sed '/^$/d' fisier.txt"
      - "sed 's/^$//' fisier.txt"
      - "sed '/./d' fisier.txt"
      - "sed 'd' fisier.txt"
    corect: 0
    explicatie: |
      ^$ = pattern pentru linie goală (început urmat imediat de sfârșit)
      d = comandă delete
      /pattern/d = șterge liniile care se potrivesc
      
      Varianta B doar înlocuiește linia goală cu nimic, dar linia rămâne.
      Varianta C șterge liniile care conțin cel puțin un caracter (opusul).
      Varianta D șterge TOATE liniile.
    misconceptii:
      1: "Confuzie între substituție cu șir gol și ștergerea liniei"

  - id: A3
    tip: mcq
    bloom: apply
    lo: [LO4]
    punctaj: 8
    text: |
      Care comandă awk calculează suma valorilor din coloana 3 a unui CSV?
    optiuni:
      - "awk -F, '{sum+=$3} END {print sum}' date.csv"
      - "awk '{print $3}' date.csv | sum"
      - "awk -F, 'BEGIN {print $3}' date.csv"
      - "awk '{sum=$3} END {print sum}' date.csv"
    corect: 0
    explicatie: |
      -F, = separator virgulă (CSV)
      sum+=$3 = adună $3 la variabila sum (pentru fiecare linie)
      END = bloc executat după procesarea tuturor liniilor
      
      Varianta D resetează sum la $3 în loc să adune (lipsește +).
    misconceptii:
      3: "Diferența între sum=$3 (atribuire) și sum+=$3 (adunare)"

  - id: A4
    tip: mcq
    bloom: apply
    lo: [LO2, LO5]
    punctaj: 8
    text: |
      Care pipeline numără câte linii unice conțin "ERROR" în toate fișierele .log?
    optiuni:
      - "grep -h 'ERROR' *.log | sort | uniq | wc -l"
      - "grep 'ERROR' *.log | wc -l"
      - "grep -c 'ERROR' *.log"
      - "grep 'ERROR' *.log | uniq | wc -l"
    corect: 0
    explicatie: |
      -h = suppress filename în output (altfel fiecare linie are prefix)
      sort = necesar înainte de uniq (uniq funcționează pe linii adiacente)
      uniq = elimină duplicatele
      wc -l = numără liniile
      
      Varianta B numără TOATE aparițiile, nu liniile unice.
      Varianta D: uniq fără sort nu funcționează corect.
    misconceptii:
      3: "uniq TREBUIE precedat de sort (lucrează pe linii consecutive)"

  - id: A5
    tip: fill
    bloom: apply
    lo: [LO3]
    punctaj: 8
    text: |
      Completează comanda sed care înlocuiește TOATE aparițiile lui "foo" cu "bar":
      
      sed 's/foo/bar/___' fisier.txt
    raspuns_corect: "g"
    explicatie: |
      Flag-ul 'g' (global) face substituția pe toate aparițiile din linie,
      nu doar pe prima.

  # ─────────────────────────────────────────────────────────────────────────────
  # ANALYSE (2 întrebări) — 14%
  # ─────────────────────────────────────────────────────────────────────────────

  - id: AN1
    tip: mcq
    bloom: analyse
    lo: [LO1, LO2, LO5]
    punctaj: 9
    text: |
      Un coleg a scris această comandă dar nu funcționează cum se așteaptă:
      
      grep 'error|warning' server.log
      
      Comanda nu găsește nimic, deși fișierul conține linii cu "error" și "warning".
      Care este problema?
    optiuni:
      - "Lipsește -E; în BRE, | este literal, nu alternativă"
      - "Pattern-ul trebuie să fie 'error\\|warning'"
      - "Ambele variante A și B sunt corecte"
      - "Trebuie folosit -i pentru case-insensitive"
    corect: 2
    explicatie: |
      În BRE (grep fără -E), caracterul | este literal.
      Două soluții corecte:
      1. grep -E 'error|warning' server.log   (folosește ERE)
      2. grep 'error\|warning' server.log     (escape în BRE)
      
      Varianta D nu rezolvă problema dacă textul este exact "error"/"warning".
    misconceptii:
      0: "Înțelegerea diferenței BRE vs ERE este esențială pentru debugging"

  - id: AN2
    tip: mcq
    bloom: analyse
    lo: [LO3, LO4, LO5]
    punctaj: 9
    text: |
      Care abordare este MAI EFICIENTĂ pentru a procesa un fișier CSV de 1GB 
      și a extrage doar coloana 2?
    optiuni:
      - "awk -F, '{print $2}' mare.csv"
      - "cat mare.csv | cut -d, -f2"
      - "sed 's/[^,]*,\\([^,]*\\).*/\\1/' mare.csv"
      - "Toate sunt la fel de eficiente"
    corect: 0
    explicatie: |
      awk este cel mai eficient pentru extragerea câmpurilor deoarece:
      - Parsează linia o singură dată
      - Nu creează procese suplimentare
      - Este optimizat pentru procesare pe câmpuri
      
      Varianta B: cat | cut = UUOC (Useless Use of Cat) + pipe overhead
      Varianta C: sed cu regex complex este mai lent pentru task simplu
    misconceptii:
      1: "UUOC (Useless Use of Cat) - cat nu e necesar aici"
      2: "sed e puternic dar nu ideal pentru extragere simplă de câmpuri"

# ═══════════════════════════════════════════════════════════════════════════════
# CONFIGURARE FEEDBACK
# ═══════════════════════════════════════════════════════════════════════════════

feedback:
  scor_90_100:
    mesaj: "Excelent! Stăpânești text processing la nivel avansat."
    recomandare: "Încearcă proiectele din SEM-PROJ nivel MEDIUM."
  
  scor_70_89:
    mesaj: "Bine! Ai înțeles conceptele principale."
    recomandare: "Revizuiește secțiunile unde ai greșit și practică cu exercițiile sprint."
  
  scor_50_69:
    mesaj: "Satisfăcător. Mai ai nevoie de practică."
    recomandare: "Recitește Material Principal și refă exercițiile de bază."
  
  scor_sub_50:
    mesaj: "Necesită îmbunătățire semnificativă."
    recomandare: "Participă la consultații și lucrează prin toate exemplele pas cu pas."

# ═══════════════════════════════════════════════════════════════════════════════
# FIN
# ═══════════════════════════════════════════════════════════════════════════════
