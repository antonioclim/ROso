# ═══════════════════════════════════════════════════════════════════════════════
# Quiz Formativ - Seminar 05: Advanced Bash Scripting
# ═══════════════════════════════════════════════════════════════════════════════
# Sisteme de Operare | ASE București - CSIE
# Versiune: 1.0.0 | Data: 2025-01
#
# UTILIZARE:
#   python3 quiz_runner.py quiz.yaml           # Mod interactiv
#   python3 quiz_runner.py quiz.yaml --random  # Ordine aleatorie
#   python3 quiz_runner.py quiz.yaml --export  # Export JSON pentru LMS
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  seminar: 5
  titlu: "Advanced Bash Scripting"
  subtitlu: "Funcții, Arrays, Stabilitate, Error Handling"
  versiune: "1.0.0"
  autor: "ing. dr. Antonio Clim"
  institutie: "ASE București - CSIE"
  data: "2025-01"
  durata_minute: 25
  numar_intrebari: 18
  punctaj_total: 100
  prag_promovare: 60
  
  distributie_bloom:
    remember: 2
    understand: 8
    apply: 5
    analyse: 2
    evaluate: 1

  teme:
    - nume: "Funcții"
      intrebari: ["q01", "q02", "q03"]
    - nume: "Arrays"
      intrebari: ["q04", "q05", "q06", "q07"]
    - nume: "Stabilitate"
      intrebari: ["q08", "q09", "q10", "q11", "q12"]
    - nume: "Trap și Error Handling"
      intrebari: ["q13", "q14"]
    - nume: "Consolidare"
      intrebari: ["q15", "q16", "q17", "q18"]

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 1: FUNCȚII
# ═══════════════════════════════════════════════════════════════════════════════

intrebari:

  - id: q01
    tema: "Funcții"
    titlu: "Variabile în Funcții"
    bloom: understand
    puncte: 5
    dificultate: medie
    timp_secunde: 60
    misconceptie_vizata: "80% cred că variabilele sunt locale by default"
    
    cod: |
      #!/bin/bash
      count=10
      
      increment() {
          count=$((count + 1))
          echo "În funcție: $count"
      }
      
      increment
      echo "După funcție: $count"
    
    intrebare: "Ce afișează ultima linie?"
    
    optiuni:
      - text: "După funcție: 10"
        explicatie: "Crede că variabilele sunt locale by default"
      - text: "După funcție: 11"
        explicatie: "CORECT - variabilele din funcții sunt GLOBALE by default"
      - text: "După funcție: (gol)"
        explicatie: "Confundă cu comportament undefined"
      - text: "Eroare - count nu e definit în main"
        explicatie: "Nu înțelege că variabilele sunt globale"
    
    raspuns_corect: 1
    
    explicatie: |
      În Bash, variabilele din funcții sunt GLOBALE by default.
      Aceasta e opusul comportamentului din Python/Java/C.
      Pentru variabile locale, folosește: local count=$((count + 1))
    
    followup: "Cum facem ca variabila să rămână locală?"
    raspuns_followup: "local count=$((count + 1))"

  - id: q02
    tema: "Funcții"
    titlu: "Return vs Echo"
    bloom: understand
    puncte: 6
    dificultate: medie
    timp_secunde: 60
    misconceptie_vizata: "75% cred că return funcționează ca în alte limbaje"
    
    cod: |
      #!/bin/bash
      
      get_value() {
          return 42
      }
      
      result=$(get_value)
      echo "Result: '$result'"
    
    intrebare: "Ce afișează?"
    
    optiuni:
      - text: "Result: '42'"
        explicatie: "Confundă return cu echo/print din alte limbaje"
      - text: "Result: '' (string gol)"
        explicatie: "CORECT - return setează exit code, $() capturează stdout"
      - text: "Result: '0'"
        explicatie: "Confundă cu exit code default"
      - text: "Eroare de sintaxă"
        explicatie: "Sintaxa e validă"
    
    raspuns_corect: 1
    
    explicatie: |
      `return` în Bash setează doar exit code (0-255), nu returnează valori.
      $() capturează stdout, nu exit code-ul.
      Pentru a "returna" valori, folosește echo în funcție.

  - id: q03
    tema: "Funcții"
    titlu: "Argumente Funcție vs Script"
    bloom: understand
    puncte: 5
    dificultate: medie
    timp_secunde: 60
    misconceptie_vizata: "65% confundă $1 din funcție cu $1 din script"
    
    cod: |
      #!/bin/bash
      # Script: test.sh, rulat cu: ./test.sh SCRIPT_ARG
      
      show_arg() {
          echo "Funcție vede: $1"
      }
      
      echo "Script vede: $1"
      show_arg "FUNC_ARG"
    
    intrebare: "Rulat cu ./test.sh SCRIPT_ARG, ce afișează a doua linie?"
    
    optiuni:
      - text: "Funcție vede: SCRIPT_ARG"
        explicatie: "Confundă scope-ul argumentelor"
      - text: "Funcție vede: FUNC_ARG"
        explicatie: "CORECT - $1 în funcție e argumentul funcției"
      - text: "Funcție vede: (gol)"
        explicatie: "Funcția primește argument explicit"
      - text: "Funcție vede: $1"
        explicatie: "Variabilele se expandează"
    
    raspuns_corect: 1
    
    explicatie: |
      $1 în funcție se referă la argumentul funcției, nu al scriptului.
      Funcțiile au propriul set de argumente poziționale.

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 2: ARRAYS
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q04
    tema: "Arrays"
    titlu: "Indexare Arrays"
    bloom: remember
    puncte: 4
    dificultate: usor
    timp_secunde: 45
    misconceptie_vizata: "55% cred că arrays încep de la 1"
    
    cod: |
      #!/bin/bash
      arr=("first" "second" "third")
      echo "${arr[1]}"
    
    intrebare: "Ce afișează?"
    
    optiuni:
      - text: "first"
        explicatie: "Crede că indexarea începe de la 1"
      - text: "second"
        explicatie: "CORECT - arrays în Bash încep de la 0"
      - text: "third"
        explicatie: "Confuzie de indexare"
      - text: "Eroare - indexul 1 nu există"
        explicatie: "Indexul 1 există (al doilea element)"
    
    raspuns_corect: 1
    
    explicatie: |
      Arrays în Bash încep de la index 0.
      arr[0]="first", arr[1]="second", arr[2]="third"

  - id: q05
    tema: "Arrays"
    titlu: "declare -A"
    bloom: understand
    puncte: 6
    dificultate: greu
    timp_secunde: 90
    misconceptie_vizata: "70% cred că declare -A e opțional pentru hash"
    
    cod: |
      #!/bin/bash
      # Fără declare -A
      config[host]="localhost"
      config[port]="8080"
      echo "Chei: ${!config[@]}"
    
    intrebare: "Ce afișează?"
    
    optiuni:
      - text: "Chei: host port"
        explicatie: "Așa ar fi cu declare -A"
      - text: "Chei: 0"
        explicatie: "CORECT - fără declare -A, 'host' și 'port' devin 0"
      - text: "Chei: 0 0"
        explicatie: "Doar o cheie rămâne (suprascrisă)"
      - text: "Eroare - config nu e declarat"
        explicatie: "Arrays indexate se creează implicit"
    
    raspuns_corect: 1
    
    explicatie: |
      Fără declare -A, Bash tratează config ca array INDEXAT.
      'host' și 'port' sunt evaluate ca variabile (nedefinite = 0).
      Ambele asignări scriu la config[0], ultima suprascrie prima.

  - id: q06
    tema: "Arrays"
    titlu: "Iterare cu Ghilimele"
    bloom: apply
    puncte: 6
    dificultate: medie
    timp_secunde: 75
    misconceptie_vizata: "65% uită ghilimelele la iterare"
    
    cod: |
      #!/bin/bash
      files=("file one.txt" "file two.txt")
      
      count=0
      for f in ${files[@]}; do
          ((count++))
      done
      echo "Iterații: $count"
    
    intrebare: "Câte iterații are loop-ul?"
    
    optiuni:
      - text: "2"
        explicatie: "Așa ar fi CU ghilimele"
      - text: "4"
        explicatie: "CORECT - word splitting separă fiecare element"
      - text: "1"
        explicatie: "Nu înțelege iterarea peste array"
      - text: "Eroare"
        explicatie: "Codul e valid sintactic"
    
    raspuns_corect: 1
    
    explicatie: |
      Fără ghilimele, Bash aplică word splitting.
      "file one.txt" devine 2 cuvinte: "file" și "one.txt"
      REGULĂ: ÎNTOTDEAUNA folosește "${arr[@]}" cu ghilimele!

  - id: q07
    tema: "Arrays"
    titlu: "Ștergere Element din Array"
    bloom: apply
    puncte: 5
    dificultate: medie
    timp_secunde: 60
    misconceptie_vizata: "50% cred că unset reindexează automat"
    
    cod: |
      #!/bin/bash
      arr=("a" "b" "c" "d" "e")
      unset arr[2]
      echo "Indici: ${!arr[@]}"
      echo "Lungime: ${#arr[@]}"
    
    intrebare: "Ce afișează?"
    
    optiuni:
      - text: "Indici: 0 1 2 3 și Lungime: 4"
        explicatie: "Crede că array-ul se reindexează"
      - text: "Indici: 0 1 3 4 și Lungime: 4"
        explicatie: "CORECT - array devine sparse, indicii nu se schimbă"
      - text: "Indici: 0 1 2 3 4 și Lungime: 5"
        explicatie: "Nu înțelege efectul unset"
      - text: "Eroare"
        explicatie: "Codul e valid"
    
    raspuns_corect: 1
    
    explicatie: |
      unset arr[2] șterge elementul, dar NU reindexează.
      Array-ul devine "sparse" (cu gap).
      Pentru iterare sigură, folosește: for i in "${!arr[@]}"

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 3: STABILITATE (set -euo pipefail)
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q08
    tema: "Stabilitate"
    titlu: "set -u (nounset)"
    bloom: understand
    puncte: 5
    dificultate: medie
    timp_secunde: 60
    misconceptie_vizata: "Mulți nu știu cum să folosească variabile opționale"
    
    cod: |
      #!/bin/bash
      set -euo pipefail
      
      x="${UNDEFINED_VAR}"
      echo "Continuă..."
    
    intrebare: "Ce se întâmplă?"
    
    optiuni:
      - text: "Afișează Continuă... cu x=\"\""
        explicatie: "Așa ar fi FĂRĂ set -u"
      - text: "Eroare: unbound variable"
        explicatie: "CORECT - set -u oprește la variabile nedefinite"
      - text: "Afișează Continuă... cu x=\"UNDEFINED_VAR\""
        explicatie: "Variabilele se expandează, nu rămân literal"
      - text: "Depinde de versiunea Bash"
        explicatie: "Comportamentul e consistent"
    
    raspuns_corect: 1
    
    explicatie: |
      set -u face ca variabilele nedefinite să cauzeze eroare.
      Pentru variabile opționale, folosește: x="${VAR:-default}"

  - id: q09
    tema: "Stabilitate"
    titlu: "set -e în if"
    bloom: understand
    puncte: 6
    dificultate: greu
    timp_secunde: 75
    misconceptie_vizata: "75% cred că set -e oprește la ORICE eroare"
    
    cod: |
      #!/bin/bash
      set -e
      
      if false; then
          echo "În if"
      fi
      echo "După if"
    
    intrebare: "Ce se întâmplă?"
    
    optiuni:
      - text: "Script se oprește la false"
        explicatie: "set -e NU se aplică în condiții if"
      - text: "Afișează După if"
        explicatie: "CORECT - set -e nu funcționează în context de test"
      - text: "Afișează În if apoi După if"
        explicatie: "Condiția false e falsă, corpul if nu se execută"
      - text: "Eroare de sintaxă"
        explicatie: "Sintaxa e validă"
    
    raspuns_corect: 1
    
    explicatie: |
      set -e NU funcționează pentru comenzi în condiții if/while/until.
      De asemenea nu funcționează după || sau && sau cu !.

  - id: q10
    tema: "Stabilitate"
    titlu: "set -e cu ||"
    bloom: apply
    puncte: 5
    dificultate: medie
    timp_secunde: 60
    misconceptie_vizata: "Pattern || true nu e înțeles"
    
    cod: |
      #!/bin/bash
      set -e
      
      false || echo "Rescued"
      echo "Continuă"
    
    intrebare: "Ce afișează?"
    
    optiuni:
      - text: "Nimic - script se oprește"
        explicatie: "|| salvează eroarea"
      - text: "Rescued apoi Continuă"
        explicatie: "CORECT - || dezactivează set -e pentru acea comandă"
      - text: "Doar Continuă"
        explicatie: "Rescued se afișează pentru că false eșuează"
      - text: "Doar Rescued"
        explicatie: "Scriptul continuă după ||"
    
    raspuns_corect: 1
    
    explicatie: |
      || "salvează" eroarea - set -e nu se aplică.
      Pattern util: command_that_might_fail || handle_error

  - id: q11
    tema: "Stabilitate"
    titlu: "pipefail"
    bloom: understand
    puncte: 5
    dificultate: medie
    timp_secunde: 60
    misconceptie_vizata: "50% nu știu ce face pipefail"
    
    cod: |
      #!/bin/bash
      set -o pipefail
      
      false | true | true
      echo "Exit: $?"
    
    intrebare: "Ce afișează?"
    
    optiuni:
      - text: "Exit: 0"
        explicatie: "Așa ar fi FĂRĂ pipefail"
      - text: "Exit: 1"
        explicatie: "CORECT - pipefail returnează prima eroare din pipe"
      - text: "Exit: 2"
        explicatie: "Doar primul exit code non-zero contează"
      - text: "Nimic - script se oprește"
        explicatie: "fără set -e, scriptul continuă"
    
    raspuns_corect: 1
    
    explicatie: |
      Cu pipefail, pipeline returnează exit code-ul primei comenzi care eșuează.
      Fără pipefail, ar fi returnat 0 (de la ultimul true).

  - id: q12
    tema: "Stabilitate"
    titlu: "set -e + pipefail"
    bloom: apply
    puncte: 6
    dificultate: greu
    timp_secunde: 75
    misconceptie_vizata: "Combinația set -e + pipefail"
    
    cod: |
      #!/bin/bash
      set -eo pipefail
      
      cat /nonexistent | grep "pattern"
      echo "După pipe"
    
    intrebare: "Ce se întâmplă?"
    
    optiuni:
      - text: "Afișează eroarea de la cat, apoi După pipe"
        explicatie: "set -e oprește scriptul"
      - text: "Script se oprește la eroarea cat"
        explicatie: "CORECT - set -e + pipefail = erori din pipe opresc"
      - text: "Afișează După pipe (grep salvează)"
        explicatie: "pipefail propagă eroarea din cat"
      - text: "Depinde de existența fișierului pattern"
        explicatie: "Eroarea cat apare prima"
    
    raspuns_corect: 1
    
    explicatie: |
      set -e + pipefail = erori din pipe opresc scriptul.
      cat /nonexistent eșuează, pipefail propagă eroarea, set -e oprește.

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 4: TRAP ȘI ERROR HANDLING
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q13
    tema: "Trap și Error Handling"
    titlu: "Trap EXIT"
    bloom: apply
    puncte: 6
    dificultate: medie
    timp_secunde: 75
    misconceptie_vizata: "55% cred că trap EXIT nu se execută la erori"
    
    cod: |
      #!/bin/bash
      set -e
      
      cleanup() {
          echo "Cleanup executat"
      }
      trap cleanup EXIT
      
      echo "Start"
      false
      echo "End"
    
    intrebare: "Ce afișează?"
    
    optiuni:
      - text: "Start apoi Cleanup executat"
        explicatie: "CORECT - trap EXIT se execută ÎNTOTDEAUNA"
      - text: "Start, End, Cleanup executat"
        explicatie: "set -e oprește la false, End nu se afișează"
      - text: "Doar Start"
        explicatie: "trap EXIT tot se execută"
      - text: "Cleanup executat apoi Start"
        explicatie: "trap se execută la EXIT, nu la start"
    
    raspuns_corect: 0
    
    explicatie: |
      trap cleanup EXIT se execută ÎNTOTDEAUNA la ieșire:
      - La ieșire normală
      - La erori (set -e)
      - La Ctrl+C (dacă ai și trap INT)

  - id: q14
    tema: "Trap și Error Handling"
    titlu: "Trap și Subshell"
    bloom: understand
    puncte: 6
    dificultate: greu
    timp_secunde: 90
    misconceptie_vizata: "45% cred că trap se moștenește în subshell"
    
    cod: |
      #!/bin/bash
      
      cleanup() { echo "Cleanup"; }
      trap cleanup EXIT
      
      (
          echo "În subshell"
          exit 1
      )
      
      echo "După subshell: $?"
    
    intrebare: "Câte Cleanup apar?"
    
    optiuni:
      - text: "0"
        explicatie: "Trap-ul din scriptul principal tot se execută"
      - text: "1"
        explicatie: "CORECT - trap NU se moștenește în subshell"
      - text: "2"
        explicatie: "Trap-ul nu se moștenește"
      - text: "Depinde de versiunea Bash"
        explicatie: "Comportamentul e consistent"
    
    raspuns_corect: 1
    
    explicatie: |
      Trap-urile NU se moștenesc în subshell-uri.
      Cleanup apare doar o dată, când scriptul principal se termină.

# ═══════════════════════════════════════════════════════════════════════════════
# SECȚIUNEA 5: CONSOLIDARE
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q15
    tema: "Consolidare"
    titlu: "Template Profesional"
    bloom: remember
    puncte: 5
    dificultate: medie
    timp_secunde: 60
    misconceptie_vizata: "Ordinea secțiunilor în scripturi"
    
    intrebare: "Care e ordinea corectă a secțiunilor într-un script profesional?"
    
    optiuni:
      - text: "Shebang → Main → Functions → Trap → Constants"
        explicatie: "Main trebuie la final"
      - text: "Shebang → Constants → Functions → Trap → Main"
        explicatie: "Lipsește set -euo pipefail"
      - text: "Shebang → set -euo pipefail → Constants → Functions → Trap → Parse Args → Main"
        explicatie: "CORECT - structura standard profesională"
      - text: "Main → Functions → Shebang → Trap"
        explicatie: "Shebang trebuie prima linie"
    
    raspuns_corect: 2
    
    explicatie: |
      Structura profesională: Shebang → strict mode → constante → 
      funcții → cleanup → trap → argument parsing → main → execuție main

  - id: q16
    tema: "Consolidare"
    titlu: "Identifică Bug-urile"
    bloom: analyse
    puncte: 8
    dificultate: greu
    timp_secunde: 120
    misconceptie_vizata: "Pattern-uri greșite comune"
    
    cod: |
      #!/bin/bash
      set -euo pipefail
      
      declare -a files
      files=$(find . -name "*.txt")
      
      for f in ${files[@]}; do
          process "$f"
      done
    
    intrebare: "Câte bug-uri are acest cod?"
    
    optiuni:
      - text: "1"
        explicatie: "Sunt mai multe probleme"
      - text: "2"
        explicatie: "Mai e una"
      - text: "3"
        explicatie: "CORECT - assignment greșit, lipsă ghilimele, declare redundant"
      - text: "4 sau mai multe"
        explicatie: "Sunt exact 3 principale"
    
    raspuns_corect: 2
    
    explicatie: |
      Bug 1: files=$(...) - ar trebui mapfile -t files < <(find...)
      Bug 2: ${files[@]} fără ghilimele - ar trebui "${files[@]}"
      Bug 3: declare -a redundant pentru arrays indexate

  - id: q17
    tema: "Consolidare"
    titlu: "Best Practice - Adevărat/Fals"
    bloom: evaluate
    puncte: 6
    dificultate: medie
    timp_secunde: 75
    misconceptie_vizata: "Excepțiile set -e"
    
    intrebare: "Care afirmație este FALSĂ despre best practices în Bash?"
    
    optiuni:
      - text: "local trebuie folosit pentru toate variabilele din funcții"
        explicatie: "ADEVĂRAT - previne efecte secundare"
      - text: "declare -A e obligatoriu pentru arrays asociative"
        explicatie: "ADEVĂRAT - altfel sunt tratate ca indexate"
      - text: "set -e oprește scriptul la absolut orice eroare"
        explicatie: "FALS - are multiple excepții (if, ||, &&, !, etc.)"
      - text: "\"${arr[@]}\" cu ghilimele e necesar pentru iterare corectă"
        explicatie: "ADEVĂRAT - previne word splitting"
    
    raspuns_corect: 2
    
    explicatie: |
      set -e are excepții: comenzi în if/while, după || sau &&,
      comenzi negate cu !, funcții în context de test.

  - id: q18
    tema: "Consolidare"
    titlu: "Pattern Debug"
    bloom: analyse
    puncte: 6
    dificultate: medie
    timp_secunde: 75
    misconceptie_vizata: "Pattern-ul de debug condiționat"
    
    cod: |
      #!/bin/bash
      DEBUG="${DEBUG:-false}"
      
      process() {
          local file="$1"
          $DEBUG && echo "[DEBUG] Processing: $file" >&2
          # ... procesare
      }
    
    intrebare: "Ce face $DEBUG && echo ...?"
    
    optiuni:
      - text: "Întotdeauna afișează mesajul debug"
        explicatie: "Depinde de valoarea DEBUG"
      - text: "Afișează mesajul doar dacă DEBUG=\"true\""
        explicatie: "CORECT - $DEBUG se execută ca comandă"
      - text: "Afișează mesajul dacă DEBUG e orice valoare non-goală"
        explicatie: "false ca string nu e comandă validă"
      - text: "Eroare de sintaxă"
        explicatie: "Sintaxa e validă"
    
    raspuns_corect: 1
    
    explicatie: |
      $DEBUG se execută ca COMANDĂ.
      DEBUG="true" → comanda "true" reușește → echo se execută
      DEBUG="false" → comanda "false" eșuează → echo nu se execută
